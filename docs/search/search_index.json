{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"MOVING FORTH __ __ _ _____ _ _ | \\/ | _____ _(_)_ __ __ _ | ___|__ _ __| |_| |__ | |\\/| |/ _ \\ \\ / / | '_ \\ / _` | | |_ / _ \\| '__| __| '_ \\ | | | | (_) \\ V /| | | | | (_| | | _| (_) | | | |_| | | | |_| |_|\\___/ \\_/ |_|_| |_|\\__, | |_| \\___/|_| \\__|_| |_| |___/ Author: Brad Rodriguez Editor: E Furlan Website: http://efurlanm.github.io/movingforth Original sources: http://www.bradrodriguez.com/papers/ I decided to create this documentation because it was difficult for me to read, study and learn easily using the original documentation, plus the fact that I enjoy taking notes as I read. There were broken links, bad formatting on the smartphone screen, files were scattered, and so on, so I decided to put everything in one place, fix broken links, add more useful links and comments, move the pictures to SVG, and format it a little better to make the consultation and study easier. Everything I've done is under the CC BY 4.0 license, and all original sources are under the author's original license . Forth is a procedural, stack-oriented programming language and interactive environment designed by Charles H. Moore in 1968 at the United States National Radio Astronomy Observatory (NRAO), to help control radio telescopes. Today it is used in numerous spacecraft, such as the Rosetta/Philae probe which uses 10 RTX2010 processors that support direct execution of Forth. NASA has a list of space-related applications of the Forth , compiled by James Rash, at Goddard Space Flight Center Greenbelt, Maryland. Forth is generally targeted at small embedded systems and microcontrollers like the STM8 used in various consumer devices like chinese gadgets . What catches my attention in Forth is the possibility of being used running directly on the microcontroller using a REPL (Read-Eval-Print Loop) programming environment that allows the programmer to interact with a running program, experiment and obtain immediate results directly in the microcontroller, without the need for cross-compilation, which reduces development time. Other features are also useful, such as the ease of the interface and, because it is relatively simple, it is easy to deploy and optimize for a specific architecture. Moving Forth: a series on writing Forth kernels This series originally appeared in The Computer Journal . Accompanying source code can be found on the CamelForth page. Part 1: Design Decisions in the Forth Kernel Part 2: Benchmarks and Case Studies of Forth Kernels Part 3: Demystifying DOES> Part 4: Assemble or Metacompile? Part 5: The Z80 Primitives Part 6: The Z80 High-level Kernel Part 7: CamelForth for the 8051 Part 8: CamelForth for the 6809 Multitasking 8051 CamelForth Listings These listings are part of Moving Forth and are described in the text. Glossary : Glossary of words in CAMEL80.AZM Primitive testing code : The \"minimal\" test of the CamelForth kernel CAMEL80.AZM : Code Primitives CAMEL80H.AZM : High Level Words CAMEL80D.AZM : CPU and Model Dependencies CAMEL09 : Direct-Threaded Forth model for Motorola 6809 The Computer Journal (TCJ) The Computer Journal Home Page (Wayback Machine link) Scanned PDF files source: http://archive.org/details/the-computer-journal TCJ #52: B.Y.O. Assembler (1) (3.9 MB PDF file) [1] [2] TCJ #54: B.Y.O. Assembler (2) (2.7 MB PDF file) [1] [2] TCJ #59: Moving Forth (2.6 MB PDF file) [1] [2] TCJ #60: Moving Forth Part II (2.9 MB PDF file) [1] [2] TCJ #62: Moving Forth Part III (3.0 MB PDF file) [1] [2] TCJ #64: Moving Forth Part IV (3.4 MB PDF file) [1] [2] TCJ #67: Moving Forth Part 5 (3.1 MB PDF file) [1] [2] TCJ #69: Moving Forth Part 6 (3.7 MB PDF file) [1] [2] TCJ #71: Moving Forth Part 7 (3.2 MB PDF file) [1] [2] TCJ #72: Moving Forth Part 7.5 (3.1 MB PDF file) [1] [2] TCJ #74: Moving Forth Part 8 (4.0 MB PDF file) [1] [2] Forth Dimensions (FD) Source 1 : http://archive.org/details/forthdimension (scanned PDF files) Source 2 : http://www.forth.org/fd/FDcover.html (scanned PDF files) FD #XIII:6 \"Forth Systems Comparisons\" (21 MB PDF file) [1] [2] [3] FD #XIV:3 \"Principles of Metacompilation 1\" (21 MB PDF file) [1] [2] [3] FD #XIV:4 \"Principles of Metacompilation 2\" (21 MB PDF file) [1] [2] [3] FD #XIV:5 \"Principles of Metacompilation 3\" & \"Life in the FastForth Lane\" (22 MB PDF file) [1] [2] [3] FD #XIV:5 \"Principles of Metacompilation 3\" & \"Optimizing in a BSR/JSR Threaded Forth\" (22 MB PDF file) [1] [2] [3] This repository is permanently under construction, so its content changes constantly.","title":"MOVING FORTH"},{"location":"index.html#moving-forth","text":"__ __ _ _____ _ _ | \\/ | _____ _(_)_ __ __ _ | ___|__ _ __| |_| |__ | |\\/| |/ _ \\ \\ / / | '_ \\ / _` | | |_ / _ \\| '__| __| '_ \\ | | | | (_) \\ V /| | | | | (_| | | _| (_) | | | |_| | | | |_| |_|\\___/ \\_/ |_|_| |_|\\__, | |_| \\___/|_| \\__|_| |_| |___/ Author: Brad Rodriguez Editor: E Furlan Website: http://efurlanm.github.io/movingforth Original sources: http://www.bradrodriguez.com/papers/ I decided to create this documentation because it was difficult for me to read, study and learn easily using the original documentation, plus the fact that I enjoy taking notes as I read. There were broken links, bad formatting on the smartphone screen, files were scattered, and so on, so I decided to put everything in one place, fix broken links, add more useful links and comments, move the pictures to SVG, and format it a little better to make the consultation and study easier. Everything I've done is under the CC BY 4.0 license, and all original sources are under the author's original license . Forth is a procedural, stack-oriented programming language and interactive environment designed by Charles H. Moore in 1968 at the United States National Radio Astronomy Observatory (NRAO), to help control radio telescopes. Today it is used in numerous spacecraft, such as the Rosetta/Philae probe which uses 10 RTX2010 processors that support direct execution of Forth. NASA has a list of space-related applications of the Forth , compiled by James Rash, at Goddard Space Flight Center Greenbelt, Maryland. Forth is generally targeted at small embedded systems and microcontrollers like the STM8 used in various consumer devices like chinese gadgets . What catches my attention in Forth is the possibility of being used running directly on the microcontroller using a REPL (Read-Eval-Print Loop) programming environment that allows the programmer to interact with a running program, experiment and obtain immediate results directly in the microcontroller, without the need for cross-compilation, which reduces development time. Other features are also useful, such as the ease of the interface and, because it is relatively simple, it is easy to deploy and optimize for a specific architecture.","title":"MOVING FORTH"},{"location":"index.html#moving-forth-a-series-on-writing-forth-kernels","text":"This series originally appeared in The Computer Journal . Accompanying source code can be found on the CamelForth page. Part 1: Design Decisions in the Forth Kernel Part 2: Benchmarks and Case Studies of Forth Kernels Part 3: Demystifying DOES> Part 4: Assemble or Metacompile? Part 5: The Z80 Primitives Part 6: The Z80 High-level Kernel Part 7: CamelForth for the 8051 Part 8: CamelForth for the 6809 Multitasking 8051 CamelForth","title":"Moving Forth: a series on writing Forth kernels"},{"location":"index.html#listings","text":"These listings are part of Moving Forth and are described in the text. Glossary : Glossary of words in CAMEL80.AZM Primitive testing code : The \"minimal\" test of the CamelForth kernel CAMEL80.AZM : Code Primitives CAMEL80H.AZM : High Level Words CAMEL80D.AZM : CPU and Model Dependencies CAMEL09 : Direct-Threaded Forth model for Motorola 6809","title":"Listings"},{"location":"index.html#the-computer-journal-tcj","text":"The Computer Journal Home Page (Wayback Machine link) Scanned PDF files source: http://archive.org/details/the-computer-journal TCJ #52: B.Y.O. Assembler (1) (3.9 MB PDF file) [1] [2] TCJ #54: B.Y.O. Assembler (2) (2.7 MB PDF file) [1] [2] TCJ #59: Moving Forth (2.6 MB PDF file) [1] [2] TCJ #60: Moving Forth Part II (2.9 MB PDF file) [1] [2] TCJ #62: Moving Forth Part III (3.0 MB PDF file) [1] [2] TCJ #64: Moving Forth Part IV (3.4 MB PDF file) [1] [2] TCJ #67: Moving Forth Part 5 (3.1 MB PDF file) [1] [2] TCJ #69: Moving Forth Part 6 (3.7 MB PDF file) [1] [2] TCJ #71: Moving Forth Part 7 (3.2 MB PDF file) [1] [2] TCJ #72: Moving Forth Part 7.5 (3.1 MB PDF file) [1] [2] TCJ #74: Moving Forth Part 8 (4.0 MB PDF file) [1] [2]","title":"The Computer Journal (TCJ)"},{"location":"index.html#forth-dimensions-fd","text":"Source 1 : http://archive.org/details/forthdimension (scanned PDF files) Source 2 : http://www.forth.org/fd/FDcover.html (scanned PDF files) FD #XIII:6 \"Forth Systems Comparisons\" (21 MB PDF file) [1] [2] [3] FD #XIV:3 \"Principles of Metacompilation 1\" (21 MB PDF file) [1] [2] [3] FD #XIV:4 \"Principles of Metacompilation 2\" (21 MB PDF file) [1] [2] [3] FD #XIV:5 \"Principles of Metacompilation 3\" & \"Life in the FastForth Lane\" (22 MB PDF file) [1] [2] [3] FD #XIV:5 \"Principles of Metacompilation 3\" & \"Optimizing in a BSR/JSR Threaded Forth\" (22 MB PDF file) [1] [2] [3] This repository is permanently under construction, so its content changes constantly.","title":"Forth Dimensions (FD)"},{"location":"8051task.html","text":"MULTITASKING 8051 CAMELFORTH Brad Rodriguez, T-Recursive Technology This article describes a multitasking extension to the 8051 CamelForth system (described in TCJ #71 and #72). The techniques described here are not limited to Forth; they should be useful to any 8051 assembly-language programmer. CONTEXT SWITCHING When several tasks are sharing a processor, the information which is specific to any one task is called that task\u2019s \u201ccontext.\u201d This includes the current instruction pointer, CPU registers, subroutine return stack, and any other private data. CamelForth uses the 8051 registers as follows: Figure 1. 8051 register usage The registers labelled \u201cscratch\u201d may be used within Forth words, but have no guaranteed value between Forth words (except that the register select bits in PSW must always be 00 in 8051 CamelForth). The 8051 stack pointer SP points to the last byte actually stored in the Return stack. This stack grows from internal RAM location (register) 09 upward to 7F. In CamelForth, each task\u2019s private data is contained within a 768-byte \u201ctask area,\u201d organized as in Figure 2 . Figure 2. CamelForth task area All of this data is addressed relative to a pointer, UAREA, whose high byte is stored in register 8. (The Task Area is page-aligned, so the low byte of this pointer is always 00.) To make another Task Area current, only this pointer need be changed. Note that the start of the Task Area is 100h bytes before UAREA. So, to switch the from one task\u2019s context to another, the following steps must be taken: Save the \u201cimportant\u201d registers and the Return stack in external RAM, with the task\u2019s private data. This is is purpose of the \u201cTask Save Area\u201d in Figure 2. Switch the UAREA pointer to the new task\u2019s User Variables area. Restore the previously-saved registers and Return stack from the new task\u2019s Task Save Area. Resume execution. The code to do this is shown in Listing 1 , as a Forth word SWITCH. This word expects the address of the new task\u2019s Task Save Area on top of stack (i.e., in DPTR). Obviously, copying the Return stack out to the Task Save Area is the time-consuming step, so SWITCH includes a tight loop to copy registers N to 1 to external RAM, using R0 as the loop counter. The number of the highest register to be saved is contained in the Return stack pointer SP; this number is saved in the first byte of the Task Save Area. Since SWITCH is called as a subroutine, the program counter will already be pushed on the return stack (and thus saved by the copy loop). Register R0 (the Data stack pointer) is saved by copying it to R1 before the loop. DPTR doesn\u2019t need to be saved, since its contents can be discarded after the task is switched. On the other hand, R2-R5 are saved needlessly, since they don\u2019t need to be preserved across Forth words. But including them simplifies the loop, and will come in handy later. After SWITCH copies the current task\u2019s context out to RAM, it fetches the new task\u2019s context (specified by the address parameter passed to SWITCH). The process is simply the reverse of what was done to save the context. This assumes that the new Task Save Area contains the data saved when that task did a SWITCH. What about a brand-new task? The Forth word INITTASK sets up the Task Save Area for a new task. It saves 10 bytes in the Task Save Area: two bytes of return stack, and the eight registers 1 through 8. For register 8, the high byte of the User Variables area address is stored. For register 1, the low byte of the Parameter stack pointer, 0FD, is stored (this value will cause an empty stack once the task starts running). The \u201csaved\u201d return stack contains only a return address, which is where execution will begin when the task is started. So, to create and launch a new task: Reserve 768 bytes of storage for the Task Area. Call this area taskname . This name can be defined as a Forth CONSTANT, or by using CREATE if care is taken to keep the area page-aligned. Initialize the task to perform a Forth word , with the command \u2018 word taskname INITTASK Launch the new task with the command taskname SWITCH The \u201cmain\u201d CamelForth task will be suspended, and the new task will run. Beware: if the new task never does a SWITCH back to the main task, it will retain control forever! Listing 2 shows an example of how to define a task area in high RAM, by offsetting it below the main task\u2019s user area (thus ensuring page alignment). It also shows how to write a task that will do something and then return to the main task: after loading this program, every time you type TASK1 SWITCH , the 8051 will emit a bell character. ROUND-ROBIN TASK SWITCHING For true multitasking, each task must run for a short time, and then hand off control to another task...making sure that all of the defined tasks get a turn. One way to do this is to have each task switch to the \u201cnext\u201d task in the list. This can be done, clumsily, with SWITCH statements, as long as the list never changes (since task addresses are hard-coded in the program). A better way is to maintain a dynamic linked list of all tasks in RAM. Listing 3 shows high-level words to manage a linked list of tasks. The first cell of the user variables (at offset 0 from UAREA) is reserved in CamelForth for a task link. MYTASK always returns the address of the running task area, by offseting -100h from UAREA. DETACH empties the task list, by making the running task link back to itself. (This causes an inadvertent PAUSE to simply save and restore to the running task\u2019s context.) ATTACH adds a task to the list, inserting it immediately after the running task. Finally, PAUSE just causes a switch to the next task in the list. The secret to PAUSE is that it fetches a User variable, TASKLINK. User variables are always addressed relative to the current UAREA pointer, so whenever a task runs PAUSE, it fetches its link to the \u201cnext\u201d task. In this manner, all of the tasks are linked together in a circular list. (See Figure 3 .) Figure 3. Linked list of two tasks Listing 3 also includes the \u201cbell\u201d demo, this time written with PAUSE. Every time PAUSE is typed at the keyboard, a bell character is output. SWITCH can also be used to implement more complex task schedulers, by defining a \u201cdispatcher\u201d task (or a \u201cdispatcher\u201d Forth word). The dispatcher might, for example, select the task having highest-priority according to some rule. This is left as an exercise for the student. PRE-EMPTIVE TASK SWITCHING SWITCH and PAUSE require a task to voluntarily give up the CPU to other tasks. This \u201ccooperative\u201d multitasking is simple and efficient, and avoids many of the synchronization problems that can occur when many tasks share a resource. But poorly written tasks can \u201chog\u201d the CPU, and with even the best-written tasks, it\u2019s difficult to parcel out CPU time evenly. A preemptive multitasker uses some external event -- typically a timer interrupt -- to force a task switch. This ensures that tasks are switched regularly. But since a task switch can occur at any time -- not just between Forth words -- we must take pains to save all of the working registers that are used by CamelForth. SWITCH saves all of the working registers except R1-R3, DPH, DPL, ACC, B, and PSW. The simplest solution is for the interrupt to push these onto the return stack, and then call SWITCH with the address of the next task. When the round-robin returns to this task, SWITCH will return to the interrupt service routine, which will then pop these eight registers and return to wherever this task was suspended. A subroutine PREEMPT to do this is given in Listing 4 . Note that PREEMPT fetches the same task link as does PAUSE. We can\u2019t use ACALL PAUSE , since the phrase TASKLINK @ in PAUSE may destroy some registers that we haven\u2019t saved. (We could learn this by examining the kernel listing for USER and @, but it\u2019s bad form to build such hidden dependencies into kernel words.) Also, PREEMPT saves all of the \u201cextra\u201d registers on the Return stack, except DPH and DPL. This is because SWITCH, before returning to PREEMPT, pops DPH and DPL from the Data stack. Listing 4 also shows how to link PREEMPT to a timer interrupt, and initialize the timer. Listing 5 is the corresponding high-level test code. Once TASK1 is ATTACHed, the variable TICKS should increment every 65.536 msec (with a 12 MHz oscillator), and yet there should be no visible effect on normal Forth operation. Note the use of PAUSE to return control immediately to the \u201cmain\u201d task, after the interrupt is processed. A disadvantage of this approach is that the RETI instruction, required by the 8051\u2019s interrupt processing hardware, is not executed until the preempted task is resumed. For a simple example this is tolerable. To avoid this problem, PREEMPT should call a second copy of SWITCH, identical except that it ends with a RETI. Then PREEMPT should end with a RET. Also, the preemptive multitasker could be made slightly more efficient if SWITCH saved all working registers (i.e., if PREEMPT were merged into the SWITCH routine). But this adds unnecessary overhead to the \u201ccooperative\u201d SWITCH. The code presented here clearly shows the extra context-switching overhead of a preemptive multitasker. LISTING 1 ; =============================================== ; CamelForth Multitasker for the Intel 8051 ; (c) 1996 Bradford J. Rodriguez ; Permission is granted to freely copy, modify, ; and distribute this program for personal or ; educational use. Commercial inquiries should ; be directed to the author at 115 First St., ; #105, Collingwood, Ontario L9Y 4W3 Canada ; =============================================== .equ dr1,h'01 ; r1 as direct register ; The key word of the multitasker is SWITCH. ; It saves the working registers AND the return ; stack of the currently executing task to a ; storage area in external RAM. Then it gets ; the saved registers and return stack of the ; new task, restores them, and continues ; execution wherever the new task left off. ; ; Registers as they are saved: ; 01 (R1): saved Parameter Stack pointer. ; 02 (R2): future use ; 03 (R3): \" ; 04 (R4): \" ; 05 (R5): \" ; 06 (R6): loop index ; 07 (R7): \" ; 08: P2, User Area pointer high ; 09...N: return stack (N is given by SP) ; ; DPTR is not saved, since it is consumed by ; SWITCH. (It is the address of the new task's ; save area, UAREA-100h.) ; ; Note that these are stored backwards in ; external RAM, starting at address UAREA-100h. ; Thus the save area of a newly created task ; should look like: ; SP: 0Ah ; 0A,09: init'l Program Counter, hi byte first ; 08: task's User Pointer high (stack page) ; 07,06: xxx ; 05,04: xxx ; 03,02: xxx ; 01: 0FDh, initial stack pointer ; The initial stack pointer must be FDh because ; of the poptos at the end of SWITCH. ; SWITCH a -- switch to new task .drw link .set link,*+1 .db 0,6,\"SWITCH\" SWITCH: mov r2,dph ; stash new task adrs mov r3,dpl mov dph,UP ; save me at UAREA-100h dec dph mov dpl,#h'0 mov dr1,r0 ; save my Pstack pointer ; This loop copies internal RAM, from location ; (SP) down to 01, to external RAM. 6+7n cycles. ; The length is saved as the first byte. mov a,sp ; sp=high address, movx @dptr,a ; =length. inc dptr mov r0,a ; 00 won't be moved saveregs: mov a,@r0 ; 1 cycle movx @dptr,a ; 2 cycles inc dptr ; 2 cycles djnz r0,saveregs ; 2 cycles mov dph,r2 ; now get new task mov dpl,r3 ; This loop copies external RAM to internal RAM, ; and restores SP accordingly. 6+7n cycles. movx a,@dptr ; get high address inc dptr mov sp,a ; restore Rstack pointer mov r0,a getregs: movx a,@dptr inc dptr mov @r0,a djnz r0,getregs ; The top of this restored return stack contains ; a return address in the new task. DPTR no ; longer contains its top-of-stack; so pop the ; new top of stack from RAM. mov r0,dr1 ; restore Pstack pointer mov p2,UP ; set new stack page ljmp poptos ; pop TOS and return ; ----------------------------------------------- ; INITTASK xt a -- initialize a task area ; Given the xt (code address) of a Forth word to ; execute, and the address of a task's save area, ; fill in that save area so the given word will ; execute when that task is started. .drw link .set link,*+1 .db 0,8,\"INITTASK\" INITTASK: mov a,#h'0a ; length movx @dptr,a inc dptr movx a,@r0 ; low byte of xt inc r0 mov r2,a movx a,@r0 ; high byte of xt inc r0 movx @dptr,a ; store high byte first inc dptr mov a,r2 movx @dptr,a inc dptr mov a,dph ; UAREA=SaveArea+100h, so inc a ; DPH+1 = UAREA high byte movx @dptr,a inc dptr inc dptr ; skip 6 don't-cares inc dptr inc dptr inc dptr inc dptr inc dptr mov a,#h'fd ; initial Pstack pointer movx @dptr,a ljmp poptos LISTING 2 (MULTITASKER TEST) HEX U0 100 - CONSTANT TASK0 ( start of \"main\" Task Area) TASK0 300 - CONSTANT TASK1 ( new Task Area, 768 bytes ) ( lower) : TEST1 BEGIN 7 EMIT TASK0 SWITCH AGAIN ; ' TEST1 TASK1 INITTASK LISTING 3 (ROUND-ROBIN TASK LIST) HEX -100 USER MYTASK ( start of current Task Area) 0 USER TASKLINK ( link to next task in list) ( Initialize the task list to \"empty\".) : DETACH MYTASK TASKLINK ! ; ( Insert a new task into the linked list, immediately) ( after the current task.) : ATTACH ( a -- ) TASKLINK @ ( my previous successor) OVER TASKLINK ! ( new task becomes my successor) SWAP 100 + ! ; ( prev. successor becomes new) ( task's successor) ( Switch to the next task in the list.) : PAUSE TASKLINK @ SWITCH ; ( EXAMPLE) DETACH MYTASK CONSTANT TASK0 TASK0 300 - CONSTANT TASK1 : TEST1 BEGIN 7 EMIT PAUSE AGAIN ; ' TEST1 TASK1 INITTASK TASK1 ATTACH LISTING 4 ; ----------------------------------------------- ; PREEMPT force a task switch ; If entered from an interrupt, this will cause ; a switch to the next task in the round robin. ; The task link must be in the first cell of the ; user area (user variable U0). Note that this ; is an assembler subroutine and must not be ; called as a Forth word. PREEMPT: push psw ; save regs used by SWITCH push acc push b push dr1 push dr2 push dr3 lcall pushtos ; DPTR saved on Data stack! mov dph,UP ; fetch task link... mov dpl,#0 movx a,@dptr mov r2,a inc dptr movx a,@dptr mov dpl,r2 mov dph,a ; ...to DPTR acall SWITCH ; switch to next task ; Execution will resume here when the round-robin ; comes back to this task. Note that the last ; action of SWITCH is to restore DPH:DPL from the ; Data stack, with \"poptos\". pop dr3 ; restore regs pop dr2 pop dr1 pop b pop acc pop psw reti ; ----------------------------------------------- ; Sample timer 0 interrupt, entered when timer 0 ; rolls over from FFFF to 0000. The interrupt ; flag is automatically cleared when the ; interrupt service routine is entered. CLOCK: sjmp PREEMPT ; CLOCKON starts timer 0 & enables the interrupt .drw link .set link,*+1 .db 0,7,\"CLOCKON\" CLOCKON: mov tmod,#h'21 ; T1 mode 2, T0 mode 1 mov th0,#h'0 mov tl0,#h'0 setb tcon.4 ; enable timer 0 mov ie,#h'82 ; enable timer 0 irpt ret ; CLOCKOFF stops timer 0 & disables the interrupt .drw link .set link,*+1 .db 0,8,\"CLOCKOFF\" CLOCKOFF: clr tcon.4 ; disable timer 0 clr ie.1 ; enable timer 0 irpt ret LISTING 5 (PREEMPTIVE MULTITASKING TEST) (requires round-robin support words) DETACH ( reset task list) VARIABLE TICKS : TEST2 BEGIN 1 TICKS +! PAUSE AGAIN ; ' TEST2 TASK1 INITTASK TASK1 ATTACH ( add TASK1 to task list)","title":"MULTITASKING 8051 CAMELFORTH"},{"location":"8051task.html#multitasking-8051-camelforth","text":"Brad Rodriguez, T-Recursive Technology This article describes a multitasking extension to the 8051 CamelForth system (described in TCJ #71 and #72). The techniques described here are not limited to Forth; they should be useful to any 8051 assembly-language programmer.","title":"MULTITASKING 8051 CAMELFORTH"},{"location":"8051task.html#context-switching","text":"When several tasks are sharing a processor, the information which is specific to any one task is called that task\u2019s \u201ccontext.\u201d This includes the current instruction pointer, CPU registers, subroutine return stack, and any other private data. CamelForth uses the 8051 registers as follows: Figure 1. 8051 register usage The registers labelled \u201cscratch\u201d may be used within Forth words, but have no guaranteed value between Forth words (except that the register select bits in PSW must always be 00 in 8051 CamelForth). The 8051 stack pointer SP points to the last byte actually stored in the Return stack. This stack grows from internal RAM location (register) 09 upward to 7F. In CamelForth, each task\u2019s private data is contained within a 768-byte \u201ctask area,\u201d organized as in Figure 2 . Figure 2. CamelForth task area All of this data is addressed relative to a pointer, UAREA, whose high byte is stored in register 8. (The Task Area is page-aligned, so the low byte of this pointer is always 00.) To make another Task Area current, only this pointer need be changed. Note that the start of the Task Area is 100h bytes before UAREA. So, to switch the from one task\u2019s context to another, the following steps must be taken: Save the \u201cimportant\u201d registers and the Return stack in external RAM, with the task\u2019s private data. This is is purpose of the \u201cTask Save Area\u201d in Figure 2. Switch the UAREA pointer to the new task\u2019s User Variables area. Restore the previously-saved registers and Return stack from the new task\u2019s Task Save Area. Resume execution. The code to do this is shown in Listing 1 , as a Forth word SWITCH. This word expects the address of the new task\u2019s Task Save Area on top of stack (i.e., in DPTR). Obviously, copying the Return stack out to the Task Save Area is the time-consuming step, so SWITCH includes a tight loop to copy registers N to 1 to external RAM, using R0 as the loop counter. The number of the highest register to be saved is contained in the Return stack pointer SP; this number is saved in the first byte of the Task Save Area. Since SWITCH is called as a subroutine, the program counter will already be pushed on the return stack (and thus saved by the copy loop). Register R0 (the Data stack pointer) is saved by copying it to R1 before the loop. DPTR doesn\u2019t need to be saved, since its contents can be discarded after the task is switched. On the other hand, R2-R5 are saved needlessly, since they don\u2019t need to be preserved across Forth words. But including them simplifies the loop, and will come in handy later. After SWITCH copies the current task\u2019s context out to RAM, it fetches the new task\u2019s context (specified by the address parameter passed to SWITCH). The process is simply the reverse of what was done to save the context. This assumes that the new Task Save Area contains the data saved when that task did a SWITCH. What about a brand-new task? The Forth word INITTASK sets up the Task Save Area for a new task. It saves 10 bytes in the Task Save Area: two bytes of return stack, and the eight registers 1 through 8. For register 8, the high byte of the User Variables area address is stored. For register 1, the low byte of the Parameter stack pointer, 0FD, is stored (this value will cause an empty stack once the task starts running). The \u201csaved\u201d return stack contains only a return address, which is where execution will begin when the task is started. So, to create and launch a new task: Reserve 768 bytes of storage for the Task Area. Call this area taskname . This name can be defined as a Forth CONSTANT, or by using CREATE if care is taken to keep the area page-aligned. Initialize the task to perform a Forth word , with the command \u2018 word taskname INITTASK Launch the new task with the command taskname SWITCH The \u201cmain\u201d CamelForth task will be suspended, and the new task will run. Beware: if the new task never does a SWITCH back to the main task, it will retain control forever! Listing 2 shows an example of how to define a task area in high RAM, by offsetting it below the main task\u2019s user area (thus ensuring page alignment). It also shows how to write a task that will do something and then return to the main task: after loading this program, every time you type TASK1 SWITCH , the 8051 will emit a bell character.","title":"CONTEXT SWITCHING"},{"location":"8051task.html#round-robin-task-switching","text":"For true multitasking, each task must run for a short time, and then hand off control to another task...making sure that all of the defined tasks get a turn. One way to do this is to have each task switch to the \u201cnext\u201d task in the list. This can be done, clumsily, with SWITCH statements, as long as the list never changes (since task addresses are hard-coded in the program). A better way is to maintain a dynamic linked list of all tasks in RAM. Listing 3 shows high-level words to manage a linked list of tasks. The first cell of the user variables (at offset 0 from UAREA) is reserved in CamelForth for a task link. MYTASK always returns the address of the running task area, by offseting -100h from UAREA. DETACH empties the task list, by making the running task link back to itself. (This causes an inadvertent PAUSE to simply save and restore to the running task\u2019s context.) ATTACH adds a task to the list, inserting it immediately after the running task. Finally, PAUSE just causes a switch to the next task in the list. The secret to PAUSE is that it fetches a User variable, TASKLINK. User variables are always addressed relative to the current UAREA pointer, so whenever a task runs PAUSE, it fetches its link to the \u201cnext\u201d task. In this manner, all of the tasks are linked together in a circular list. (See Figure 3 .) Figure 3. Linked list of two tasks Listing 3 also includes the \u201cbell\u201d demo, this time written with PAUSE. Every time PAUSE is typed at the keyboard, a bell character is output. SWITCH can also be used to implement more complex task schedulers, by defining a \u201cdispatcher\u201d task (or a \u201cdispatcher\u201d Forth word). The dispatcher might, for example, select the task having highest-priority according to some rule. This is left as an exercise for the student.","title":"ROUND-ROBIN TASK SWITCHING"},{"location":"8051task.html#pre-emptive-task-switching","text":"SWITCH and PAUSE require a task to voluntarily give up the CPU to other tasks. This \u201ccooperative\u201d multitasking is simple and efficient, and avoids many of the synchronization problems that can occur when many tasks share a resource. But poorly written tasks can \u201chog\u201d the CPU, and with even the best-written tasks, it\u2019s difficult to parcel out CPU time evenly. A preemptive multitasker uses some external event -- typically a timer interrupt -- to force a task switch. This ensures that tasks are switched regularly. But since a task switch can occur at any time -- not just between Forth words -- we must take pains to save all of the working registers that are used by CamelForth. SWITCH saves all of the working registers except R1-R3, DPH, DPL, ACC, B, and PSW. The simplest solution is for the interrupt to push these onto the return stack, and then call SWITCH with the address of the next task. When the round-robin returns to this task, SWITCH will return to the interrupt service routine, which will then pop these eight registers and return to wherever this task was suspended. A subroutine PREEMPT to do this is given in Listing 4 . Note that PREEMPT fetches the same task link as does PAUSE. We can\u2019t use ACALL PAUSE , since the phrase TASKLINK @ in PAUSE may destroy some registers that we haven\u2019t saved. (We could learn this by examining the kernel listing for USER and @, but it\u2019s bad form to build such hidden dependencies into kernel words.) Also, PREEMPT saves all of the \u201cextra\u201d registers on the Return stack, except DPH and DPL. This is because SWITCH, before returning to PREEMPT, pops DPH and DPL from the Data stack. Listing 4 also shows how to link PREEMPT to a timer interrupt, and initialize the timer. Listing 5 is the corresponding high-level test code. Once TASK1 is ATTACHed, the variable TICKS should increment every 65.536 msec (with a 12 MHz oscillator), and yet there should be no visible effect on normal Forth operation. Note the use of PAUSE to return control immediately to the \u201cmain\u201d task, after the interrupt is processed. A disadvantage of this approach is that the RETI instruction, required by the 8051\u2019s interrupt processing hardware, is not executed until the preempted task is resumed. For a simple example this is tolerable. To avoid this problem, PREEMPT should call a second copy of SWITCH, identical except that it ends with a RETI. Then PREEMPT should end with a RET. Also, the preemptive multitasker could be made slightly more efficient if SWITCH saved all working registers (i.e., if PREEMPT were merged into the SWITCH routine). But this adds unnecessary overhead to the \u201ccooperative\u201d SWITCH. The code presented here clearly shows the extra context-switching overhead of a preemptive multitasker.","title":"PRE-EMPTIVE TASK SWITCHING"},{"location":"8051task.html#listing-1","text":"; =============================================== ; CamelForth Multitasker for the Intel 8051 ; (c) 1996 Bradford J. Rodriguez ; Permission is granted to freely copy, modify, ; and distribute this program for personal or ; educational use. Commercial inquiries should ; be directed to the author at 115 First St., ; #105, Collingwood, Ontario L9Y 4W3 Canada ; =============================================== .equ dr1,h'01 ; r1 as direct register ; The key word of the multitasker is SWITCH. ; It saves the working registers AND the return ; stack of the currently executing task to a ; storage area in external RAM. Then it gets ; the saved registers and return stack of the ; new task, restores them, and continues ; execution wherever the new task left off. ; ; Registers as they are saved: ; 01 (R1): saved Parameter Stack pointer. ; 02 (R2): future use ; 03 (R3): \" ; 04 (R4): \" ; 05 (R5): \" ; 06 (R6): loop index ; 07 (R7): \" ; 08: P2, User Area pointer high ; 09...N: return stack (N is given by SP) ; ; DPTR is not saved, since it is consumed by ; SWITCH. (It is the address of the new task's ; save area, UAREA-100h.) ; ; Note that these are stored backwards in ; external RAM, starting at address UAREA-100h. ; Thus the save area of a newly created task ; should look like: ; SP: 0Ah ; 0A,09: init'l Program Counter, hi byte first ; 08: task's User Pointer high (stack page) ; 07,06: xxx ; 05,04: xxx ; 03,02: xxx ; 01: 0FDh, initial stack pointer ; The initial stack pointer must be FDh because ; of the poptos at the end of SWITCH. ; SWITCH a -- switch to new task .drw link .set link,*+1 .db 0,6,\"SWITCH\" SWITCH: mov r2,dph ; stash new task adrs mov r3,dpl mov dph,UP ; save me at UAREA-100h dec dph mov dpl,#h'0 mov dr1,r0 ; save my Pstack pointer ; This loop copies internal RAM, from location ; (SP) down to 01, to external RAM. 6+7n cycles. ; The length is saved as the first byte. mov a,sp ; sp=high address, movx @dptr,a ; =length. inc dptr mov r0,a ; 00 won't be moved saveregs: mov a,@r0 ; 1 cycle movx @dptr,a ; 2 cycles inc dptr ; 2 cycles djnz r0,saveregs ; 2 cycles mov dph,r2 ; now get new task mov dpl,r3 ; This loop copies external RAM to internal RAM, ; and restores SP accordingly. 6+7n cycles. movx a,@dptr ; get high address inc dptr mov sp,a ; restore Rstack pointer mov r0,a getregs: movx a,@dptr inc dptr mov @r0,a djnz r0,getregs ; The top of this restored return stack contains ; a return address in the new task. DPTR no ; longer contains its top-of-stack; so pop the ; new top of stack from RAM. mov r0,dr1 ; restore Pstack pointer mov p2,UP ; set new stack page ljmp poptos ; pop TOS and return ; ----------------------------------------------- ; INITTASK xt a -- initialize a task area ; Given the xt (code address) of a Forth word to ; execute, and the address of a task's save area, ; fill in that save area so the given word will ; execute when that task is started. .drw link .set link,*+1 .db 0,8,\"INITTASK\" INITTASK: mov a,#h'0a ; length movx @dptr,a inc dptr movx a,@r0 ; low byte of xt inc r0 mov r2,a movx a,@r0 ; high byte of xt inc r0 movx @dptr,a ; store high byte first inc dptr mov a,r2 movx @dptr,a inc dptr mov a,dph ; UAREA=SaveArea+100h, so inc a ; DPH+1 = UAREA high byte movx @dptr,a inc dptr inc dptr ; skip 6 don't-cares inc dptr inc dptr inc dptr inc dptr inc dptr mov a,#h'fd ; initial Pstack pointer movx @dptr,a ljmp poptos","title":"LISTING 1"},{"location":"8051task.html#listing-2","text":"(MULTITASKER TEST) HEX U0 100 - CONSTANT TASK0 ( start of \"main\" Task Area) TASK0 300 - CONSTANT TASK1 ( new Task Area, 768 bytes ) ( lower) : TEST1 BEGIN 7 EMIT TASK0 SWITCH AGAIN ; ' TEST1 TASK1 INITTASK","title":"LISTING 2"},{"location":"8051task.html#listing-3","text":"(ROUND-ROBIN TASK LIST) HEX -100 USER MYTASK ( start of current Task Area) 0 USER TASKLINK ( link to next task in list) ( Initialize the task list to \"empty\".) : DETACH MYTASK TASKLINK ! ; ( Insert a new task into the linked list, immediately) ( after the current task.) : ATTACH ( a -- ) TASKLINK @ ( my previous successor) OVER TASKLINK ! ( new task becomes my successor) SWAP 100 + ! ; ( prev. successor becomes new) ( task's successor) ( Switch to the next task in the list.) : PAUSE TASKLINK @ SWITCH ; ( EXAMPLE) DETACH MYTASK CONSTANT TASK0 TASK0 300 - CONSTANT TASK1 : TEST1 BEGIN 7 EMIT PAUSE AGAIN ; ' TEST1 TASK1 INITTASK TASK1 ATTACH","title":"LISTING 3"},{"location":"8051task.html#listing-4","text":"; ----------------------------------------------- ; PREEMPT force a task switch ; If entered from an interrupt, this will cause ; a switch to the next task in the round robin. ; The task link must be in the first cell of the ; user area (user variable U0). Note that this ; is an assembler subroutine and must not be ; called as a Forth word. PREEMPT: push psw ; save regs used by SWITCH push acc push b push dr1 push dr2 push dr3 lcall pushtos ; DPTR saved on Data stack! mov dph,UP ; fetch task link... mov dpl,#0 movx a,@dptr mov r2,a inc dptr movx a,@dptr mov dpl,r2 mov dph,a ; ...to DPTR acall SWITCH ; switch to next task ; Execution will resume here when the round-robin ; comes back to this task. Note that the last ; action of SWITCH is to restore DPH:DPL from the ; Data stack, with \"poptos\". pop dr3 ; restore regs pop dr2 pop dr1 pop b pop acc pop psw reti ; ----------------------------------------------- ; Sample timer 0 interrupt, entered when timer 0 ; rolls over from FFFF to 0000. The interrupt ; flag is automatically cleared when the ; interrupt service routine is entered. CLOCK: sjmp PREEMPT ; CLOCKON starts timer 0 & enables the interrupt .drw link .set link,*+1 .db 0,7,\"CLOCKON\" CLOCKON: mov tmod,#h'21 ; T1 mode 2, T0 mode 1 mov th0,#h'0 mov tl0,#h'0 setb tcon.4 ; enable timer 0 mov ie,#h'82 ; enable timer 0 irpt ret ; CLOCKOFF stops timer 0 & disables the interrupt .drw link .set link,*+1 .db 0,8,\"CLOCKOFF\" CLOCKOFF: clr tcon.4 ; disable timer 0 clr ie.1 ; enable timer 0 irpt ret","title":"LISTING 4"},{"location":"8051task.html#listing-5","text":"(PREEMPTIVE MULTITASKING TEST) (requires round-robin support words) DETACH ( reset task list) VARIABLE TICKS : TEST2 BEGIN 1 TICKS +! PAUSE AGAIN ; ' TEST2 TASK1 INITTASK TASK1 ATTACH ( add TASK1 to task list)","title":"LISTING 5"},{"location":"camel09.html","text":"CamelForth for the Motorola 6809 (c) 1995 Bradford J. Rodriguez * Permission is granted to freely copy, modify, and * * distribute this program for personal or educational use. * * Commercial inquiries should be directed to the author at * * 221 King St. E., #32, Hamilton, Ontario L8N 1B5 Canada * Direct-Threaded Forth model for Motorola 6809 16 bit cell, 8 bit char, 8 bit (byte) adrs unit X = Forth W temporary address register Y = IP Interpreter Pointer U = RSP Return Stack Pointer S = PSP Parameter Stack Pointer D = TOS top parameter stack item DP = UP User Pointer (high byte) v1.0 alpha test version, 28 Apr 95 \\ 6809 Source Code: boot parameters (c) 28apr95 bjr HEX 0E000 FFFF DICTIONARY ROM ROM 7A00 EQU UP-INIT \\ UP must be page aligned. Stacks, 7A EQU UP-INIT-HI \\ TIB, etc. init'd relative to UP. 6000 EQU DP-INIT \\ starting RAM adrs for dictionary \\ SM2 memory map with 8K RAM: 6000-7BFF RAM, 7C00-7FFF I/O \\ Harvard synonyms - these must all be PRESUMEd AKA , I, AKA @ I@ AKA ! I! AKA C, IC, AKA C@ IC@ AKA C! IC! AKA HERE IHERE AKA ALLOT IALLOT PRESUME WORD AKA WORD IWORD \\ 6809 DTC: SCC initialization (c) 17apr95 bjr HERE EQU SCCATBL HEX 7C02 , 2500 , \\ port address, #bytes, reset reg ptr 09C0 , 0444 , 0100 , 0200 , 03C0 , 0560 , 0901 , 0A00 , 0B50 , 0C18 , 0D00 , 0E02 , 0E03 , 03C1 , 0568 , 0F00 , 1010 , 0100 , HERE EQU SCCBTBL 7C00 , 1F00 , \\ port address, #bytes, reset reg ptr 0444 , 0100 , 03C0 , 0560 , 0A00 , 0B50 , 0C18 , 0D00 , 0E02 , 0E03 , 03C1 , 0568 , 0F00 , 1010 , 0100 , \\ 0909 , ASM: HERE EQU SCCINIT \\ set up on-board i/o X ,++ LDY, X ,+ LDB, BEGIN, X ,+ LDA, Y 0, STA, DECB, EQ UNTIL, RTS, ;C \\ 6809 DTC: serial I/O (c) 31mar95 bjr HEX 7C02 EQU SCCACMD 7C03 EQU SCCADTA CODE KEY \\ -- c get char from serial port 6 # ( D) PSHS, BEGIN, SCCACMD LDB, 1 # ANDB, NE UNTIL, SCCADTA LDB, CLRA, NEXT ;C CODE KEY? \\ -- f return true if char waiting 6 # ( D) PSHS, CLRA, SCCACMD LDB, 1 # ANDB, NE IF, -1 # LDB, THEN, NEXT ;C CODE EMIT \\ c -- output character to serial port BEGIN, SCCACMD LDA, 4 # ANDA, NE UNTIL, SCCADTA STB, 6 # ( D) PULS, NEXT ;C \\ 6809 DTC: interpreter logic (c) 17apr95 bjr ASM: HERE RESOLVES DOCOLON HERE EQU <DOCOLON> HEX 20 # ( Y) PSHU, 20 # PULS, NEXT, ;C ASM: HERE RESOLVES DOCREATE HERE EQU <DOCREATE> 10 # ( X) PULS, 6 # ( D) PSHS, X D TFR, NEXT, ;C CODE EXIT \\ -- exit a colon definition HEX 20 # ( Y) PULU, NEXT ;C CODE LIT \\ -- x fetch inline literal to stack 6 # ( D) PSHS, Y ,++ LDD, NEXT ;C CODE EXECUTE \\ i*x xt -- j*x execute Forth word at 'xt' D X TFR, 6 # ( D) PULS, X 0, JMP, ;C \\ 6809 DTC: stack operations (c) 31mar95 bjr CODE DUP \\ x -- x x duplicate top of stack 6 # ( D) PSHS, NEXT ;C CODE ?DUP \\ x -- 0 | x x DUP if nonzero 0 # CMPD, NE IF, 6 # ( D) PSHS, THEN, NEXT ;C CODE DROP \\ x -- drop top of stack 6 # ( D) PULS, NEXT ;C CODE SWAP \\ x1 x2 -- x2 x1 swap top two items S 0, LDX, S 0, STD, X D TFR, NEXT ;C CODE OVER \\ x1 x2 -- x1 x2 x1 per stack diagram 6 # ( D) PSHS, S 2 , LDD, NEXT ;C \\ 6809 DTC: stack operations (c) 31mar95 bjr CODE ROT \\ x1 x2 x3 -- x2 x3 x1 per stack diagram S 0, LDX, S 0, STD, S 2 , LDD, S 2 , STX, NEXT ;C CODE NIP \\ x1 x2 -- x2 per stack diagram S 2 , LEAS, NEXT ;C CODE TUCK \\ x1 x2 -- x2 x1 x2 per stack diagram S 0, LDX, S 0, STD, HEX 10 # ( X) PSHS, NEXT ;C CODE >R \\ x -- R: -- x push to return stack 6 # ( D) PSHU, 6 # ( D) PULS, NEXT ;C CODE R> \\ -- x R: x -- pop from return stack 6 # ( D) PSHS, 6 # ( D) PULU, NEXT ;C \\ 6809 DTC: stack operations (c) 31mar95 bjr CODE R@ \\ -- x R: x -- x fetch from return stack 6 # ( D) PSHS, U 0, LDD, NEXT ;C CODE SP@ \\ -- a-addr get data stack pointer 6 # ( D) PSHS, S D TFR, NEXT ;C CODE SP! \\ a-addr -- set data stack pointer D S TFR, 6 # ( D) PULS, NEXT ;C CODE RP@ \\ -- a-addr get return stack pointer 6 # ( D) PSHS, U D TFR, NEXT ;C CODE RP! \\ a-addr -- set return stack pointer D U TFR, 6 # ( D) PULS, NEXT ;C \\ 6809 DTC: memory operations (c) 31mar95 bjr CODE ! \\ x a-addr -- store cell in memory D X TFR, 6 # ( D) PULS, X 0, STD, 6 # ( D) PULS, NEXT ;C CODE C! \\ char c-addr -- store char in memory D X TFR, 6 # ( D) PULS, X 0, STB, 6 # ( D) PULS, NEXT ;C CODE @ \\ a-addr -- x fetch cell from memory D X TFR, X 0, LDD, NEXT ;C CODE C@ \\ c-addr -- char fetch char from memory D X TFR, X 0, LDB, CLRA, NEXT ;C \\ 6809 DTC: arithmetic operations (c) 26apr95 bjr CODE + \\ n1/u1 n2/u2 -- n3/u3 add n1+n2 S ,++ ADDD, NEXT ;C CODE M+ \\ d n -- d add single to double S 2 , ADDD, S 2 , STD, 6 # ( D) PULS, 0 # ADCB, 0 # ADCA, NEXT ;C CODE - \\ n1/u1 n2/u2 -- n3/u3 subtract n1-n2 S ,++ SUBD, COMA, COMB, 1 # ADDD, NEXT ;C CODE NEGATE \\ x1 -- x2 two's complement COMA, COMB, 1 # ADDD, NEXT ;C \\ 6809 DTC: logical operations (c) 31mar95 bjr CODE AND \\ x1 x2 -- x3 logical AND S ,+ ANDA, S ,+ ANDB, NEXT ;C CODE OR \\ x1 x2 -- x3 logical OR S ,+ ORA, S ,+ ORB, NEXT ;C CODE XOR \\ x1 x2 -- c3 logical XOR S ,+ EORA, S ,+ EORB, NEXT ;C CODE INVERT \\ x1 -- x2 bitwise inversion COMA, COMB, NEXT ;C CODE >< \\ x1 -- x2 swap bytes A B EXG, NEXT ;C \\ 6809 DTC: arithmetic operations (c) 31mar95 bjr CODE 1+ \\ n1/u1 -- n2/u2 add 1 to TOS 1 # ADDD, NEXT ;C CODE 1- \\ n1/u1 -- n2/u2 subtract 1 from TOS 1 # SUBD, NEXT ;C CODE 2* \\ x1 -- x2 arithmetic left shift ASLB, ROLA, NEXT ;C CODE 2/ \\ x1 -- x2 arithmetic right shift ASRA, RORB, NEXT ;C CODE +! \\ n/u a-addr -- add cell to memory D X TFR, 6 # ( D) PULS, X 0, ADDD, X 0, STD, 6 # ( D) PULS, NEXT ;C \\ 6809 DTC: arithmetic operations (c) 31mar95 bjr CODE LSHIFT \\ x1 u -- x2 logical shift left u places D X TFR, 6 # ( D) PULS, X 0, LEAX, NE IF, BEGIN, LSLB, ROLA, X -1 , LEAX, EQ UNTIL, THEN, NEXT ;C CODE RSHIFT \\ x1 u -- x2 logical shift right u places D X TFR, 6 # ( D) PULS, X 0, LEAX, NE IF, BEGIN, LSRA, RORB, X -1 , LEAX, EQ UNTIL, THEN, NEXT ;C \\ 6809 DTC: comparison operations (c) 31mar95 bjr CODE 0= \\ n/u -- flag return true if TOS=0 0 # CMPD, EQ IF, HERE EQU TOSTRUE -1 # LDD, NEXT THEN, CLRA, CLRB, NEXT ;C CODE 0< \\ n/u -- flag true if TOS negative TSTA, TOSTRUE BMI, CLRA, CLRB, NEXT ;C CODE = \\ x1 x2 -- flag test x1=x2 S ,++ SUBD, TOSTRUE BEQ, CLRA, CLRB, NEXT ;C CODE <> \\ x1 x2 -- flag test not equal S ,++ SUBD, TOSTRUE BNE, CLRA, CLRB, NEXT ;C \\ 6809 DTC: comparison operations (c) 31mar95 bjr CODE < \\ n1 n2 -- flag test n1<n2, signed S ,++ SUBD, TOSTRUE BGT, CLRA, CLRB, NEXT ;C CODE > \\ n1 n2 -- flag test n1>n2, signed S ,++ SUBD, TOSTRUE BLT, CLRA, CLRB, NEXT ;C CODE U< \\ n1 n2 -- flag test n1<n2, unsigned S ,++ SUBD, TOSTRUE BHI, CLRA, CLRB, NEXT ;C CODE U> \\ n1 n2 -- flag test n1>n2, unsigned S ,++ SUBD, TOSTRUE BLO, CLRA, CLRB, NEXT ;C \\ 6809 DTC: branch and loop operations (c) 31mar95 bjr CODE BRANCH \\ -- branch always Y 0, LDY, NEXT ;C CODE ?BRANCH \\ x -- branch if TOS zero 0 # CMPD, EQ IF, 6 # ( D) PULS, Y 0, LDY, NEXT THEN, 6 # ( D) PULS, Y 2 , LEAY, NEXT ;C CODE (DO) \\ n1|u1 n2|u2 -- R: -- sys1 sys2 D X TFR, HEX 8000 # LDD, S ,++ SUBD, \\ fudg=8000-limit 6 # ( D) PSHU, X D, LEAX, 10 # ( X) PSHU, \\ start+fudg 6 # ( D) PULS, NEXT ;C CODE UNLOOP \\ -- R: sys1 sys2 -- drop loop parameters U 4 , LEAU, NEXT ;C \\ 6809 DTC: branch and loop operations (c) 31mar95 bjr CODE (LOOP) \\ R: sys1 sys2 -- | sys1 sys2 run-time for LOOP 6 # ( D) PSHS, U 0, LDD, 1 # ADDD, VC IF, HERE EQU TAKELOOP U 0, STD, Y 0, LDY, 6 # PULS, NEXT THEN, Y 2 , LEAY, U 4 , LEAU, 6 # PULS, NEXT ;C CODE (+LOOP) \\ n -- R: sys1 sys2 -- | sys1 sys2 for +LOOP U 0, ADDD, TAKELOOP BVC, Y 2 , LEAY, U 4 , LEAU, 6 # PULS, NEXT ;C CODE I \\ -- n R: sys1 sys2 -- sys1 sys2 loop index 6 # ( D) PSHS, U 0, LDD, U 2 , SUBD, NEXT ;C CODE J \\ -- n R: 4*sys -- 4*sys 2nd loop index 6 # ( D) PSHS, U 4 , LDD, U 6 , SUBD, NEXT ;C \\ 6809 DTC: multiply (c) 25apr95 bjr CODE UM* \\ u1 u2 -- ud 16*16->32 unsigned multiply 16 # ( X,D) PSHS, \\ push temporary, u2 S 5 , LDA, S 1 , LDB, MUL, S 2 , STD, \\ 1lo*2lo S 4 , LDA, S 1 , LDB, MUL, \\ 1hi*2lo S 2 , ADDB, 0 # ADCA, S 1 , STD, S 5 , LDA, S 0, LDB, MUL, \\ 1lo*2hi S 1 , ADDD, S 1 , STD, CLRA, ROLA, \\ cy in A S 0, LDB, S 0, STA, S 4 , LDA, MUL, \\ 2hi*1hi S 0, ADDD, \\ hi result in D S 2 , LDX, S 4 , LEAS, S 0, STX, NEXT ;C \\ lo result \\ 6809 DTC: divide (c) 25apr95 bjr CODE UM/MOD \\ ud u1 -- rem quot 32/16->16 divide HEX 6 # PSHS, 10 # LDX, \\ save u1 in mem S 5 , ASL, S 4 , ROL, \\ initial shift (lo 16) BEGIN, S 3 , ROL, S 2 , ROL, S 2 , LDD, \\ shift left hi 16 CS IF, \\ 1xxxx: 17 bits, subtract is ok S 0, SUBD, S 2 , STD, 0FE # ANDCC, \\ clear cy ELSE, \\ 0xxxx: 16 bits, test subtract S 0, SUBD, CC IF, S 2 , STD, THEN, \\ cs=can't subtr THEN, \\ cy=0 if sub ok, 1 if no subtract S 5 , ROL, S 4 , ROL, \\ rotate cy into result X -1 , LEAX, EQ UNTIL, \\ loop 16 times S 4 , LDD, COMA, COMB, \\ invert to get true quot in D S 2 , LDX, S 4 , STX, S 4 , LEAS, \\ save rem, clean stack NEXT ;C \\ 6809 DTC: block and string operations (c) 31mar95 bjr CODE FILL \\ c-addr u char -- fill mem with char HEX 20 # ( Y) PSHU, 30 # ( X,Y) PULS, \\ D=char X=u Y=adr 0 # CMPX, NE IF, BEGIN, Y ,+ STB, X -1 , LEAX, EQ UNTIL, THEN, 6 # ( D) PULS, 20 # ( Y) PULU, NEXT, ;C CODE S= \\ c-addr1 c-addr2 u -- n string compare 1:2 S 2 , ADDD, S 2 , LDX, S 2 , STY, \\ X=src D=end S 0, LDY, S 0, STD, CLRB, \\ Y=dst B=0 BEGIN, S 0, CMPX, NE WHILE, X ,+ LDA, Y ,+ SUBA, NE IF, 0 # SBCB, B A TFR, 1 # ORB, HEX 30 # ( X,Y) PULS, NEXT, THEN, REPEAT, B A TFR, HEX 30 # ( X,Y) PULS, NEXT, ;C \\ 6809 DTC: block and string operations (c) 31mar95 bjr CODE CMOVE \\ c-addr1 c-addr2 u -- move from bottom 1->2 S 2 , ADDD, S 2 , LDX, S 2 , STY, \\ X=src D=end S 0, LDY, S 0, STD, \\ Y=dst BEGIN, S 0, CMPX, NE WHILE, X ,+ LDB, Y ,+ STB, REPEAT, HEX 30 # ( X,Y) PULS, 6 # ( D) PULS, NEXT ;C CODE CMOVE> \\ c-addr1 c-addr2 u -- move from top 1->2 S 2 , LDX, X D, LEAX, S 2 , STY, \\ X=src D=u S 0, LDY, Y D, LEAY, \\ Y=dst BEGIN, S 0, CMPY, NE WHILE, X -, LDB, Y -, STB, REPEAT, HEX 30 # ( X,Y) PULS, 6 # ( D) PULS, NEXT ;C \\ 6809 DTC: block and string operations (c) 31mar95 bjr ASM: HERE EQU SKIPEXIT Y -1 , LEAY, HERE EQU SKIPDONE HEX 20 # PSHS, X D TFR, 20 # PULU, NEXT ;C CODE SKIP \\ c-addr u c -- c-addr' u' skip matching chars HEX 20 # ( Y) PSHU, 30 # ( X,Y) PULS, \\ D=char X=u Y=adr 0 # CMPX, NE IF, BEGIN, Y ,+ CMPB, SKIPEXIT BNE, X -1 , LEAX, EQ UNTIL, THEN, SKIPDONE BRA, ;C CODE SCAN \\ c-addr u c -- c-addr' u' find matching char HEX 20 # ( Y) PSHU, 30 # ( X,Y) PULS, \\ D=char X=u Y=adr 0 # CMPX, NE IF, BEGIN, Y ,+ CMPB, SKIPEXIT BEQ, X -1 , LEAX, EQ UNTIL, THEN, SKIPDONE BRA, ;C \\ 6809 DTC: system dependencies (c) 21apr95 bjr \\ These words are shorter in CODE than as colon definitions! CODE ALIGNED NEXT ;C \\ a1 -- a2 align address CODE ALIGN NEXT ;C \\ -- align HERE CODE CELL+ 2 # ADDD, NEXT ;C \\ a1 -- a2 add cell size CODE CELLS ASLB, ROLA, NEXT ;C \\ n1 -- n2 cells->adr units CODE CHAR+ 1 # ADDD, NEXT ;C \\ a1 -- a2 add char size CODE CHARS NEXT ;C \\ n1 -- n2 chars->adr units CODE >BODY 3 # ADDD, NEXT ;C \\ xt -- a-addr cfa->pfa AKA 1- CHAR- \\ Note: CELL, a constant, must be defined after CONSTANT. \\ 6809 DTC: system dependencies (c) 21apr95 bjr HEX : COMPILE, , ; \\ xt -- append execution tokn : !CF 0BD OVER C! 1+ ! ; \\ adrs cfa -- set code field : ,CF HERE !CF 3 ALLOT ; \\ adrs -- append code field : !COLON -3 ALLOT <DOCOLON> ,CF ; \\ -- changes last c.f. : ,EXIT ['] EXIT COMPILE, ; \\ -- append EXIT action : ,BRANCH , ; \\ xt -- append branch instr. : ,DEST , ; \\ dest -- append dest'n adrs : !DEST ! ; \\ dest adr -- change dest'n \\ 6809 DTC: dodoes (does>) does> (c) 18apr95 bjr ASM: HERE RESOLVES DODOES HERE EQU <DODOES> HEX 20 # ( Y) PSHU, 20 # ( Y) PULS, \\ adrs of DODOES code 10 # ( X) PULS, 6 # ( D) PSHS, X D TFR, \\ adrs of data NEXT, ;C DECIMAL \\ to keep ,CF from compiling as a hex number : (DOES>) R> LATEST @ NFA>CFA !CF ; : DOES> ['] (DOES>) COMPILE, <DODOES> ,CF ; IMMEDIATE \\ 6809 DTC: defining words (c) 21apr95 bjr : : CREATE HIDE ] !COLON ; : ; REVEAL ,EXIT [COMPILE] [ ; IMMEDIATE : CONSTANT CREATE , ;CODE HEX 10 # ( X) PULS, 6 # ( D) PSHS, X 0, LDD, NEXT, ;C EMULATE: TCREATE T, MDOES> T@ ;EMULATE : VARIABLE CREATE CELL ALLOT ; EMULATE: TCREATE 0 T, MDOES> ;EMULATE : USER CREATE , ;CODE HEX 10 # ( X) PULS, 6 # ( D) PSHS, \\ get pfa in X DPR A TFR, CLRB, X 0, ADDD, NEXT, ;C \\ UP+offset -> D EMULATE: TCREATE T, MDOES> .UNDEF ;EMULATE \\ High level: control structures (c) 21apr95 bjr : IF \\ -- adrs conditional forward branch ['] ?BRANCH ,BRANCH HERE DUP ,DEST ; EMULATE: M['] ?BRANCH T, THERE DUP T, ;EMULATE IMMEDIATE : THEN \\ adrs -- resolve forward branch HERE SWAP !DEST ; EMULATE: THERE SWAP T! ;EMULATE IMMEDIATE : ELSE \\ adrs1 -- adrs2 branch for IF..ELSE ['] BRANCH ,BRANCH HERE DUP ,DEST SWAP [COMPILE] THEN ; EMULATE: M['] BRANCH T, THERE DUP T, SWAP THERE SWAP T! ;EMULATE IMMEDIATE \\ High level: control structures (c) 21apr95 bjr : BEGIN HERE ; \\ -- adrs target for backward branch EMULATE: THERE ;EMULATE IMMEDIATE : UNTIL \\ adrs -- conditional backward branch ['] ?BRANCH ,BRANCH ,DEST ; EMULATE: M['] ?BRANCH T, T, ;EMULATE IMMEDIATE : AGAIN \\ adrs -- unconditional backward branch ['] BRANCH ,BRANCH ,DEST ; EMULATE: M['] BRANCH T, T, ;EMULATE IMMEDIATE : WHILE \\ -- adrs branch for WHILE loop [COMPILE] IF ; EMULATE: M['] ?BRANCH T, THERE DUP T, ;EMULATE IMMEDIATE \\ High level: control structures (c) 21apr95 bjr : REPEAT \\ adrs1 adrs2 --- resolve WHILE loop SWAP [COMPILE] AGAIN [COMPILE] THEN ; EMULATE: SWAP M['] BRANCH T, T, THERE SWAP T! ;EMULATE IMMEDIATE : >L CELL LP +! LP @ ! ; : L> LP @ @ CELL NEGATE LP +! ; : DO \\ -- adrs L: -- 0 ['] (DO) ,BRANCH HERE 0 >L ; EMULATE: M['] (DO) T, THERE 0 T>L ;EMULATE IMMEDIATE : LEAVE ['] UNLOOP COMPILE, ['] BRANCH ,BRANCH HERE DUP ,DEST >L ; EMULATE: M['] UNLOOP T, M['] BRANCH T, THERE DUP T, T>L ;EMULATE IMMEDIATE \\ High level: control structures (c) 21apr95 bjr : ENDLOOP ,BRANCH ,DEST \\ adrs xt -- L: 0 a1 a2 .. aN -- BEGIN L> ?DUP WHILE [COMPILE] THEN REPEAT ; ALSO FORTH ALSO META DEFINITIONS : TENDLOOP T, T, BEGIN TL> ?DUP WHILE THERE SWAP T! REPEAT ; PREVIOUS PREVIOUS DEFINITIONS : LOOP ['] (LOOP) ENDLOOP ; EMULATE: M['] (LOOP) TENDLOOP ;EMULATE IMMEDIATE : +LOOP ['] (+LOOP) ENDLOOP ; EMULATE: M['] (+LOOP) TENDLOOP ;EMULATE IMMEDIATE \\ High level: system variables and constants (c) 21apr95 bjr HEX 2 CONSTANT CELL \\ system dependent constant 20 CONSTANT BL 7E CONSTANT TIBSIZE \\ High level: system variables and constants (c) 31mar95 bjr HEX -80 USER TIB \\ -- a-addr Terminal Input Buffer 0 USER U0 \\ -- a-addr current user area adrs 2 USER >IN \\ -- a-addr holds offset into TIB 4 USER BASE \\ -- a-addr holds conversion radix 6 USER STATE \\ -- a-addr holds compiler state 8 USER DP \\ -- a-addr holds dictionary pointer 0A USER 'SOURCE \\ -- a-addr two cells: length, address 0E USER LATEST \\ -- a-addr last word in dictionary 10 USER HP \\ -- a-addr HOLD pointer 12 USER LP \\ -- a-addr leave-stack pointer 100 USER S0 \\ -- a-addr end of parameter stack 128 USER PAD \\ -- a-addr user PAD buffer/end of hold 180 USER L0 \\ -- a-addr bottom of leave stack 200 USER R0 \\ -- a-addr end of return stack \\ High level: arithmetic operators (c) 31mar95 bjr : S>D \\ n -- d single -> double precision DUP 0< ; : ?NEGATE \\ n1 n2 -- n3 negate n1 if n2 negative 0< IF NEGATE THEN ; : ABS \\ n1 -- n2 absolute value DUP ?NEGATE ; : DNEGATE \\ d1 -- d2 negate, double precision SWAP INVERT SWAP INVERT 1 M+ ; : ?DNEGATE \\ d1 n -- d2 negate d1 if n negative 0< IF DNEGATE THEN ; : DABS \\ d1 -- d2 absolute value, double precision DUP ?DNEGATE ; \\ High level: arithmetic operators (c) 31mar95 bjr : M* \\ n1 n2 -- d signed 16*16->32 multiply 2DUP XOR >R SWAP ABS SWAP ABS UM* R> ?DNEGATE ; : SM/REM \\ d1 n1 -- n2 n3 symmetric signed division 2DUP XOR >R OVER >R ABS >R DABS R> UM/MOD SWAP R> ?NEGATE SWAP R> ?NEGATE ; \\ High level: arithmetic operators (c) 31mar95 bjr : FM/MOD \\ d1 n1 -- n2 n3 floored signed division DUP >R SM/REM DUP 0< IF SWAP R> + SWAP 1- ELSE R> DROP THEN ; : * \\ n1 n2 -- n3 signed multiply M* DROP ; : /MOD \\ n1 n2 -- n3 n4 signed divide/remainder >R S>D R> FM/MOD ; : / \\ n1 n2 -- n3 signed divide /MOD NIP ; \\ High level: arithmetic operators (c) 31mar95 bjr : MOD \\ n1 n2 -- n3 signed remainder /MOD DROP ; : */MOD \\ n1 n2 n3 -- n4 n5 n1*n2/n3, remainder&quotient >R M* R> FM/MOD ; : */ \\ n1 n2 n3 -- n4 n1*n2/n3 */MOD NIP ; : MAX \\ n1 n2 -- n3 signed maximum 2DUP < IF SWAP THEN DROP ; : MIN \\ n1 n2 -- n3 signed minimum 2DUP > IF SWAP THEN DROP ; \\ High level: double operators (c) 31mar95 bjr : 2@ \\ a-addr -- x1 x2 fetch 2 cells DUP CELL+ @ SWAP @ ; : 2! \\ x1 x2 a-addr -- store 2 cells SWAP OVER ! CELL+ ! ; : 2DROP \\ x1 x2 -- drop 2 cells DROP DROP ; : 2DUP \\ x1 x2 -- x1 x2 x1 x2 dup top 2 cells OVER OVER ; : 2SWAP \\ x1 x2 x3 x4 -- x3 x4 x1 x2 per diagram ROT >R ROT R> ; : 2OVER \\ x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 per diagram >R >R 2DUP R> R> 2SWAP ; \\ High level: input/output (c) 31mar95 bjr HEX : COUNT \\ c-addr1 -- c-addr2 u counted->addr/length DUP CHAR+ SWAP C@ ; : CR \\ -- output newline 0D EMIT 0A EMIT ; : SPACE \\ -- output a space BL EMIT ; : SPACES \\ u -- output u spaces BEGIN DUP WHILE SPACE 1- REPEAT DROP ; : UMIN \\ u1 u2 -- u unsigned minimum 2DUP U> IF SWAP THEN DROP ; : UMAX \\ u1 u2 -- u unsigned maximum 2DUP U< IF SWAP THEN DROP ; \\ High level: input/output (c) 31mar95 bjr : ACCEPT \\ c-addr +n -- +n' get line from terminal OVER + 1- OVER BEGIN KEY DUP 0D <> WHILE DUP EMIT DUP 8 = IF DROP 1- >R OVER R> UMAX ELSE OVER C! 1+ OVER UMIN THEN REPEAT DROP NIP SWAP - ; : TYPE \\ c-addr +n -- type line to terminal ?DUP IF OVER + SWAP DO I C@ EMIT LOOP ELSE DROP THEN ; \\ High level: input/output (c) 31mar95 bjr : (S\") \\ -- c-addr u run-time code for S\" R> COUNT 2DUP + ALIGN >R ; ALSO FORTH ALSO META DEFINITIONS : TS\" 22 WORD DUP C@ 1+ THERE OVER TALLOT SWAP >TCMOVE ; PREVIOUS PREVIOUS DEFINITIONS : S\" \\ -- compile in-line string ['] (S\") COMPILE, 22 WORD C@ 1+ ALIGNED ALLOT ; EMULATE: M['] (S\") T, TS\" ;EMULATE IMMEDIATE : .\" \\ -- compile string to print [COMPILE] S\" ['] TYPE COMPILE, ; EMULATE: M['] (S\") T, TS\" M['] TYPE T, ;EMULATE IMMEDIATE \\ High level: numeric output (c) 31mar95 bjr : UD/MOD \\ ud1 u2 -- u3 ud4 32/16->32 divide >R 0 R@ UM/MOD ROT ROT R> UM/MOD ROT ; : UD* \\ ud1 u2 -- ud3 32*16->32 multiply DUP >R UM* DROP SWAP R> UM* ROT + ; : HOLD \\ char -- add char to output string -1 HP +! HP @ C! ; : <# \\ -- begin numeric conversion PAD HP ! ; : >DIGIT \\ n -- c convert to 0..9A..Z DUP 9 > 7 AND + 30 + ; : # \\ ud1 -- ud2 convert 1 digit of output BASE @ UD/MOD ROT >DIGIT HOLD ; : #S \\ ud1 -- ud2 convert remaining digits BEGIN # 2DUP OR 0= UNTIL ; \\ High level: numeric output (c) 31mar95 bjr : #> \\ ud1 -- c-addr u end conversion, get string 2DROP HP @ PAD OVER - ; : SIGN \\ n -- add minus sign if n<0 0< IF 2D HOLD THEN ; : U. \\ u -- display u unsigned <# 0 #S #> TYPE SPACE ; : . \\ n -- display n signed <# DUP ABS 0 #S ROT SIGN #> TYPE SPACE ; : DECIMAL \\ -- set number base to decimal 0A BASE ! ; : HEX \\ -- set number base to hex 10 BASE ! ; \\ High level: dictionary management (c) 31mar95 bjr : HERE \\ -- addr returns dictionary ptr DP @ ; : ALLOT \\ n -- allocate n adr units in dict DP +! ; : , \\ x -- append cell to dict HERE ! 1 CELLS ALLOT ; : C, \\ char -- append char to dict HERE C! 1 CHARS ALLOT ; \\ High level: interpreter (c) 31mar95 bjr : SOURCE \\ -- adr n current input buffer 'SOURCE 2@ ; : /STRING \\ a u n -- a+n u-n trim string ROT OVER + ROT ROT - ; : >COUNTED \\ src n dst -- copy to counted string 2DUP C! CHAR+ SWAP CMOVE ; : WORD \\ char -- c-addr word delim'd by char DUP SOURCE >IN @ /STRING DUP >R ROT SKIP OVER >R ROT SCAN DUP IF CHAR- THEN R> R> ROT - >IN +! TUCK - HERE >COUNTED HERE BL OVER COUNT + C! ; \\ High level: interpreter (c) 31mar95 bjr : NFA>LFA \\ nfa -- lfa name adr -> link field 3 - ; : NFA>CFA \\ nfa -- cfa name adr -> code field COUNT 7F AND + ; : IMMED? \\ nfa -- f fetch immediate flag 1- C@ ; : FIND \\ c-addr -- c-addr 0/1/-1 not found/immed/normal LATEST @ BEGIN \\ -- a nfa 2DUP OVER C@ CHAR+ \\ -- a nfa a nfa n+1 S= DUP IF DROP NFA>LFA @ DUP THEN \\ -- a link link 0= UNTIL \\ -- a nfa OR a 0 DUP IF \\ if found, check immed status NIP DUP NFA>CFA \\ -- nfa xt SWAP IMMED? 0= 1 OR \\ -- xt 1/-1 THEN ; \\ High level: interpreter (c) 31mar95 bjr : LITERAL \\ x -- append numeric literal STATE @ IF ['] LIT COMPILE, I, THEN ; EMULATES TLITERAL IMMEDIATE HEX : DIGIT? \\ c -- n -1 | x 0 true if c is a valid digit DUP 39 > 100 AND + \\ silly looking, DUP 140 > 107 AND - 30 - \\ but it works! DUP BASE @ U< ; : ?SIGN \\ adr n -- adr' n' f get optional sign OVER C@ \\ -- adr n c 2C - DUP ABS 1 = AND \\ -- +=-1, -=+1, else 0 DUP IF 1+ \\ +=0, -=+2 NZ=negative >R 1 /STRING R> \\ adr' n' f THEN ; \\ High level: interpreter (c) 31mar95 bjr : >NUMBER \\ ud adr u -- ud' adr' u' conv. string to number BEGIN DUP WHILE OVER C@ DIGIT? 0= IF DROP EXIT THEN >R 2SWAP BASE @ UD* R> M+ 2SWAP 1 /STRING REPEAT ; : ?NUMBER \\ c-addr -- n -1 | c-addr 0 string->number DUP 0 0 ROT COUNT \\ -- ca ud adr n ?SIGN >R >NUMBER \\ -- ca ud adr' n' IF R> 2DROP 2DROP 0 \\ -- ca 0 (error) ELSE 2DROP NIP R> IF NEGATE THEN -1 \\ -- n -1 (ok) THEN ; \\ High level: interpreter (c) 31mar95 bjr : INTERPRET \\ i*x c-addr u -- j*x interpret given buffer 'SOURCE 2! 0 >IN ! BEGIN BL WORD DUP C@ WHILE \\ -- textadr FIND ?DUP IF \\ -- xt 1/-1 1+ STATE @ 0= OR \\ immed or interp? IF EXECUTE ELSE COMPILE, THEN ELSE \\ -- textadr ?NUMBER IF [COMPILE] LITERAL \\ converted ok ELSE COUNT TYPE 3F EMIT CR ABORT THEN \\ error THEN REPEAT DROP ; : EVALUATE \\ i*x c-addr u -- j*x interpret string 'SOURCE 2@ >R >R >IN @ >R INTERPRET R> >IN ! R> R> 'SOURCE 2! ; \\ High level: interpreter (c) 28apr95 bjr : QUIT \\ -- R: i*x -- interpret from keyboard L0 LP ! R0 RP! 0 STATE ! \\ reset stacks, state BEGIN TIB DUP TIBSIZE ACCEPT SPACE INTERPRET STATE @ 0= IF CR .\" OK \" THEN AGAIN ; : ABORT \\ i*x -- R: j*x -- clear stack and QUIT S0 SP! QUIT ; : ?ABORT \\ f c-addr u -- abort and print message ROT IF TYPE ABORT THEN 2DROP ; : ABORT\" \\ i*x 0 -- i*x abort, print inline msg [COMPILE] S\" ['] ?ABORT COMPILE, ; EMULATE: M['] (S\") T, TS\" M['] ?ABORT T, ;EMULATE IMMEDIATE \\ High level: interpreter (c) 31mar95 bjr : ' \\ -- xt find word in dictionary BL WORD FIND 0= ABORT\" ?\" ; : CHAR \\ -- char parse ASCII character BL WORD 1+ C@ ; : [CHAR] \\ -- compile character literal CHAR ['] LIT COMPILE, I, ; IMMEDIATE : ( \\ -- skip input until ) 29 WORD DROP ; IMMEDIATE \\ High level: compiler (c) 31mar95 bjr : CREATE \\ -- create an empty definition LATEST @ I, 0 IC, \\ link & immediate field IHERE LATEST ! \\ new \"latest\" link BL IWORD IC@ 1+ IALLOT \\ name field <DOCREATE> ,CF ; \\ code field : RECURSE \\ -- recurse current definition LATEST @ NFA>CFA COMPILE, ; IMMEDIATE : [ \\ -- enter interpretive state 0 STATE ! ; IMMEDIATE : ] \\ -- enter compiling state -1 STATE ! ; \\ High level: compiler (c) 31mar95 bjr HEX : HIDE \\ -- \"hide\" latest definition LATEST @ DUP IC@ 80 OR SWAP IC! ; : REVEAL \\ -- \"reveal\" latest definition LATEST @ DUP IC@ 7F AND SWAP IC! ; : IMMEDIATE \\ -- make last definition immediate 1 LATEST @ 1- IC! ; : ['] \\ -- find word and compile as literal ' ['] LIT COMPILE, I, ; IMMEDIATE \\ High level: compiler (c) 31mar95 bjr : POSTPONE \\ -- postpone compile action of word BL WORD FIND DUP 0= ABORT\" ?\" \\ find word 0< IF ['] LIT COMPILE, I, \\ non-immed: compiles later ['] COMPILE, COMPILE, \\ add \"LIT xt COMPILE,\" to df ELSE COMPILE, THEN ; IMMEDIATE \\ immed: compile into df \\ High level: other operations (c) 25apr95 bjr : WITHIN \\ n1|u1 n2|u2 n3|u3 -- f n2<=n1<n3? OVER - >R - R> U< ; : MOVE \\ addr1 addr2 u -- smart move >R 2DUP SWAP DUP R@ + WITHIN IF R> CMOVE> ELSE R> CMOVE THEN ; : DEPTH \\ -- n SP@ S0 SWAP - 2/ ; \\ 16 BIT VERSION! : ENVIRONMENT? \\ c-addr u -- i*x true system query 2DROP 0 ; \\ -- false \\ High level: utility words (c) 25apr95 bjr : WORDS \\ -- list all words in dictionary LATEST @ BEGIN DUP COUNT TYPE SPACE NFA>LFA @ DUP 0= UNTIL DROP ; EMULATES WORDS : .S \\ -- print contents of stack SP@ S0 - IF SP@ S0 2 - DO I @ h. -2 +LOOP THEN ; EMULATES .S \\ High level: startup (c) 25apr95 bjr : COLD \\ -- cold start Forth system UINIT U0 #INIT CMOVE .\" 6809 CamelForth v1.0 25 Apr 95\" CR ABORT ; \\ Testing words HEX : .H ( n - ) 0F AND 30 + DUP 39 > IF 7 + THEN EMIT ; : .HH ( n - ) DUP 2/ 2/ 2/ 2/ .H .H ; : .HHHH ( n - ) DUP 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ .HH .HH ; : H. ( n - ) .HHHH SPACE ; : .B ( a - a+1 ) DUP C@ .HH SPACE 1+ ; : DUMP ( a n - ) 0 DO DUP CR H. SPACE .B .B .B .B .B .B .B .B SPACE .B .B .B .B .B .B .B .B 10 +LOOP DROP ; \\ 6809 DTC: reset initialization (c) 25apr95 bjr ASM: HERE EQU ENTRY HEX CLRA, F000 STA, INCA, E000 STA, INCA, D000 STA, INCA, C000 STA, INCA, B000 STA, INCA, A000 STA, INCA, 9000 STA, INCA, 8000 STA, \\ init mem mapping UP-INIT-HI # LDA, A DPR TFR, \\ initial UP UP-INIT 100 + # LDS, \\ initial SP UP-INIT 200 + # LDU, \\ initial RP SCCATBL # LDX, SCCINIT JSR, \\ init serial ports SCCBTBL # LDX, SCCINIT JSR, ' COLD JMP, ;C \\ enter top-level Forth word ASM: HERE EQU IRET RTI, ;C HERE 0FFF0 ORG \\ 6809 hardware vectors IRET , IRET , IRET , IRET , \\ tbd, SWI3, SWI2, FIRQ IRET , IRET , IRET , ENTRY , \\ IRQ, SWI, NMI, RESET ORG \\ 6809 DTC: user area initialization (c) 25apr95 bjr DECIMAL 18 CONSTANT #INIT \\ # bytes of user area init data CREATE UINIT HEX 0 , 0 , 0A , 0 , \\ reserved,>IN,BASE,STATE DP-INIT , \\ DP 0 , 0 , \\ SOURCE init'd elsewhere META ALSO FORTH TLATEST @ T, PREVIOUS TARGET \\ LATEST 0 , \\ HP init'd elsewhere \\ Note that UINIT must be the *last* word in the kernel, in \\ order to set the initial LATEST as shown above. If this is \\ not the last word, be sure to patch the LATEST value above.","title":"Camel09"},{"location":"camel80.html","text":"; Listing 2. ; =============================================== ; CamelForth for the Zilog Z80 ; (c) 1994 Bradford J. Rodriguez ; Permission is granted to freely copy, modify, ; and distribute this program for personal or ; educational use. Commercial inquiries should ; be directed to the author at 221 King St. E., ; #32, Hamilton, Ontario L8N 1B5 Canada ; ; CAMEL80.AZM: Code Primitives ; Source code is for the Z80MR macro assembler. ; Forth words are documented as follows: ;x NAME stack -- stack description ; where x=C for ANS Forth Core words, X for ANS ; Extensions, Z for internal or private words. ; ; Direct-Threaded Forth model for Zilog Z80 ; 16 bit cell, 8 bit char, 8 bit (byte) adrs unit ; Z80 BC = Forth TOS (top Param Stack item) ; HL = W working register ; DE = IP Interpreter Pointer ; SP = PSP Param Stack Pointer ; IX = RSP Return Stack Pointer ; IY = UP User area Pointer ; A, alternate register set = temporaries ; ; Revision history: ; 19 Aug 94 v1.0 ; 25 Jan 95 v1.01 now using BDOS function 0Ah ; for interpreter input; TIB at 82h. ; 02 Mar 95 v1.02 changed ALIGN to ALIGNED in ; S\" (S\"); changed ,BRANCH to ,XT in DO. ; =============================================== ; Macros to define Forth headers ; HEAD label,length,name,action ; IMMED label,length,name,action ; label = assembler name for this word ; (special characters not allowed) ; length = length of name field ; name = Forth's name for this word ; action = code routine for this word, e.g. ; DOCOLON, or DOCODE for code words ; IMMED defines a header for an IMMEDIATE word. ; DOCODE EQU 0 ; flag to indicate CODE words link DEFL 0 ; link to previous Forth word head MACRO #label,#length,#name,#action DW link DB 0 link DEFL $ DB #length,'#name' #label: IF .NOT.(#action=DOCODE) call #action ENDIF ENDM immed MACRO #label,#length,#name,#action DW link DB 1 link DEFL $ DB #length,'#name' #label: IF .NOT.(#action=DOCODE) call #action ENDIF ENDM ; The NEXT macro (7 bytes) assembles the 'next' ; code in-line in every Z80 CamelForth CODE word. next MACRO ex de,hl ld e,(hl) inc hl ld d,(hl) inc hl ex de,hl jp (hl) ENDM ; NEXTHL is used when the IP is already in HL. nexthl MACRO ld e,(hl) inc hl ld d,(hl) inc hl ex de,hl jp (hl) ENDM ; RESET AND INTERRUPT VECTORS =================== ; ...are not used in the CP/M implementation ; Instead, we have the... ; CP/M ENTRY POINT org 100h reset: ld hl,(6h) ; BDOS address, rounded down ld l,0 ; = end of avail.mem (EM) dec h ; EM-100h ld sp,hl ; = top of param stack inc h ; EM push hl pop ix ; = top of return stack dec h ; EM-200h dec h push hl pop iy ; = bottom of user area ld de,1 ; do reset if COLD returns jp COLD ; enter top-level Forth word ; Memory map: ; 0080h Terminal Input Buffer, 128 bytes ; 0100h Forth kernel = start of CP/M TPA ; ? h Forth dictionary (user RAM) ; EM-200h User area, 128 bytes ; EM-180h Parameter stack, 128B, grows down ; EM-100h HOLD area, 40 bytes, grows down ; EM-0D8h PAD buffer, 88 bytes ; EM-80h Return stack, 128 B, grows down ; EM End of RAM = start of CP/M BDOS ; See also the definitions of U0, S0, and R0 ; in the \"system variables & constants\" area. ; A task w/o terminal input requires 200h bytes. ; Double all except TIB and PAD for 32-bit CPUs. ; INTERPRETER LOGIC ============================= ; See also \"defining words\" at end of this file ;C EXIT -- exit a colon definition head EXIT,4,EXIT,docode ld e,(ix+0) ; pop old IP from ret stk inc ix ld d,(ix+0) inc ix next ;Z lit -- x fetch inline literal to stack ; This is the primtive compiled by LITERAL. head lit,3,lit,docode push bc ; push old TOS ld a,(de) ; fetch cell at IP to TOS, ld c,a ; advancing IP inc de ld a,(de) ld b,a inc de next ;C EXECUTE i*x xt -- j*x execute Forth word ;C at 'xt' head EXECUTE,7,EXECUTE,docode ld h,b ; address of word -> HL ld l,c pop bc ; get new TOS jp (hl) ; go do Forth word ; DEFINING WORDS ================================ ; ENTER, a.k.a. DOCOLON, entered by CALL ENTER ; to enter a new high-level thread (colon def'n.) ; (internal code fragment, not a Forth word) ; N.B.: DOCOLON must be defined before any ; appearance of 'docolon' in a 'word' macro! docolon: ; (alternate name) enter: dec ix ; push old IP on ret stack ld (ix+0),d dec ix ld (ix+0),e pop hl ; param field adrs -> IP nexthl ; use the faster 'nexthl' ;C VARIABLE -- define a Forth variable ; CREATE 1 CELLS ALLOT ; ; Action of RAM variable is identical to CREATE, ; so we don't need a DOES> clause to change it. head VARIABLE,8,VARIABLE,docolon DW CREATE,LIT,1,CELLS,ALLOT,EXIT ; DOVAR, code action of VARIABLE, entered by CALL ; DOCREATE, code action of newly created words docreate: dovar: ; -- a-addr pop hl ; parameter field address push bc ; push old TOS ld b,h ; pfa = variable's adrs -> TOS ld c,l next ;C CONSTANT n -- define a Forth constant ; CREATE , DOES> (machine code fragment) head CONSTANT,8,CONSTANT,docolon DW CREATE,COMMA,XDOES ; DOCON, code action of CONSTANT, ; entered by CALL DOCON docon: ; -- x pop hl ; parameter field address push bc ; push old TOS ld c,(hl) ; fetch contents of parameter inc hl ; field -> TOS ld b,(hl) next ;Z USER n -- define user variable 'n' ; CREATE , DOES> (machine code fragment) head USER,4,USER,docolon DW CREATE,COMMA,XDOES ; DOUSER, code action of USER, ; entered by CALL DOUSER douser: ; -- a-addr pop hl ; parameter field address push bc ; push old TOS ld c,(hl) ; fetch contents of parameter inc hl ; field ld b,(hl) push iy ; copy user base address to HL pop hl add hl,bc ; and add offset ld b,h ; put result in TOS ld c,l next ; DODOES, code action of DOES> clause ; entered by CALL fragment ; parameter field ; ... ; fragment: CALL DODOES ; high-level thread ; Enters high-level thread with address of ; parameter field on top of stack. ; (internal code fragment, not a Forth word) dodoes: ; -- a-addr dec ix ; push old IP on ret stk ld (ix+0),d dec ix ld (ix+0),e pop de ; adrs of new thread -> IP pop hl ; adrs of parameter field push bc ; push old TOS onto stack ld b,h ; pfa -> new TOS ld c,l next ; CP/M TERMINAL I/O ============================= cpmbdos EQU 5h ; CP/M BDOS entry point ;Z BDOS de c -- a call CP/M BDOS head BDOS,4,BDOS,docode ex de,hl ; save important Forth regs pop de ; (DE,IX,IY) & pop DE value push hl push ix push iy call cpmbdos ld c,a ; result in TOS ld b,0 pop iy ; restore Forth regs pop ix pop de next ;C EMIT c -- output character to console ; 6 BDOS DROP ; ; warning: if c=0ffh, will read one keypress head EMIT,4,EMIT,docolon DW LIT,06H,BDOS,DROP,EXIT ;Z SAVEKEY -- addr temporary storage for KEY? head savekey,7,SAVEKEY,dovar DW 0 ;X KEY? -- f return true if char waiting ; 0FF 6 BDOS DUP SAVEKEY C! ; rtns 0 or key ; must use BDOS function 6 to work with KEY head querykey,4,KEY?,docolon DW LIT,0FFH,LIT,06H,BDOS DW DUP,SAVEKEY,CSTORE,EXIT ;C KEY -- c get character from keyboard ; BEGIN SAVEKEY C@ 0= WHILE KEY? DROP REPEAT ; SAVEKEY C@ 0 SAVEKEY C! ; ; must use CP/M direct console I/O to avoid echo ; (BDOS function 6, contained within KEY?) head KEY,3,KEY,docolon KEY1: DW SAVEKEY,CFETCH,ZEROEQUAL,qbranch,KEY2 DW QUERYKEY,DROP,branch,KEY1 KEY2: DW SAVEKEY,CFETCH,LIT,0,SAVEKEY,CSTORE DW EXIT ;Z CPMACCEPT c-addr +n -- +n' get line of input ; SWAP 2 - TUCK C! max # of characters ; DUP 0A BDOS DROP CP/M Get Console Buffer ; 1+ C@ 0A EMIT ; get returned count ; Note: requires the two locations before c-addr ; to be available for use. head CPMACCEPT,9,CPMACCEPT,docolon DW SWOP,LIT,2,MINUS,TUCK,CSTORE DW DUP,LIT,0Ah,BDOS,DROP DW ONEPLUS,CFETCH,LIT,0Ah,EMIT,EXIT ;X BYE i*x -- return to CP/M head bye,3,bye,docode jp 0 ; STACK OPERATIONS ============================== ;C DUP x -- x x duplicate top of stack head DUP,3,DUP,docode pushtos: push bc next ;C ?DUP x -- 0 | x x DUP if nonzero head QDUP,4,?DUP,docode ld a,b or c jr nz,pushtos next ;C DROP x -- drop top of stack head DROP,4,DROP,docode poptos: pop bc next ;C SWAP x1 x2 -- x2 x1 swap top two items head SWOP,4,SWAP,docode pop hl push bc ld b,h ld c,l next ;C OVER x1 x2 -- x1 x2 x1 per stack diagram head OVER,4,OVER,docode pop hl push hl push bc ld b,h ld c,l next ;C ROT x1 x2 x3 -- x2 x3 x1 per stack diagram head ROT,3,ROT,docode ; x3 is in TOS pop hl ; x2 ex (sp),hl ; x2 on stack, x1 in hl push bc ld b,h ld c,l next ;X NIP x1 x2 -- x2 per stack diagram head NIP,3,NIP,docolon DW SWOP,DROP,EXIT ;X TUCK x1 x2 -- x2 x1 x2 per stack diagram head TUCK,4,TUCK,docolon DW SWOP,OVER,EXIT ;C >R x -- R: -- x push to return stack head TOR,2,>R,docode dec ix ; push TOS onto rtn stk ld (ix+0),b dec ix ld (ix+0),c pop bc ; pop new TOS next ;C R> -- x R: x -- pop from return stack head RFROM,2,R>,docode push bc ; push old TOS ld c,(ix+0) ; pop top rtn stk item inc ix ; to TOS ld b,(ix+0) inc ix next ;C R@ -- x R: x -- x fetch from rtn stk head RFETCH,2,R@,docode push bc ; push old TOS ld c,(ix+0) ; fetch top rtn stk item ld b,(ix+1) ; to TOS next ;Z SP@ -- a-addr get data stack pointer head SPFETCH,3,SP@,docode push bc ld hl,0 add hl,sp ld b,h ld c,l next ;Z SP! a-addr -- set data stack pointer head SPSTORE,3,SP!,docode ld h,b ld l,c ld sp,hl pop bc ; get new TOS next ;Z RP@ -- a-addr get return stack pointer head RPFETCH,3,RP@,docode push bc push ix pop bc next ;Z RP! a-addr -- set return stack pointer head RPSTORE,3,RP!,docode push bc pop ix pop bc next ; MEMORY AND I/O OPERATIONS ===================== ;C ! x a-addr -- store cell in memory head STORE,1,!,docode ld h,b ; address in hl ld l,c pop bc ; data in bc ld (hl),c inc hl ld (hl),b pop bc ; pop new TOS next ;C C! char c-addr -- store char in memory head CSTORE,2,C!,docode ld h,b ; address in hl ld l,c pop bc ; data in bc ld (hl),c pop bc ; pop new TOS next ;C @ a-addr -- x fetch cell from memory head FETCH,1,@,docode ld h,b ; address in hl ld l,c ld c,(hl) inc hl ld b,(hl) next ;C C@ c-addr -- char fetch char from memory head CFETCH,2,C@,docode ld a,(bc) ld c,a ld b,0 next ;Z PC! char c-addr -- output char to port head PCSTORE,3,PC!,docode pop hl ; char in L out (c),l ; to port (BC) pop bc ; pop new TOS next ;Z PC@ c-addr -- char input char from port head PCFETCH,3,PC@,docode in c,(c) ; read port (BC) to C ld b,0 next ; ARITHMETIC AND LOGICAL OPERATIONS ============= ;C + n1/u1 n2/u2 -- n3/u3 add n1+n2 head PLUS,1,+,docode pop hl add hl,bc ld b,h ld c,l next ;X M+ d n -- d add single to double head MPLUS,2,M+,docode ex de,hl pop de ; hi cell ex (sp),hl ; lo cell, save IP add hl,bc ld b,d ; hi result in BC (TOS) ld c,e jr nc,mplus1 inc bc mplus1: pop de ; restore saved IP push hl ; push lo result next ;C - n1/u1 n2/u2 -- n3/u3 subtract n1-n2 head MINUS,1,-,docode pop hl or a sbc hl,bc ld b,h ld c,l next ;C AND x1 x2 -- x3 logical AND head AND,3,AND,docode pop hl ld a,b and h ld b,a ld a,c and l ld c,a next ;C OR x1 x2 -- x3 logical OR head OR,2,OR,docode pop hl ld a,b or h ld b,a ld a,c or l ld c,a next ;C XOR x1 x2 -- x3 logical XOR head XOR,3,XOR,docode pop hl ld a,b xor h ld b,a ld a,c xor l ld c,a next ;C INVERT x1 -- x2 bitwise inversion head INVERT,6,INVERT,docode ld a,b cpl ld b,a ld a,c cpl ld c,a next ;C NEGATE x1 -- x2 two's complement head NEGATE,6,NEGATE,docode ld a,b cpl ld b,a ld a,c cpl ld c,a inc bc next ;C 1+ n1/u1 -- n2/u2 add 1 to TOS head ONEPLUS,2,1+,docode inc bc next ;C 1- n1/u1 -- n2/u2 subtract 1 from TOS head ONEMINUS,2,1-,docode dec bc next ;Z >< x1 -- x2 swap bytes (not ANSI) head swapbytes,2,><,docode ld a,b ld b,c ld c,a next ;C 2* x1 -- x2 arithmetic left shift head TWOSTAR,2,2*,docode sla c rl b next ;C 2/ x1 -- x2 arithmetic right shift head TWOSLASH,2,2/,docode sra b rr c next ;C LSHIFT x1 u -- x2 logical L shift u places head LSHIFT,6,LSHIFT,docode ld b,c ; b = loop counter pop hl ; NB: hi 8 bits ignored! inc b ; test for counter=0 case jr lsh2 lsh1: add hl,hl ; left shift HL, n times lsh2: djnz lsh1 ld b,h ; result is new TOS ld c,l next ;C RSHIFT x1 u -- x2 logical R shift u places head RSHIFT,6,RSHIFT,docode ld b,c ; b = loop counter pop hl ; NB: hi 8 bits ignored! inc b ; test for counter=0 case jr rsh2 rsh1: srl h ; right shift HL, n times rr l rsh2: djnz rsh1 ld b,h ; result is new TOS ld c,l next ;C +! n/u a-addr -- add cell to memory head PLUSSTORE,2,+!,docode pop hl ld a,(bc) ; low byte add a,l ld (bc),a inc bc ld a,(bc) ; high byte adc a,h ld (bc),a pop bc ; pop new TOS next ; COMPARISON OPERATIONS ========================= ;C 0= n/u -- flag return true if TOS=0 head ZEROEQUAL,2,0=,docode ld a,b or c ; result=0 if bc was 0 sub 1 ; cy set if bc was 0 sbc a,a ; propagate cy through A ld b,a ; put 0000 or FFFF in TOS ld c,a next ;C 0< n -- flag true if TOS negative head ZEROLESS,2,0<,docode sla b ; sign bit -> cy flag sbc a,a ; propagate cy through A ld b,a ; put 0000 or FFFF in TOS ld c,a next ;C = x1 x2 -- flag test x1=x2 head EQUAL,1,=,docode pop hl or a sbc hl,bc ; x1-x2 in HL, SZVC valid jr z,tostrue tosfalse: ld bc,0 next ;X <> x1 x2 -- flag test not eq (not ANSI) head NOTEQUAL,2,<>,docolon DW EQUAL,ZEROEQUAL,EXIT ;C < n1 n2 -- flag test n1<n2, signed head LESS,1,<,docode pop hl or a sbc hl,bc ; n1-n2 in HL, SZVC valid ; if result negative & not OV, n1<n2 ; neg. & OV => n1 +ve, n2 -ve, rslt -ve, so n1>n2 ; if result positive & not OV, n1>=n2 ; pos. & OV => n1 -ve, n2 +ve, rslt +ve, so n1<n2 ; thus OV reverses the sense of the sign bit jp pe,revsense ; if OV, use rev. sense jp p,tosfalse ; if +ve, result false tostrue: ld bc,0ffffh ; if -ve, result true next revsense: jp m,tosfalse ; OV: if -ve, reslt false jr tostrue ; if +ve, result true ;C > n1 n2 -- flag test n1>n2, signed head GREATER,1,>,docolon DW SWOP,LESS,EXIT ;C U< u1 u2 -- flag test u1<n2, unsigned head ULESS,2,U<,docode pop hl or a sbc hl,bc ; u1-u2 in HL, SZVC valid sbc a,a ; propagate cy through A ld b,a ; put 0000 or FFFF in TOS ld c,a next ;X U> u1 u2 -- flag u1>u2 unsgd (not ANSI) head UGREATER,2,U>,docolon DW SWOP,ULESS,EXIT ; LOOP AND BRANCH OPERATIONS ==================== ;Z branch -- branch always head branch,6,branch,docode dobranch: ld a,(de) ; get inline value => IP ld l,a inc de ld a,(de) ld h,a nexthl ;Z ?branch x -- branch if TOS zero head qbranch,7,?branch,docode ld a,b or c ; test old TOS pop bc ; pop new TOS jr z,dobranch ; if old TOS=0, branch inc de ; else skip inline value inc de next ;Z (do) n1|u1 n2|u2 -- R: -- sys1 sys2 ;Z run-time code for DO ; '83 and ANSI standard loops terminate when the ; boundary of limit-1 and limit is crossed, in ; either direction. This can be conveniently ; implemented by making the limit 8000h, so that ; arithmetic overflow logic can detect crossing. ; I learned this trick from Laxen & Perry F83. ; fudge factor = 8000h-limit, to be added to ; the start value. head xdo,4,(do),docode ex de,hl ex (sp),hl ; IP on stack, limit in HL ex de,hl ld hl,8000h or a sbc hl,de ; 8000-limit in HL dec ix ; push this fudge factor ld (ix+0),h ; onto return stack dec ix ; for later use by 'I' ld (ix+0),l add hl,bc ; add fudge to start value dec ix ; push adjusted start value ld (ix+0),h ; onto return stack dec ix ; as the loop index. ld (ix+0),l pop de ; restore the saved IP pop bc ; pop new TOS next ;Z (loop) R: sys1 sys2 -- | sys1 sys2 ;Z run-time code for LOOP ; Add 1 to the loop index. If loop terminates, ; clean up the return stack and skip the branch. ; Else take the inline branch. Note that LOOP ; terminates when index=8000h. head xloop,6,(loop),docode exx ld bc,1 looptst: ld l,(ix+0) ; get the loop index ld h,(ix+1) or a adc hl,bc ; increment w/overflow test jp pe,loopterm ; overflow=loop done ; continue the loop ld (ix+0),l ; save the updated index ld (ix+1),h exx jr dobranch ; take the inline branch loopterm: ; terminate the loop ld bc,4 ; discard the loop info add ix,bc exx inc de ; skip the inline branch inc de next ;Z (+loop) n -- R: sys1 sys2 -- | sys1 sys2 ;Z run-time code for +LOOP ; Add n to the loop index. If loop terminates, ; clean up the return stack and skip the branch. ; Else take the inline branch. head xplusloop,7,(+loop),docode pop hl ; this will be the new TOS push bc ld b,h ld c,l exx pop bc ; old TOS = loop increment jr looptst ;C I -- n R: sys1 sys2 -- sys1 sys2 ;C get the innermost loop index head II,1,I,docode push bc ; push old TOS ld l,(ix+0) ; get current loop index ld h,(ix+1) ld c,(ix+2) ; get fudge factor ld b,(ix+3) or a sbc hl,bc ; subtract fudge factor, ld b,h ; returning true index ld c,l next ;C J -- n R: 4*sys -- 4*sys ;C get the second loop index head JJ,1,J,docode push bc ; push old TOS ld l,(ix+4) ; get current loop index ld h,(ix+5) ld c,(ix+6) ; get fudge factor ld b,(ix+7) or a sbc hl,bc ; subtract fudge factor, ld b,h ; returning true index ld c,l next ;C UNLOOP -- R: sys1 sys2 -- drop loop parms head UNLOOP,6,UNLOOP,docode inc ix inc ix inc ix inc ix next ; MULTIPLY AND DIVIDE =========================== ;C UM* u1 u2 -- ud unsigned 16x16->32 mult. head UMSTAR,3,UM*,docode push bc exx pop bc ; u2 in BC pop de ; u1 in DE ld hl,0 ; result will be in HLDE ld a,17 ; loop counter or a ; clear cy umloop: rr h rr l rr d rr e jr nc,noadd add hl,bc noadd: dec a jr nz,umloop push de ; lo result push hl ; hi result exx pop bc ; put TOS back in BC next ;C UM/MOD ud u1 -- u2 u3 unsigned 32/16->16 head UMSLASHMOD,6,UM/MOD,docode push bc exx pop bc ; BC = divisor pop hl ; HLDE = dividend pop de ld a,16 ; loop counter sla e rl d ; hi bit DE -> carry udloop: adc hl,hl ; rot left w/ carry jr nc,udiv3 ; case 1: 17 bit, cy:HL = 1xxxx or a ; we know we can subtract sbc hl,bc or a ; clear cy to indicate sub ok jr udiv4 ; case 2: 16 bit, cy:HL = 0xxxx udiv3: sbc hl,bc ; try the subtract jr nc,udiv4 ; if no cy, subtract ok add hl,bc ; else cancel the subtract scf ; and set cy to indicate udiv4: rl e ; rotate result bit into DE, rl d ; and next bit of DE into cy dec a jr nz,udloop ; now have complemented quotient in DE, ; and remainder in HL ld a,d cpl ld b,a ld a,e cpl ld c,a push hl ; push remainder push bc exx pop bc ; quotient remains in TOS next ; BLOCK AND STRING OPERATIONS =================== ;C FILL c-addr u char -- fill memory with char head FILL,4,FILL,docode ld a,c ; character in a exx ; use alt. register set pop bc ; count in bc pop de ; address in de or a ; clear carry flag ld hl,0ffffh adc hl,bc ; test for count=0 or 1 jr nc,filldone ; no cy: count=0, skip ld (de),a ; fill first byte jr z,filldone ; zero, count=1, done dec bc ; else adjust count, ld h,d ; let hl = start adrs, ld l,e inc de ; let de = start adrs+1 ldir ; copy (hl)->(de) filldone: exx ; back to main reg set pop bc ; pop new TOS next ;X CMOVE c-addr1 c-addr2 u -- move from bottom ; as defined in the ANSI optional String word set ; On byte machines, CMOVE and CMOVE> are logical ; factors of MOVE. They are easy to implement on ; CPUs which have a block-move instruction. head CMOVE,5,CMOVE,docode push bc exx pop bc ; count pop de ; destination adrs pop hl ; source adrs ld a,b ; test for count=0 or c jr z,cmovedone ldir ; move from bottom to top cmovedone: exx pop bc ; pop new TOS next ;X CMOVE> c-addr1 c-addr2 u -- move from top ; as defined in the ANSI optional String word set head CMOVEUP,6,CMOVE>,docode push bc exx pop bc ; count pop hl ; destination adrs pop de ; source adrs ld a,b ; test for count=0 or c jr z,umovedone add hl,bc ; last byte in destination dec hl ex de,hl add hl,bc ; last byte in source dec hl lddr ; move from top to bottom umovedone: exx pop bc ; pop new TOS next ;Z SKIP c-addr u c -- c-addr' u' ;Z skip matching chars ; Although SKIP, SCAN, and S= are perhaps not the ; ideal factors of WORD and FIND, they closely ; follow the string operations available on many ; CPUs, and so are easy to implement and fast. head skip,4,SKIP,docode ld a,c ; skip character exx pop bc ; count pop hl ; address ld e,a ; test for count=0 ld a,b or c jr z,skipdone ld a,e skiploop: cpi jr nz,skipmis ; char mismatch: exit jp pe,skiploop ; count not exhausted jr skipdone ; count 0, no mismatch skipmis: inc bc ; mismatch! undo last to dec hl ; point at mismatch char skipdone: push hl ; updated address push bc ; updated count exx pop bc ; TOS in bc next ;Z SCAN c-addr u c -- c-addr' u' ;Z find matching char head scan,4,SCAN,docode ld a,c ; scan character exx pop bc ; count pop hl ; address ld e,a ; test for count=0 ld a,b or c jr z,scandone ld a,e cpir ; scan 'til match or count=0 jr nz,scandone ; no match, BC & HL ok inc bc ; match! undo last to dec hl ; point at match char scandone: push hl ; updated address push bc ; updated count exx pop bc ; TOS in bc next ;Z S= c-addr1 c-addr2 u -- n string compare ;Z n<0: s1<s2, n=0: s1=s2, n>0: s1>s2 head sequal,2,S=,docode push bc exx pop bc ; count pop hl ; addr2 pop de ; addr1 ld a,b ; test for count=0 or c jr z,smatch ; by definition, match! sloop: ld a,(de) inc de cpi jr nz,sdiff ; char mismatch: exit jp pe,sloop ; count not exhausted smatch: ; count exhausted & no mismatch found exx ld bc,0 ; bc=0000 (s1=s2) jr snext sdiff: ; mismatch! undo last 'cpi' increment dec hl ; point at mismatch char cp (hl) ; set cy if char1 < char2 sbc a,a ; propagate cy thru A exx ld b,a ; bc=FFFF if cy (s1<s2) or 1 ; bc=0001 if ncy (s1>s2) ld c,a snext: next *INCLUDE camel80d.azm ; CPU Dependencies *INCLUDE camel80h.azm ; High Level words lastword EQU link ; nfa of last word in dict. enddict EQU $ ; user's code starts here END","title":"Camel80"},{"location":"camel80d.html","text":"; LISTING 3. ; ; =============================================== ; CamelForth for the Zilog Z80 ; (c) 1994 Bradford J. Rodriguez ; Permission is granted to freely copy, modify, ; and distribute this program for personal or ; educational use. Commercial inquiries should ; be directed to the author at 221 King St. E., ; #32, Hamilton, Ontario L8N 1B5 Canada ; ; CAMEL80D.AZM: CPU and Model Dependencies ; Source code is for the Z80MR macro assembler. ; Forth words are documented as follows: ;* NAME stack -- stack description ; Word names in upper case are from the ANS ; Forth Core word set. Names in lower case are ; \"internal\" implementation words & extensions. ; ; Direct-Threaded Forth model for Zilog Z80 ; cell size is 16 bits (2 bytes) ; char size is 8 bits (1 byte) ; address unit is 8 bits (1 byte), i.e., ; addresses are byte-aligned. ; =============================================== ; ALIGNMENT AND PORTABILITY OPERATORS =========== ; Many of these are synonyms for other words, ; and so are defined as CODE words. ;C ALIGN -- align HERE head ALIGN,5,ALIGN,docode noop: next ;C ALIGNED addr -- a-addr align given addr head ALIGNED,7,ALIGNED,docode jr noop ;Z CELL -- n size of one cell head CELL,4,CELL,docon dw 2 ;C CELL+ a-addr1 -- a-addr2 add cell size ; 2 + ; head CELLPLUS,5,CELL+,docode inc bc inc bc next ;C CELLS n1 -- n2 cells->adrs units head CELLS,5,CELLS,docode jp twostar ;C CHAR+ c-addr1 -- c-addr2 add char size head CHARPLUS,5,CHAR+,docode jp oneplus ;C CHARS n1 -- n2 chars->adrs units head CHARS,5,CHARS,docode jr noop ;C >BODY xt -- a-addr adrs of param field ; 3 + ; Z80 (3 byte CALL) head TOBODY,5,>BODY,docolon DW LIT,3,PLUS,EXIT ;X COMPILE, xt -- append execution token ; I called this word ,XT before I discovered that ; it is defined in the ANSI standard as COMPILE,. ; On a DTC Forth this simply appends xt (like , ) ; but on an STC Forth this must append 'CALL xt'. head COMMAXT,8,'COMPILE,',docode jp COMMA ;Z !CF adrs cfa -- set code action of a word ; 0CD OVER C! store 'CALL adrs' instr ; 1+ ! ; Z80 VERSION ; Depending on the implementation this could ; append CALL adrs or JUMP adrs. head STORECF,3,!CF,docolon DW LIT,0CDH,OVER,CSTORE DW ONEPLUS,STORE,EXIT ;Z ,CF adrs -- append a code field ; HERE !CF 3 ALLOT ; Z80 VERSION (3 bytes) head COMMACF,3,',CF',docolon DW HERE,STORECF,LIT,3,ALLOT,EXIT ;Z !COLON -- change code field to docolon ; -3 ALLOT docolon-adrs ,CF ; ; This should be used immediately after CREATE. ; This is made a distinct word, because on an STC ; Forth, colon definitions have no code field. head STORCOLON,6,'!COLON',docolon DW LIT,-3,ALLOT DW LIT,docolon,COMMACF,EXIT ;Z ,EXIT -- append hi-level EXIT action ; ['] EXIT ,XT ; ; This is made a distinct word, because on an STC ; Forth, it appends a RET instruction, not an xt. head CEXIT,5,',EXIT',docolon DW LIT,EXIT,COMMAXT,EXIT ; CONTROL STRUCTURES ============================ ; These words allow Forth control structure words ; to be defined portably. ;Z ,BRANCH xt -- append a branch instruction ; xt is the branch operator to use, e.g. qbranch ; or (loop). It does NOT append the destination ; address. On the Z80 this is equivalent to ,XT. head COMMABRANCH,7,',BRANCH',docode jp COMMA ;Z ,DEST dest -- append a branch address ; This appends the given destination address to ; the branch instruction. On the Z80 this is ',' ; ...other CPUs may use relative addressing. head COMMADEST,5,',DEST',docode jp COMMA ;Z !DEST dest adrs -- change a branch dest'n ; Changes the destination address found at 'adrs' ; to the given 'dest'. On the Z80 this is '!' ; ...other CPUs may need relative addressing. head STOREDEST,5,'!DEST',docode jp STORE ; HEADER STRUCTURE ============================== ; The structure of the Forth dictionary headers ; (name, link, immediate flag, and \"smudge\" bit) ; does not necessarily differ across CPUs. This ; structure is not easily factored into distinct ; \"portable\" words; instead, it is implicit in ; the definitions of FIND and CREATE, and also in ; NFA>LFA, NFA>CFA, IMMED?, IMMEDIATE, HIDE, and ; REVEAL. These words must be (substantially) ; rewritten if either the header structure or its ; inherent assumptions are changed.","title":"Camel80d"},{"location":"camel80h.html","text":"; LISTING 2. ; ; =============================================== ; CamelForth for the Zilog Z80 ; (c) 1994 Bradford J. Rodriguez ; Permission is granted to freely copy, modify, ; and distribute this program for personal or ; educational use. Commercial inquiries should ; be directed to the author at 221 King St. E., ; #32, Hamilton, Ontario L8N 1B5 Canada ; ; CAMEL80H.AZM: High Level Words ; Source code is for the Z80MR macro assembler. ; Forth words are documented as follows: ;* NAME stack -- stack description ; Word names in upper case are from the ANS ; Forth Core word set. Names in lower case are ; \"internal\" implementation words & extensions. ; =============================================== ; SYSTEM VARIABLES & CONSTANTS ================== ;C BL -- char an ASCII space head BL,2,BL,docon dw 20h ;Z tibsize -- n size of TIB head TIBSIZE,7,TIBSIZE,docon dw 124 ; 2 chars safety zone ;X tib -- a-addr Terminal Input Buffer ; HEX 82 CONSTANT TIB CP/M systems: 126 bytes ; HEX -80 USER TIB others: below user area head TIB,3,TIB,docon dw 82h ;Z u0 -- a-addr current user area adrs ; 0 USER U0 head U0,2,U0,douser dw 0 ;C >IN -- a-addr holds offset into TIB ; 2 USER >IN head TOIN,3,>IN,douser dw 2 ;C BASE -- a-addr holds conversion radix ; 4 USER BASE head BASE,4,BASE,douser dw 4 ;C STATE -- a-addr holds compiler state ; 6 USER STATE head STATE,5,STATE,douser dw 6 ;Z dp -- a-addr holds dictionary ptr ; 8 USER DP head DP,2,DP,douser dw 8 ;Z 'source -- a-addr two cells: len, adrs ; 10 USER 'SOURCE ; head TICKSOURCE,7,'SOURCE,douser DW link ; must expand DB 0 ; manually link DEFL $ ; because of DB 7,27h,'SOURCE' ; tick character TICKSOURCE: call douser ; in name! dw 10 ;Z latest -- a-addr last word in dict. ; 14 USER LATEST head LATEST,6,LATEST,douser dw 14 ;Z hp -- a-addr HOLD pointer ; 16 USER HP head HP,2,HP,douser dw 16 ;Z LP -- a-addr Leave-stack pointer ; 18 USER LP head LP,2,LP,douser dw 18 ;Z s0 -- a-addr end of parameter stack head S0,2,S0,douser dw 100h ;X PAD -- a-addr user PAD buffer ; = end of hold area! head PAD,3,PAD,douser dw 128h ;Z l0 -- a-addr bottom of Leave stack head L0,2,L0,douser dw 180h ;Z r0 -- a-addr end of return stack head R0,2,R0,douser dw 200h ;Z uinit -- addr initial values for user area head UINIT,5,UINIT,docreate DW 0,0,10,0 ; reserved,>IN,BASE,STATE DW enddict ; DP DW 0,0 ; SOURCE init'd elsewhere DW lastword ; LATEST DW 0 ; HP init'd elsewhere ;Z #init -- n #bytes of user area init data head NINIT,5,#INIT,docon DW 18 ; ARITHMETIC OPERATORS ========================== ;C S>D n -- d single -> double prec. ; DUP 0< ; head STOD,3,S>D,docolon dw DUP,ZEROLESS,EXIT ;Z ?NEGATE n1 n2 -- n3 negate n1 if n2 negative ; 0< IF NEGATE THEN ; ...a common factor head QNEGATE,7,?NEGATE,docolon DW ZEROLESS,qbranch,QNEG1,NEGATE QNEG1: DW EXIT ;C ABS n1 -- +n2 absolute value ; DUP ?NEGATE ; head ABS,3,ABS,docolon DW DUP,QNEGATE,EXIT ;X DNEGATE d1 -- d2 negate double precision ; SWAP INVERT SWAP INVERT 1 M+ ; head DNEGATE,7,DNEGATE,docolon DW SWOP,INVERT,SWOP,INVERT,LIT,1,MPLUS DW EXIT ;Z ?DNEGATE d1 n -- d2 negate d1 if n negative ; 0< IF DNEGATE THEN ; ...a common factor head QDNEGATE,8,?DNEGATE,docolon DW ZEROLESS,qbranch,DNEG1,DNEGATE DNEG1: DW EXIT ;X DABS d1 -- +d2 absolute value dbl.prec. ; DUP ?DNEGATE ; head DABS,4,DABS,docolon DW DUP,QDNEGATE,EXIT ;C M* n1 n2 -- d signed 16*16->32 multiply ; 2DUP XOR >R carries sign of the result ; SWAP ABS SWAP ABS UM* ; R> ?DNEGATE ; head MSTAR,2,M*,docolon DW TWODUP,XOR,TOR DW SWOP,ABS,SWOP,ABS,UMSTAR DW RFROM,QDNEGATE,EXIT ;C SM/REM d1 n1 -- n2 n3 symmetric signed div ; 2DUP XOR >R sign of quotient ; OVER >R sign of remainder ; ABS >R DABS R> UM/MOD ; SWAP R> ?NEGATE ; SWAP R> ?NEGATE ; ; Ref. dpANS-6 section 3.2.2.1. head SMSLASHREM,6,SM/REM,docolon DW TWODUP,XOR,TOR,OVER,TOR DW ABS,TOR,DABS,RFROM,UMSLASHMOD DW SWOP,RFROM,QNEGATE,SWOP,RFROM,QNEGATE DW EXIT ;C FM/MOD d1 n1 -- n2 n3 floored signed div'n ; DUP >R save divisor ; SM/REM ; DUP 0< IF if quotient negative, ; SWAP R> + add divisor to rem'dr ; SWAP 1- decrement quotient ; ELSE R> DROP THEN ; ; Ref. dpANS-6 section 3.2.2.1. head FMSLASHMOD,6,FM/MOD,docolon DW DUP,TOR,SMSLASHREM DW DUP,ZEROLESS,qbranch,FMMOD1 DW SWOP,RFROM,PLUS,SWOP,ONEMINUS DW branch,FMMOD2 FMMOD1: DW RFROM,DROP FMMOD2: DW EXIT ;C * n1 n2 -- n3 signed multiply ; M* DROP ; head STAR,1,*,docolon dw MSTAR,DROP,EXIT ;C /MOD n1 n2 -- n3 n4 signed divide/rem'dr ; >R S>D R> FM/MOD ; head SLASHMOD,4,/MOD,docolon dw TOR,STOD,RFROM,FMSLASHMOD,EXIT ;C / n1 n2 -- n3 signed divide ; /MOD nip ; head SLASH,1,/,docolon dw SLASHMOD,NIP,EXIT ;C MOD n1 n2 -- n3 signed remainder ; /MOD DROP ; head MOD,3,MOD,docolon dw SLASHMOD,DROP,EXIT ;C */MOD n1 n2 n3 -- n4 n5 n1*n2/n3, rem&quot ; >R M* R> FM/MOD ; head SSMOD,5,*/MOD,docolon dw TOR,MSTAR,RFROM,FMSLASHMOD,EXIT ;C */ n1 n2 n3 -- n4 n1*n2/n3 ; */MOD nip ; head STARSLASH,2,*/,docolon dw SSMOD,NIP,EXIT ;C MAX n1 n2 -- n3 signed maximum ; 2DUP < IF SWAP THEN DROP ; head MAX,3,MAX,docolon dw TWODUP,LESS,qbranch,MAX1,SWOP MAX1: dw DROP,EXIT ;C MIN n1 n2 -- n3 signed minimum ; 2DUP > IF SWAP THEN DROP ; head MIN,3,MIN,docolon dw TWODUP,GREATER,qbranch,MIN1,SWOP MIN1: dw DROP,EXIT ; DOUBLE OPERATORS ============================== ;C 2@ a-addr -- x1 x2 fetch 2 cells ; DUP CELL+ @ SWAP @ ; ; the lower address will appear on top of stack head TWOFETCH,2,2@,docolon dw DUP,CELLPLUS,FETCH,SWOP,FETCH,EXIT ;C 2! x1 x2 a-addr -- store 2 cells ; SWAP OVER ! CELL+ ! ; ; the top of stack is stored at the lower adrs head TWOSTORE,2,2!,docolon dw SWOP,OVER,STORE,CELLPLUS,STORE,EXIT ;C 2DROP x1 x2 -- drop 2 cells ; DROP DROP ; head TWODROP,5,2DROP,docolon dw DROP,DROP,EXIT ;C 2DUP x1 x2 -- x1 x2 x1 x2 dup top 2 cells ; OVER OVER ; head TWODUP,4,2DUP,docolon dw OVER,OVER,EXIT ;C 2SWAP x1 x2 x3 x4 -- x3 x4 x1 x2 per diagram ; ROT >R ROT R> ; head TWOSWAP,5,2SWAP,docolon dw ROT,TOR,ROT,RFROM,EXIT ;C 2OVER x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 ; >R >R 2DUP R> R> 2SWAP ; head TWOOVER,5,2OVER,docolon dw TOR,TOR,TWODUP,RFROM,RFROM dw TWOSWAP,EXIT ; INPUT/OUTPUT ================================== ;C COUNT c-addr1 -- c-addr2 u counted->adr/len ; DUP CHAR+ SWAP C@ ; head COUNT,5,COUNT,docolon dw DUP,CHARPLUS,SWOP,CFETCH,EXIT ;C CR -- output newline ; 0D EMIT 0A EMIT ; head CR,2,CR,docolon dw lit,0dh,EMIT,lit,0ah,EMIT,EXIT ;C SPACE -- output a space ; BL EMIT ; head SPACE,5,SPACE,docolon dw BL,EMIT,EXIT ;C SPACES n -- output n spaces ; BEGIN DUP WHILE SPACE 1- REPEAT DROP ; head SPACES,6,SPACES,docolon SPCS1: DW DUP,qbranch,SPCS2 DW SPACE,ONEMINUS,branch,SPCS1 SPCS2: DW DROP,EXIT ;Z umin u1 u2 -- u unsigned minimum ; 2DUP U> IF SWAP THEN DROP ; head UMIN,4,UMIN,docolon DW TWODUP,UGREATER,QBRANCH,UMIN1,SWOP UMIN1: DW DROP,EXIT ;Z umax u1 u2 -- u unsigned maximum ; 2DUP U< IF SWAP THEN DROP ; head UMAX,4,UMAX,docolon DW TWODUP,ULESS,QBRANCH,UMAX1,SWOP UMAX1: DW DROP,EXIT ;C ACCEPT c-addr +n -- +n' get line from term'l ; OVER + 1- OVER -- sa ea a ; BEGIN KEY -- sa ea a c ; DUP 0D <> WHILE ; DUP EMIT -- sa ea a c ; DUP 8 = IF DROP 1- >R OVER R> UMAX ; ELSE OVER C! 1+ OVER UMIN ; THEN -- sa ea a ; REPEAT -- sa ea a c ; DROP NIP SWAP - ; head ACCEPT,6,ACCEPT,docolon DW OVER,PLUS,ONEMINUS,OVER ACC1: DW KEY,DUP,LIT,0DH,NOTEQUAL,QBRANCH,ACC5 DW DUP,EMIT,DUP,LIT,8,EQUAL,QBRANCH,ACC3 DW DROP,ONEMINUS,TOR,OVER,RFROM,UMAX DW BRANCH,ACC4 ACC3: DW OVER,CSTORE,ONEPLUS,OVER,UMIN ACC4: DW BRANCH,ACC1 ACC5: DW DROP,NIP,SWOP,MINUS,EXIT ;C TYPE c-addr +n -- type line to term'l ; ?DUP IF ; OVER + SWAP DO I C@ EMIT LOOP ; ELSE DROP THEN ; head TYPE,4,TYPE,docolon DW QDUP,QBRANCH,TYP4 DW OVER,PLUS,SWOP,XDO TYP3: DW II,CFETCH,EMIT,XLOOP,TYP3 DW BRANCH,TYP5 TYP4: DW DROP TYP5: DW EXIT ;Z (S\") -- c-addr u run-time code for S\" ; R> COUNT 2DUP + ALIGNED >R ; head XSQUOTE,4,(S\"),docolon DW RFROM,COUNT,TWODUP,PLUS,ALIGNED,TOR DW EXIT ;C S\" -- compile in-line string ; COMPILE (S\") [ HEX ] ; 22 WORD C@ 1+ ALIGNED ALLOT ; IMMEDIATE immed SQUOTE,2,S\",docolon DW LIT,XSQUOTE,COMMAXT DW LIT,22H,WORD,CFETCH,ONEPLUS DW ALIGNED,ALLOT,EXIT ;C .\" -- compile string to print ; POSTPONE S\" POSTPONE TYPE ; IMMEDIATE immed DOTQUOTE,2,.\",docolon DW SQUOTE DW LIT,TYPE,COMMAXT DW EXIT ; NUMERIC OUTPUT ================================ ; Numeric conversion is done l.s.digit first, so ; the output buffer is built backwards in memory. ; Some double-precision arithmetic operators are ; needed to implement ANSI numeric conversion. ;Z UD/MOD ud1 u2 -- u3 ud4 32/16->32 divide ; >R 0 R@ UM/MOD ROT ROT R> UM/MOD ROT ; head UDSLASHMOD,6,UD/MOD,docolon DW TOR,LIT,0,RFETCH,UMSLASHMOD,ROT,ROT DW RFROM,UMSLASHMOD,ROT,EXIT ;Z UD* ud1 d2 -- ud3 32*16->32 multiply ; DUP >R UM* DROP SWAP R> UM* ROT + ; head UDSTAR,3,UD*,docolon DW DUP,TOR,UMSTAR,DROP DW SWOP,RFROM,UMSTAR,ROT,PLUS,EXIT ;C HOLD char -- add char to output string ; -1 HP +! HP @ C! ; head HOLD,4,HOLD,docolon DW LIT,-1,HP,PLUSSTORE DW HP,FETCH,CSTORE,EXIT ;C <# -- begin numeric conversion ; PAD HP ! ; (initialize Hold Pointer) head LESSNUM,2,<#,docolon DW PAD,HP,STORE,EXIT ;Z >digit n -- c convert to 0..9A..Z ; [ HEX ] DUP 9 > 7 AND + 30 + ; head TODIGIT,6,>DIGIT,docolon DW DUP,LIT,9,GREATER,LIT,7,AND,PLUS DW LIT,30H,PLUS,EXIT ;C # ud1 -- ud2 convert 1 digit of output ; BASE @ UD/MOD ROT >digit HOLD ; head NUM,1,#,docolon DW BASE,FETCH,UDSLASHMOD,ROT,TODIGIT DW HOLD,EXIT ;C #S ud1 -- ud2 convert remaining digits ; BEGIN # 2DUP OR 0= UNTIL ; head NUMS,2,#S,docolon NUMS1: DW NUM,TWODUP,OR,ZEROEQUAL,qbranch,NUMS1 DW EXIT ;C #> ud1 -- c-addr u end conv., get string ; 2DROP HP @ PAD OVER - ; head NUMGREATER,2,#>,docolon DW TWODROP,HP,FETCH,PAD,OVER,MINUS,EXIT ;C SIGN n -- add minus sign if n<0 ; 0< IF 2D HOLD THEN ; head SIGN,4,SIGN,docolon DW ZEROLESS,qbranch,SIGN1,LIT,2DH,HOLD SIGN1: DW EXIT ;C U. u -- display u unsigned ; <# 0 #S #> TYPE SPACE ; head UDOT,2,U.,docolon DW LESSNUM,LIT,0,NUMS,NUMGREATER,TYPE DW SPACE,EXIT ;C . n -- display n signed ; <# DUP ABS 0 #S ROT SIGN #> TYPE SPACE ; head DOT,1,'.',docolon DW LESSNUM,DUP,ABS,LIT,0,NUMS DW ROT,SIGN,NUMGREATER,TYPE,SPACE,EXIT ;C DECIMAL -- set number base to decimal ; 10 BASE ! ; head DECIMAL,7,DECIMAL,docolon DW LIT,10,BASE,STORE,EXIT ;X HEX -- set number base to hex ; 16 BASE ! ; head HEX,3,HEX,docolon DW LIT,16,BASE,STORE,EXIT ; DICTIONARY MANAGEMENT ========================= ;C HERE -- addr returns dictionary ptr ; DP @ ; head HERE,4,HERE,docolon dw DP,FETCH,EXIT ;C ALLOT n -- allocate n bytes in dict ; DP +! ; head ALLOT,5,ALLOT,docolon dw DP,PLUSSTORE,EXIT ; Note: , and C, are only valid for combined ; Code and Data spaces. ;C , x -- append cell to dict ; HERE ! 1 CELLS ALLOT ; head COMMA,1,',',docolon dw HERE,STORE,lit,1,CELLS,ALLOT,EXIT ;C C, char -- append char to dict ; HERE C! 1 CHARS ALLOT ; head CCOMMA,2,'C,',docolon dw HERE,CSTORE,lit,1,CHARS,ALLOT,EXIT ; INTERPRETER =================================== ; Note that NFA>LFA, NFA>CFA, IMMED?, and FIND ; are dependent on the structure of the Forth ; header. This may be common across many CPUs, ; or it may be different. ;C SOURCE -- adr n current input buffer ; 'SOURCE 2@ ; length is at lower adrs head SOURCE,6,SOURCE,docolon DW TICKSOURCE,TWOFETCH,EXIT ;X /STRING a u n -- a+n u-n trim string ; ROT OVER + ROT ROT - ; head SLASHSTRING,7,/STRING,docolon DW ROT,OVER,PLUS,ROT,ROT,MINUS,EXIT ;Z >counted src n dst -- copy to counted str ; 2DUP C! CHAR+ SWAP CMOVE ; head TOCOUNTED,8,>COUNTED,docolon DW TWODUP,CSTORE,CHARPLUS,SWOP,CMOVE,EXIT ;C WORD char -- c-addr n word delim'd by char ; DUP SOURCE >IN @ /STRING -- c c adr n ; DUP >R ROT SKIP -- c adr' n' ; OVER >R ROT SCAN -- adr\" n\" ; DUP IF CHAR- THEN skip trailing delim. ; R> R> ROT - >IN +! update >IN offset ; TUCK - -- adr' N ; HERE >counted -- ; HERE -- a ; BL OVER COUNT + C! ; append trailing blank head WORD,4,WORD,docolon DW DUP,SOURCE,TOIN,FETCH,SLASHSTRING DW DUP,TOR,ROT,SKIP DW OVER,TOR,ROT,SCAN DW DUP,qbranch,WORD1,ONEMINUS ; char- WORD1: DW RFROM,RFROM,ROT,MINUS,TOIN,PLUSSTORE DW TUCK,MINUS DW HERE,TOCOUNTED,HERE DW BL,OVER,COUNT,PLUS,CSTORE,EXIT ;Z NFA>LFA nfa -- lfa name adr -> link field ; 3 - ; head NFATOLFA,7,NFA>LFA,docolon DW LIT,3,MINUS,EXIT ;Z NFA>CFA nfa -- cfa name adr -> code field ; COUNT 7F AND + ; mask off 'smudge' bit head NFATOCFA,7,NFA>CFA,docolon DW COUNT,LIT,07FH,AND,PLUS,EXIT ;Z IMMED? nfa -- f fetch immediate flag ; 1- C@ ; nonzero if immed head IMMEDQ,6,IMMED?,docolon DW ONEMINUS,CFETCH,EXIT ;C FIND c-addr -- c-addr 0 if not found ;C xt 1 if immediate ;C xt -1 if \"normal\" ; LATEST @ BEGIN -- a nfa ; 2DUP OVER C@ CHAR+ -- a nfa a nfa n+1 ; S= -- a nfa f ; DUP IF ; DROP ; NFA>LFA @ DUP -- a link link ; THEN ; 0= UNTIL -- a nfa OR a 0 ; DUP IF ; NIP DUP NFA>CFA -- nfa xt ; SWAP IMMED? -- xt iflag ; 0= 1 OR -- xt 1/-1 ; THEN ; head FIND,4,FIND,docolon DW LATEST,FETCH FIND1: DW TWODUP,OVER,CFETCH,CHARPLUS DW SEQUAL,DUP,qbranch,FIND2 DW DROP,NFATOLFA,FETCH,DUP FIND2: DW ZEROEQUAL,qbranch,FIND1 DW DUP,qbranch,FIND3 DW NIP,DUP,NFATOCFA DW SWOP,IMMEDQ,ZEROEQUAL,LIT,1,OR FIND3: DW EXIT ;C LITERAL x -- append numeric literal ; STATE @ IF ['] LIT ,XT , THEN ; IMMEDIATE ; This tests STATE so that it can also be used ; interpretively. (ANSI doesn't require this.) immed LITERAL,7,LITERAL,docolon DW STATE,FETCH,qbranch,LITER1 DW LIT,LIT,COMMAXT,COMMA LITER1: DW EXIT ;Z DIGIT? c -- n -1 if c is a valid digit ;Z -- x 0 otherwise ; [ HEX ] DUP 39 > 100 AND + silly looking ; DUP 140 > 107 AND - 30 - but it works! ; DUP BASE @ U< ; head DIGITQ,6,DIGIT?,docolon DW DUP,LIT,39H,GREATER,LIT,100H,AND,PLUS DW DUP,LIT,140H,GREATER,LIT,107H,AND DW MINUS,LIT,30H,MINUS DW DUP,BASE,FETCH,ULESS,EXIT ;Z ?SIGN adr n -- adr' n' f get optional sign ;Z advance adr/n if sign; return NZ if negative ; OVER C@ -- adr n c ; 2C - DUP ABS 1 = AND -- +=-1, -=+1, else 0 ; DUP IF 1+ -- +=0, -=+2 ; >R 1 /STRING R> -- adr' n' f ; THEN ; head QSIGN,5,?SIGN,docolon DW OVER,CFETCH,LIT,2CH,MINUS,DUP,ABS DW LIT,1,EQUAL,AND,DUP,qbranch,QSIGN1 DW ONEPLUS,TOR,LIT,1,SLASHSTRING,RFROM QSIGN1: DW EXIT ;C >NUMBER ud adr u -- ud' adr' u' ;C convert string to number ; BEGIN ; DUP WHILE ; OVER C@ DIGIT? ; 0= IF DROP EXIT THEN ; >R 2SWAP BASE @ UD* ; R> M+ 2SWAP ; 1 /STRING ; REPEAT ; head TONUMBER,7,>NUMBER,docolon TONUM1: DW DUP,qbranch,TONUM3 DW OVER,CFETCH,DIGITQ DW ZEROEQUAL,qbranch,TONUM2,DROP,EXIT TONUM2: DW TOR,TWOSWAP,BASE,FETCH,UDSTAR DW RFROM,MPLUS,TWOSWAP DW LIT,1,SLASHSTRING,branch,TONUM1 TONUM3: DW EXIT ;Z ?NUMBER c-addr -- n -1 string->number ;Z -- c-addr 0 if convert error ; DUP 0 0 ROT COUNT -- ca ud adr n ; ?SIGN >R >NUMBER -- ca ud adr' n' ; IF R> 2DROP 2DROP 0 -- ca 0 (error) ; ELSE 2DROP NIP R> ; IF NEGATE THEN -1 -- n -1 (ok) ; THEN ; head QNUMBER,7,?NUMBER,docolon DW DUP,LIT,0,DUP,ROT,COUNT DW QSIGN,TOR,TONUMBER,qbranch,QNUM1 DW RFROM,TWODROP,TWODROP,LIT,0 DW branch,QNUM3 QNUM1: DW TWODROP,NIP,RFROM,qbranch,QNUM2,NEGATE QNUM2: DW LIT,-1 QNUM3: DW EXIT ;Z INTERPRET i*x c-addr u -- j*x ;Z interpret given buffer ; This is a common factor of EVALUATE and QUIT. ; ref. dpANS-6, 3.4 The Forth Text Interpreter ; 'SOURCE 2! 0 >IN ! ; BEGIN ; BL WORD DUP C@ WHILE -- textadr ; FIND -- a 0/1/-1 ; ?DUP IF -- xt 1/-1 ; 1+ STATE @ 0= OR immed or interp? ; IF EXECUTE ELSE ,XT THEN ; ELSE -- textadr ; ?NUMBER ; IF POSTPONE LITERAL converted ok ; ELSE COUNT TYPE 3F EMIT CR ABORT err ; THEN ; THEN ; REPEAT DROP ; head INTERPRET,9,INTERPRET,docolon DW TICKSOURCE,TWOSTORE,LIT,0,TOIN,STORE INTER1: DW BL,WORD,DUP,CFETCH,qbranch,INTER9 DW FIND,QDUP,qbranch,INTER4 DW ONEPLUS,STATE,FETCH,ZEROEQUAL,OR DW qbranch,INTER2 DW EXECUTE,branch,INTER3 INTER2: DW COMMAXT INTER3: DW branch,INTER8 INTER4: DW QNUMBER,qbranch,INTER5 DW LITERAL,branch,INTER6 INTER5: DW COUNT,TYPE,LIT,3FH,EMIT,CR,ABORT INTER6: INTER8: DW branch,INTER1 INTER9: DW DROP,EXIT ;C EVALUATE i*x c-addr u -- j*x interprt string ; 'SOURCE 2@ >R >R >IN @ >R ; INTERPRET ; R> >IN ! R> R> 'SOURCE 2! ; head EVALUATE,8,EVALUATE,docolon DW TICKSOURCE,TWOFETCH,TOR,TOR DW TOIN,FETCH,TOR,INTERPRET DW RFROM,TOIN,STORE,RFROM,RFROM DW TICKSOURCE,TWOSTORE,EXIT ;C QUIT -- R: i*x -- interpret from kbd ; L0 LP ! R0 RP! 0 STATE ! ; BEGIN ; TIB DUP TIBSIZE ACCEPT SPACE ; INTERPRET ; STATE @ 0= IF CR .\" OK\" THEN ; AGAIN ; head QUIT,4,QUIT,docolon DW L0,LP,STORE DW R0,RPSTORE,LIT,0,STATE,STORE QUIT1: DW TIB,DUP,TIBSIZE,CPMACCEPT,SPACE DW INTERPRET DW STATE,FETCH,ZEROEQUAL,qbranch,QUIT2 DW CR,XSQUOTE DB 3,'ok ' DW TYPE QUIT2: DW branch,QUIT1 ;C ABORT i*x -- R: j*x -- clear stk & QUIT ; S0 SP! QUIT ; head ABORT,5,ABORT,docolon DW S0,SPSTORE,QUIT ; QUIT never returns ;Z ?ABORT f c-addr u -- abort & print msg ; ROT IF TYPE ABORT THEN 2DROP ; head QABORT,6,?ABORT,docolon DW ROT,qbranch,QABO1,TYPE,ABORT QABO1: DW TWODROP,EXIT ;C ABORT\" i*x 0 -- i*x R: j*x -- j*x x1=0 ;C i*x x1 -- R: j*x -- x1<>0 ; POSTPONE S\" POSTPONE ?ABORT ; IMMEDIATE immed ABORTQUOTE,6,ABORT\",docolon DW SQUOTE DW LIT,QABORT,COMMAXT DW EXIT ;C ' -- xt find word in dictionary ; BL WORD FIND ; 0= ABORT\" ?\" ; ; head TICK,1,',docolon DW link ; must expand DB 0 ; manually link DEFL $ ; because of DB 1,27h ; tick character TICK: call docolon DW BL,WORD,FIND,ZEROEQUAL,XSQUOTE DB 1,'?' DW QABORT,EXIT ;C CHAR -- char parse ASCII character ; BL WORD 1+ C@ ; head CHAR,4,CHAR,docolon DW BL,WORD,ONEPLUS,CFETCH,EXIT ;C [CHAR] -- compile character literal ; CHAR ['] LIT ,XT , ; IMMEDIATE immed BRACCHAR,6,[CHAR],docolon DW CHAR DW LIT,LIT,COMMAXT DW COMMA,EXIT ;C ( -- skip input until ) ; [ HEX ] 29 WORD DROP ; IMMEDIATE immed PAREN,1,(,docolon DW LIT,29H,WORD,DROP,EXIT ; COMPILER ====================================== ;C CREATE -- create an empty definition ; LATEST @ , 0 C, link & immed field ; HERE LATEST ! new \"latest\" link ; BL WORD C@ 1+ ALLOT name field ; docreate ,CF code field head CREATE,6,CREATE,docolon DW LATEST,FETCH,COMMA,LIT,0,CCOMMA DW HERE,LATEST,STORE DW BL,WORD,CFETCH,ONEPLUS,ALLOT DW LIT,docreate,COMMACF,EXIT ;Z (DOES>) -- run-time action of DOES> ; R> adrs of headless DOES> def'n ; LATEST @ NFA>CFA code field to fix up ; !CF ; head XDOES,7,(DOES>),docolon DW RFROM,LATEST,FETCH,NFATOCFA,STORECF DW EXIT ;C DOES> -- change action of latest def'n ; COMPILE (DOES>) ; dodoes ,CF ; IMMEDIATE immed DOES,5,DOES>,docolon DW LIT,XDOES,COMMAXT DW LIT,dodoes,COMMACF,EXIT ;C RECURSE -- recurse current definition ; LATEST @ NFA>CFA ,XT ; IMMEDIATE immed RECURSE,7,RECURSE,docolon DW LATEST,FETCH,NFATOCFA,COMMAXT,EXIT ;C [ -- enter interpretive state ; 0 STATE ! ; IMMEDIATE immed LEFTBRACKET,1,[,docolon DW LIT,0,STATE,STORE,EXIT ;C ] -- enter compiling state ; -1 STATE ! ; head RIGHTBRACKET,1,],docolon DW LIT,-1,STATE,STORE,EXIT ;Z HIDE -- \"hide\" latest definition ; LATEST @ DUP C@ 80 OR SWAP C! ; head HIDE,4,HIDE,docolon DW LATEST,FETCH,DUP,CFETCH,LIT,80H,OR DW SWOP,CSTORE,EXIT ;Z REVEAL -- \"reveal\" latest definition ; LATEST @ DUP C@ 7F AND SWAP C! ; head REVEAL,6,REVEAL,docolon DW LATEST,FETCH,DUP,CFETCH,LIT,7FH,AND DW SWOP,CSTORE,EXIT ;C IMMEDIATE -- make last def'n immediate ; 1 LATEST @ 1- C! ; set immediate flag head IMMEDIATE,9,IMMEDIATE,docolon DW LIT,1,LATEST,FETCH,ONEMINUS,CSTORE DW EXIT ;C : -- begin a colon definition ; CREATE HIDE ] !COLON ; head COLON,1,:,docode CALL docolon ; code fwd ref explicitly DW CREATE,HIDE,RIGHTBRACKET,STORCOLON DW EXIT ;C ; ; REVEAL ,EXIT ; POSTPONE [ ; IMMEDIATE immed SEMICOLON,1,';',docolon DW REVEAL,CEXIT DW LEFTBRACKET,EXIT ;C ['] -- find word & compile as literal ; ' ['] LIT ,XT , ; IMMEDIATE ; When encountered in a colon definition, the ; phrase ['] xxx will cause LIT,xxt to be ; compiled into the colon definition (where ; (where xxt is the execution token of word xxx). ; When the colon definition executes, xxt will ; be put on the stack. (All xt's are one cell.) ; immed BRACTICK,3,['],docolon DW link ; must expand DB 1 ; manually link DEFL $ ; because of DB 3,5Bh,27h,5Dh ; tick character BRACTICK: call docolon DW TICK ; get xt of 'xxx' DW LIT,LIT,COMMAXT ; append LIT action DW COMMA,EXIT ; append xt literal ;C POSTPONE -- postpone compile action of word ; BL WORD FIND ; DUP 0= ABORT\" ?\" ; 0< IF -- xt non immed: add code to current ; def'n to compile xt later. ; ['] LIT ,XT , add \"LIT,xt,COMMAXT\" ; ['] ,XT ,XT to current definition ; ELSE ,XT immed: compile into cur. def'n ; THEN ; IMMEDIATE immed POSTPONE,8,POSTPONE,docolon DW BL,WORD,FIND,DUP,ZEROEQUAL,XSQUOTE DB 1,'?' DW QABORT,ZEROLESS,qbranch,POST1 DW LIT,LIT,COMMAXT,COMMA DW LIT,COMMAXT,COMMAXT,branch,POST2 POST1: DW COMMAXT POST2: DW EXIT ;Z COMPILE -- append inline execution token ; R> DUP CELL+ >R @ ,XT ; ; The phrase ['] xxx ,XT appears so often that ; this word was created to combine the actions ; of LIT and ,XT. It takes an inline literal ; execution token and appends it to the dict. ; head COMPILE,7,COMPILE,docolon ; DW RFROM,DUP,CELLPLUS,TOR ; DW FETCH,COMMAXT,EXIT ; N.B.: not used in the current implementation ; CONTROL STRUCTURES ============================ ;C IF -- adrs conditional forward branch ; ['] qbranch ,BRANCH HERE DUP ,DEST ; ; IMMEDIATE immed IF,2,IF,docolon DW LIT,qbranch,COMMABRANCH DW HERE,DUP,COMMADEST,EXIT ;C THEN adrs -- resolve forward branch ; HERE SWAP !DEST ; IMMEDIATE immed THEN,4,THEN,docolon DW HERE,SWOP,STOREDEST,EXIT ;C ELSE adrs1 -- adrs2 branch for IF..ELSE ; ['] branch ,BRANCH HERE DUP ,DEST ; SWAP POSTPONE THEN ; IMMEDIATE immed ELSE,4,ELSE,docolon DW LIT,branch,COMMABRANCH DW HERE,DUP,COMMADEST DW SWOP,THEN,EXIT ;C BEGIN -- adrs target for bwd. branch ; HERE ; IMMEDIATE immed BEGIN,5,BEGIN,docode jp HERE ;C UNTIL adrs -- conditional backward branch ; ['] qbranch ,BRANCH ,DEST ; IMMEDIATE ; conditional backward branch immed UNTIL,5,UNTIL,docolon DW LIT,qbranch,COMMABRANCH DW COMMADEST,EXIT ;X AGAIN adrs -- uncond'l backward branch ; ['] branch ,BRANCH ,DEST ; IMMEDIATE ; unconditional backward branch immed AGAIN,5,AGAIN,docolon DW LIT,branch,COMMABRANCH DW COMMADEST,EXIT ;C WHILE -- adrs branch for WHILE loop ; POSTPONE IF ; IMMEDIATE immed WHILE,5,WHILE,docode jp IF ;C REPEAT adrs1 adrs2 -- resolve WHILE loop ; SWAP POSTPONE AGAIN POSTPONE THEN ; IMMEDIATE immed REPEAT,6,REPEAT,docolon DW SWOP,AGAIN,THEN,EXIT ;Z >L x -- L: -- x move to leave stack ; CELL LP +! LP @ ! ; (L stack grows up) head TOL,2,>L,docolon DW CELL,LP,PLUSSTORE,LP,FETCH,STORE,EXIT ;Z L> -- x L: x -- move from leave stack ; LP @ @ CELL NEGATE LP +! ; head LFROM,2,L>,docolon DW LP,FETCH,FETCH DW CELL,NEGATE,LP,PLUSSTORE,EXIT ;C DO -- adrs L: -- 0 ; ['] xdo ,XT HERE target for bwd branch ; 0 >L ; IMMEDIATE marker for LEAVEs immed DO,2,DO,docolon DW LIT,xdo,COMMAXT,HERE DW LIT,0,TOL,EXIT ;Z ENDLOOP adrs xt -- L: 0 a1 a2 .. aN -- ; ,BRANCH ,DEST backward loop ; BEGIN L> ?DUP WHILE POSTPONE THEN REPEAT ; ; resolve LEAVEs ; This is a common factor of LOOP and +LOOP. head ENDLOOP,7,ENDLOOP,docolon DW COMMABRANCH,COMMADEST LOOP1: DW LFROM,QDUP,qbranch,LOOP2 DW THEN,branch,LOOP1 LOOP2: DW EXIT ;C LOOP adrs -- L: 0 a1 a2 .. aN -- ; ['] xloop ENDLOOP ; IMMEDIATE immed LOOP,4,LOOP,docolon DW LIT,xloop,ENDLOOP,EXIT ;C +LOOP adrs -- L: 0 a1 a2 .. aN -- ; ['] xplusloop ENDLOOP ; IMMEDIATE immed PLUSLOOP,5,+LOOP,docolon DW LIT,xplusloop,ENDLOOP,EXIT ;C LEAVE -- L: -- adrs ; ['] UNLOOP ,XT ; ['] branch ,BRANCH HERE DUP ,DEST >L ; ; IMMEDIATE unconditional forward branch immed LEAVE,5,LEAVE,docolon DW LIT,unloop,COMMAXT DW LIT,branch,COMMABRANCH DW HERE,DUP,COMMADEST,TOL,EXIT ; OTHER OPERATIONS ============================== ;X WITHIN n1|u1 n2|u2 n3|u3 -- f n2<=n1<n3? ; OVER - >R - R> U< ; per ANS document head WITHIN,6,WITHIN,docolon DW OVER,MINUS,TOR,MINUS,RFROM,ULESS,EXIT ;C MOVE addr1 addr2 u -- smart move ; VERSION FOR 1 ADDRESS UNIT = 1 CHAR ; >R 2DUP SWAP DUP R@ + -- ... dst src src+n ; WITHIN IF R> CMOVE> src <= dst < src+n ; ELSE R> CMOVE THEN ; otherwise head MOVE,4,MOVE,docolon DW TOR,TWODUP,SWOP,DUP,RFETCH,PLUS DW WITHIN,qbranch,MOVE1 DW RFROM,CMOVEUP,branch,MOVE2 MOVE1: DW RFROM,CMOVE MOVE2: DW EXIT ;C DEPTH -- +n number of items on stack ; SP@ S0 SWAP - 2/ ; 16-BIT VERSION! head DEPTH,5,DEPTH,docolon DW SPFETCH,S0,SWOP,MINUS,TWOSLASH,EXIT ;C ENVIRONMENT? c-addr u -- false system query ; -- i*x true ; 2DROP 0 ; the minimal definition! head ENVIRONMENTQ,12,ENVIRONMENT?,docolon DW TWODROP,LIT,0,EXIT ; UTILITY WORDS AND STARTUP ===================== ;X WORDS -- list all words in dict. ; LATEST @ BEGIN ; DUP COUNT TYPE SPACE ; NFA>LFA @ ; DUP 0= UNTIL ; DROP ; head WORDS,5,WORDS,docolon DW LATEST,FETCH WDS1: DW DUP,COUNT,TYPE,SPACE,NFATOLFA,FETCH DW DUP,ZEROEQUAL,qbranch,WDS1 DW DROP,EXIT ;X .S -- print stack contents ; SP@ S0 - IF ; SP@ S0 2 - DO I @ U. -2 +LOOP ; THEN ; head DOTS,2,.S,docolon DW SPFETCH,S0,MINUS,qbranch,DOTS2 DW SPFETCH,S0,LIT,2,MINUS,XDO DOTS1: DW II,FETCH,UDOT,LIT,-2,XPLUSLOOP,DOTS1 DOTS2: DW EXIT ;Z COLD -- cold start Forth system ; UINIT U0 #INIT CMOVE init user area ; 80 COUNT INTERPRET interpret CP/M cmd ; .\" Z80 CamelForth etc.\" ; ABORT ; head COLD,4,COLD,docolon DW UINIT,U0,NINIT,CMOVE DW LIT,80h,COUNT,INTERPRET DW XSQUOTE DB 35,'Z80 CamelForth v1.01 25 Jan 1995' DB 0dh,0ah DW TYPE,ABORT ; ABORT never returns","title":"Camel80h"},{"location":"cameltst.html","text":"; Listing 1. ; =============================================== ; CamelForth for the Zilog Z80 ; Primitive testing code ; ; This is the \"minimal\" test of the CamelForth ; kernel. It verifies the threading and nesting ; mechanisms, the stacks, and the primitives ; DUP EMIT EXIT lit branch ONEPLUS. ; It is particularly useful because it does not ; use the DO..LOOP, multiply, or divide words, ; and because it can be used on embedded CPUs. ; The numeric display word .A is also useful ; for testing the rest of the Core wordset. ; ; The required macros and CPU initialization ; are in file CAMEL80.AZM. ; =============================================== ;Z >< u1 -- u2 swap the bytes of TOS head SWAB,2,><,docode ld a,b ld b,c ld c,a next ;Z LO c1 -- c2 return low nybble of TOS head LO,2,LO,docode ld a,c and 0fh ld c,a ld b,0 next ;Z HI c1 -- c2 return high nybble of TOS head HI,2,HI,docode ld a,c and 0f0h rrca rrca rrca rrca ld c,a ld b,0 next ;Z >HEX c1 -- c2 convert nybble to hex char head TOHEX,4,>HEX,docode ld a,c sub 0ah jr c,numeric add a,7 numeric: add a,3ah ld c,a next ;Z .HH c -- print byte as 2 hex digits ; DUP HI >HEX EMIT LO >HEX EMIT ; head DOTHH,3,.HH,docolon DW DUP,HI,TOHEX,EMIT,LO,TOHEX,EMIT,EXIT ;Z .B a -- a+1 fetch & print byte, advancing ; DUP C@ .HH 20 EMIT 1+ ; head DOTB,2,.B,docolon DW DUP,CFETCH,DOTHH,lit,20h,EMIT,ONEPLUS,EXIT ;Z .A u -- print unsigned as 4 hex digits ; DUP >< .HH .HH 20 EMIT ; head DOTA,2,.A,docolon DW DUP,SWAB,DOTHH,DOTHH,lit,20h,EMIT,EXIT ;X DUMP addr u -- dump u locations at addr ; 0 DO ; I 15 AND 0= IF CR DUP .A THEN ; .B ; LOOP DROP ; head DUMP,4,DUMP,docolon DW LIT,0,XDO DUMP2: DW II,LIT,15,AND,ZEROEQUAL,qbranch,DUMP1 DW CR,DUP,DOTA DUMP1: DW DOTB,XLOOP,DUMP2,DROP,EXIT ;Z ZQUIT -- endless dump for testing ; 0 BEGIN 0D EMIT 0A EMIT DUP .A ; .B .B .B .B .B .B .B .B ; .B .B .B .B .B .B .B .B ; AGAIN ; head ZQUIT,5,ZQUIT,docolon DW lit,0 zquit1: DW lit,0dh,EMIT,lit,0ah,EMIT,DUP,DOTA DW DOTB,DOTB,DOTB,DOTB,DOTB,DOTB,DOTB,DOTB DW DOTB,DOTB,DOTB,DOTB,DOTB,DOTB,DOTB,DOTB DW branch,zquit1","title":"Cameltst"},{"location":"glosslo.html","text":"TABLE 1. GLOSSARY OF WORDS IN CAMEL80.AZM Words which are (usually) written in CODE. NAME stack in -- stack out description Guide to stack diagrams: R: = return stack, c = 8-bit character, flag = boolean (0 or -1), n = signed 16-bit, u = unsigned 16-bit, d = signed 32-bit, ud = unsigned 32-bit, +n = unsigned 15-bit, x = any cell value, i*x j*x = any number of cell values, a-addr = aligned adrs, c-addr = character adrs p-addr = I/O port adrs, sys = system-specific. Refer to ANS Forth document for more details. ANS Forth Core words These are required words whose definitions are specified by the ANS Forth document. ! x a-addr -- store cell in memory + n1/u1 n2/u2 -- n3/u3 add n1+n2 +! n/u a-addr -- add cell to memory - n1/u1 n2/u2 -- n3/u3 subtract n1-n2 < n1 n2 -- flag test n1<n2, signed = x1 x2 -- flag test x1=x2 > n1 n2 -- flag test n1>n2, signed > > R x -- R: -- x push to return stack > ?DUP x -- 0 | x x DUP if nonzero > @ a-addr -- x fetch cell from memory > 0< n -- flag true if TOS negative > 0= n/u -- flag return true if TOS=0 > 1+ n1/u1 -- n2/u2 add 1 to TOS > 1- n1/u1 -- n2/u2 subtract 1 from TOS > 2* x1 -- x2 arithmetic left shift > 2/ x1 -- x2 arithmetic right shift > AND x1 x2 -- x3 logical AND > CONSTANT n -- define a Forth constant > C! c c-addr -- store char in memory > C@ c-addr -- c fetch char from memory > DROP x -- drop top of stack > DUP x -- x x duplicate top of stack > EMIT c -- output character to console > EXECUTE i*x xt -- j*x execute Forth word 'xt' > EXIT -- exit a colon definition > FILL c-addr u c -- fill memory with char > I -- n R: sys1 sys2 -- sys1 sys2 > > get the innermost loop index > > INVERT x1 -- x2 bitwise inversion > J -- n R: 4*sys -- 4*sys > > get the second loop index > > KEY -- c get character from keyboard > LSHIFT x1 u -- x2 logical L shift u places > NEGATE x1 -- x2 two's complement > OR x1 x2 -- x3 logical OR > OVER x1 x2 -- x1 x2 x1 per stack diagram > ROT x1 x2 x3 -- x2 x3 x1 per stack diagram > RSHIFT x1 u -- x2 logical R shift u places > R> -- x R: x -- pop from return stack > R@ -- x R: x -- x fetch from rtn stk > SWAP x1 x2 -- x2 x1 swap top two items > UM* u1 u2 -- ud unsigned 16x16->32 mult. > UM/MOD ud u1 -- u2 u3 unsigned 32/16->16 div. > UNLOOP -- R: sys1 sys2 -- drop loop parms > U< u1 u2 -- flag test u1<n2, unsigned > VARIABLE -- define a Forth variable > XOR x1 x2 -- x3 logical XOR ANS Forth Extensions These are optional words whose definitions are specified by the ANS Forth document. <> x1 x2 -- flag test not equal BYE i*x -- return to CP/M CMOVE c-addr1 c-addr2 u -- move from bottom CMOVE> c-addr1 c-addr2 u -- move from top KEY? -- flag return true if char waiting M+ d1 n -- d2 add single to double NIP x1 x2 -- x2 per stack diagram TUCK x1 x2 -- x2 x1 x2 per stack diagram U> u1 u2 -- flag test u1>u2, unsigned Private Extensions These are words which are unique to CamelForth. Many of these are necessary to implement ANS Forth words, but are not specified by the ANS document. Others are functions I find useful. (do) n1|u1 n2|u2 -- R: -- sys1 sys2 run-time code for DO (loop) R: sys1 sys2 -- | sys1 sys2 run-time code for LOOP (+loop) n -- R: sys1 sys2 -- | sys1 sys2 run-time code for +LOOP > < x1 -- x2 swap bytes > ?branch x -- branch if TOS zero > BDOS DE C -- A call CP/M BDOS > branch -- branch always > lit -- x fetch inline literal to stack > PC! c p-addr -- output char to port > PC@ p-addr -- c input char from port > RP! a-addr -- set return stack pointer > RP@ -- a-addr get return stack pointer > SCAN c-addr1 u1 c -- c-addr2 u2 > find matching char > SKIP c-addr1 u1 c -- c-addr2 u2 > skip matching chars > SP! a-addr -- set data stack pointer > SP@ -- a-addr get data stack pointer > S= c-addr1 c-addr2 u -- n string compare > n<0: s1<s2, n=0: s1=s2, n>0: s1>s2 > USER n -- define user variable 'n'","title":"Glosslo"},{"location":"moving1.html","text":"MOVING FORTH 1 Part 1: Design Decisions in the Forth Kernel by Brad Rodriguez This article first appeared in The Computer Journal (TCJ) #59 (January/February 1993) . INTRODUCTION Everyone in the Forth community talks about how easy it is to port Forth to a new CPU. But like many \"easy\" and \"obvious\" tasks, not much is written on how to do it! So, when Bill Kibler suggested this topic for an article, I decided to break with the great oral tradition of Forthwrights, and document the process in black and white. Over the course of these articles I will develop Forths for the 6809 , 8051 , and Z80 . I'm doing the 6809 to illustrate an easy and conventional Forth model; plus, I've already published a 6809 assembler [ROD91] [ROD92] , and I'll be needing a 6809 Forth for future TCJ projects. I'm doing the 8051 Forth for a University project, but it also illustrates some rather different design decisions. The Z80 Forth is for all the CP/M readers of TCJ, and for some friends with TRS-80 s gathering dust. THE ESSENTIAL HARDWARE You must choose a CPU. I will not delve into the merits of one CPU over another for Forth, since a CPU choice is usually forced upon you by other considerations. Besides, the object of this article is to show how to move Forth to any CPU. You can expect the usual 16-bit Forth kernel (see below) to occupy about 8 kBytes of program space. For a full kernel that can compile Forth definitions, you should allow a minimum of 1 kByte of RAM. To use Forth's block-management system for disk storage, you should add 3 kBytes or more for buffers. For a 32-bit Forth model, double these numbers. These are the minimums to get a Forth kernel up and running. To run an application on your hardware, you should increase PROM and RAM sizes to suit. 16 OR 32 BIT? The word size used by Forth is not necessarily the same as that of the CPU. The smallest practical Forth is a 16-bit model; i.e., one which uses 16-bit integers and 16-bit addresses. The Forth community calls this the \"cell\" size, since \"word\" refers to a Forth definition. 8-bit CPUs almost invariably support 16-bit Forths. This usually requires explicit coding of double-byte arithmetic, although some 8-bit CPUs do have a few 16-bit operations. 16-bit CPUs commonly run 16-bit Forths, although the same double-precision techniques can be used to write a 32-bit Forth on a 16-bit CPU. At least one 32-bit Forth has been written for the 8086/8088. 32-bit CPUs normally run 32-bit Forths. A smaller Forth model rarely saves code length or processor time. However, I know of at least one 16-bit Forth written for the 68000 . This does shrink application code size by a factor of two, since high-level Forth definitions become a string of 16-bit addresses rather than a string of 32-bit addresses. (This will become evident shortly.) Most 68000s, though, have plenty of RAM. All of the examples described in this article are 16-bit Forths running on 8-bit CPUs. THE THREADING TECHNIQUE \"Threaded code\" is the hallmark of Forth. A Forth \"thread\" is just a list of addresses of routines to be executed. You can think of this as a list of subroutine calls, with the CALL instructions removed. Over the years many threading variations have been devised, and which one is best depends upon the CPU and the application. To make a decision, you need to understand how they work, and their trade-offs. Indirect Threaded Code (ITC) This is the classical Forth threading technique, used in fig-Forth and F83 , and described in most books on Forth. All the other threading schemes are \"improvements\" on this, so you need to understand ITC to appreciate the others. Let's look at the definition of a Forth word SQUARE: : SQUARE DUP * ; In a typical ITC Forth this would appear in memory as shown in Figure 1 . (The Header Field will be discussed in a future article; it holds housekeeping information used for compilation, and isn't involved in threading.) Figure 1. Indirect Threaded Code Assume SQUARE is encountered while executing some other Forth word. Forth's Interpreter Pointer (IP) will be pointing to a cell in memory -- contained within that \"other\" word -- which contains the address of the word SQUARE. (To be precise, that cell contains the address of SQUARE's Code Field .) The interpreter fetches that address, and then uses it to fetch the contents of SQUARE's Code Field . These contents are yet another address -- the address of a machine language subroutine which performs the word SQUARE. In pseudo-code, this is: NEXT (interpreter) (IP) -> W fetch memory pointed by IP into \"W\" register ... W now holds address of the Code Field IP+2 -> IP advance IP, just like a program counter (assuming 2-byte addresses in the thread) (W) -> X fetch memory pointed by W into \"X\" register ... X now holds address of the machine code JP (X) jump to the address in the X register This illustrates an important but rarely-elucidated principle: the address of the Forth word just entered is kept in W. CODE words don't need this information, but all other kinds of Forth words do. If SQUARE were written in machine code, this would be the end of the story: that bit of machine code would be executed, and then jump back to the Forth interpreter -- which, since IP was incremented, is pointing to the next word to be executed. This is why the Forth interpreter is usually called NEXT. But, SQUARE is a high-level \"colon\" definition -- it holds a \"thread\", a list of addresses. In order to perform this definition, the Forth interpreter must be re-started at a new location: the Parameter Field of SQUARE. Of course, the interpreter's old location must be saved, to resume the \"other\" Forth word once SQUARE is finished. This is just like a subroutine call! The machine language action of SQUARE is simply to push the old IP, set IP to a new location, run the interpreter, and when SQUARE is done pop the IP. (As you can see, the IP is the \"program counter\" of high-level Forth.) This is called DOCOLON or ENTER in various Forths: ENTER PUSH IP onto the \"return address stack\" W+2 -> IP W still points to the Code Field , so W+2 is the address of the Body! (Assuming a 2-byte address -- other Forths may be different.) JUMP to interpreter (\"NEXT\") This identical code fragment is used by all high-level (i.e., threaded) Forth definitions! That's why a pointer to this code fragment, not the fragment itself, is included in the Forth definition. Over hundreds of definitions, the savings add up! And this is why it's called Indirect threading. The \"return from subroutine\" is the word EXIT, which gets compiled when Forth sees ';'. (Some Forths call it ;S instead of EXIT.) EXIT just executes a machine language routine which does the following: EXIT POP IP from the \"return address stack\" JUMP to interpreter Walk through a couple of nested Forth definitions, just to assure yourself that this works. Note the characteristics of ITC: every Forth word has a one-cell Code Field . Colon definitions compile one cell for each word used in the definition. And the Forth interpreter must actually perform a double indirection to get the address of the next machine code to run (first through IP, then through W). ITC is neither the smallest nor the fastest threading technique. It may be the simplest; although DTC (described next) is really no more complex. So why are so many Forths indirect-threaded? Mainly because previous Forths, used as models, were indirect-threaded. These days, DTC is becoming more popular. So when should ITC be used? Of the various techniques, ITC produces the cleanest and most elegant definitions -- nothing but addresses. If you're attuned to such considerations, ITC may appeal to you. If your code fiddles around with the insides of definitions, the simplicity and uniformity of the ITC representation may enhance portability. ITC is the classical Forth model, so it may be preferred for education. Finally, on CPUs lacking a subroutine call instruction -- such as the 1802 -- ITC is often more efficient than DTC. Direct Threaded Code (DTC) Direct Threaded Code differs from ITC in only one respect: instead of the Code Field containing the address of some machine code, the Code Field contains actual machine code itself. I'm not saying that the complete code for ENTER is contained in each and every colon definition! In \"high-level\" Forth words, the Code Field will contain a subroutine call , as shown in Figure 2 . Colon definitions, for instance, will contain a call to the ENTER routine. Figure 2. Direct Threaded Code The NEXT pseudo-code for direct threading is simply: (IP) -> W fetch memory pointed by IP into \"W\" register IP+2 -> IP advance IP (assuming 2-byte addresses) JP (W) jump to the address in the W register This gains speed: the interpreter now performs only a single indirection. On the Z80 this reduces the NEXT routine -- the most-used code fragment in the Forth kernel -- from eleven instructions to seven! This costs space: every high-level definition in a Z80 Forth (for example) is now one byte longer, since a 2-byte address has been replaced by a 3-byte call. But this is not universally true. A 32-bit 68000 Forth may replace a 4-byte address with a 4-byte BSR instruction, for no net loss. And on the Zilog Super8 , which has machine instructions for DTC Forth, the 2-byte address is replaced by a 1-byte ENTER instruction, making a DTC Forth smaller on the Super8! Of course, DTC CODE definitions are two bytes shorter, since they no longer need a pointer at all! I used to think that high-level definitions in DTC Forths required the use of a subroutine call in the Code Field . Frank Sergeant's Pygmy Forth [SER90] demonstrates that a simple jump can be used just as easily, and will usually be faster. Guy Kelly has compiled a superb review of Forth implementations for the IBM PC [KEL92] , which I strongly recommend to all Forth kernel writers. Of the 19 Forths he studied, 10 used DTC, 7 used ITC, and 2 used subroutine threading (discussed next). I recommend the use of Direct-Threaded Code over Indirect-Threaded Code for all new Forth kernels. Jump to NEXT, or code it in-line? The Forth inner interpreter, NEXT, is a common routine to all CODE definitions. You might keep just one copy of this common routine, and have all CODE words jump to it. (Note that you Jump to NEXT; a subroutine Call is not necessary.) However, the speed of NEXT is crucial to the speed of the entire Forth system. Also, on many CPUs, the NEXT routine is quite short; often only two or three instructions. So it may be preferable to code NEXT in-line, wherever it is used. This is frequently done by making NEXT an assembler macro. This is a simple speed vs. space decision: in-line NEXT is always faster, but almost always larger. The total size increase is the number of extra bytes required for in-line expansion, times the number of CODE words in the system. Sometimes there's no tradeoff at all: in a 6809 DTC Forth, an in-line NEXT is shorter than a Jump instruction! Subroutine Threaded Code (STC) A high-level Forth definition is nothing but a list of subroutines to be executed. You don't need interpreters to accomplish this; you can get the same effect by simply stringing a list of subroutine calls together: SQUARE: CALL DUP CALL * ; or a suitable alphanumeric name RET See Figure 3 . This representation of Forth words has been used as a starting point to explain Forth threading techniques to assembly language programmers [KOG82] . Figure 3. Subroutine Threaded Code STC is an elegant representation; colon definitions and CODE words are now identical. \"Defined words\" (VARIABLEs, CONSTANTs, and the like) are handled the same as in DTC -- the Code Field begins with a jump or call to some machine code elsewhere. The major disadvantage is that subroutine calls are usually larger than simple addresses. On the Z80, for example, the size of colon definitions increases by 50% -- and most of your application is colon definitions! Contrariwise, on a 32-bit 68000 there may be no size increase at all, when 4-byte addresses are replaced with 4-byte BSRs. (But if your code size exceeds 64K, some of those addresses must be replaced with 6-byte JSRs.) Subroutine threading may be faster than direct threading. You save time by not having an interpreter, but you lose time because every reference to a Forth word involves a push and pop of a return address. In a DTC Forth, only high-level words cause activity on the return stack. On the 6809 or Zilog Super8, DTC is faster than STC. There is another advantage to STC: it dispenses with the IP register. Some processors -- like the 8051 -- are desperately short of addressing registers. Eliminating the IP can really simplify and speed up the kernel! The only way to know for sure is to write sample code. This is intimately involved with register selection, discussed in the next section. STC with in-line expansion; optimization; direct compilation On older and 8-bit CPUs, almost every Forth primitive involves several machine instructions. But on more powerful CPUs, many Forth primitives are written in a single instruction. For example, on the 32-bit 68000, DROP is simply ADDQ #4,An where An is Forth's PSP register In a subroutine-threaded Forth, using DROP in a colon definition would result in the sequence BSR ... BSR DROP -------> DROP: ADDQ #4,An BSR ... <------- RTS ADDQ is a two-byte instruction. Why write a four-byte subroutine call to a two-byte instruction? No matter how many times DROP is used, there's no savings! The code is smaller and faster if the ADDQ is coded directly into the stream of BSRs. Some Forth compilers do this \"in-line expansion\" of CODE words [CUR93a] . The disadvantage of in-line expansion is that decompiling back to the original source code becomes very difficult. As long as subroutine calls are used, you still have pointers (the subroutine addresses) to the Forth words comprising the thread. With pointers to the words, you can obtain their names. But once a word is expanded into in-line code, all knowledge of where that code came from is lost. The advantage of in-line expansion -- aside from speed and size -- is the potential for code optimization. For example, the Forth sequence 3 + would be compiled in 68000 STC as BSR LIT .DW 3 BSR PLUS but could be expanded in-line as a single machine instruction! Optimizing Forth compilers is too broad a topic for this article. This is an active area of Forth language research; see, for instance, [SCO89] and [CUR93b] . The final culmination of optimized STC is a Forth which compiles to \"pure\" machine code, just like a C or Fortran compiler. Token Threaded Code (TTC) DTC and STC aim to improve the speed of Forth programs, at some cost in memory. Now let's move the other direction from ITC, toward something slower but smaller. The purpose of a Forth thread is to specify a list of Forth words (subroutines) to be performed. Suppose a 16-bit Forth system only had a maximum of 256 different words. Then each word could be uniquely identified by an 8-bit number. Instead of a list of 16-bit addresses, you would have a list of 8-bit identifiers or \"tokens,\" and the size of the colon definitions would be halved! A token-threaded Forth keeps a table of addresses of all Forth words, as shown in Figure 4 . The token value is then used to index into this table, to find the Forth word corresponding to a given token. This adds one level of indirection to the Forth interpreter, so it is slower than an \"address-threaded\" Forth. Figure 4. Token Threaded Code The principal advantage of token-threaded Forths is small size. TTC is most commonly seen in handheld computers and other severely size-constrained applications. Also, the table of \"entry points\" into all the Forth words can simplify linkage of separately-compiled modules. The disadvantage of TTC is speed: TTC makes the slowest Forths. Also, the TTC compiler is slightly more complex. If you need more than 256 Forth words, it's necessary to have some open-ended encoding scheme to mix 8-bit and larger tokens. I can envision a 32-bit Forth using 16-bit tokens, but how many 32-bit systems are size-constrained? Segment Threaded Code Since there are so many 8086 derivatives in the world, segment threading deserves a brief mention. Instead of using \"normal\" byte addresses within a 64K segment, paragraph addresses are used. (A \"paragraph\" is 16 bytes in the 8086.) Then, the interpreter can load these addresses into segment registers, instead of into the usual address registers. This allows a 16- bit Forth model to efficiently access the full megabyte of 8086 memory. The principal disadvantage of segment threading is the 16-byte \"granularity\" of the memory space. Every Forth word must be aligned to a 16-byte boundary. If Forth words have random lengths, an average of 8 bytes will be wasted per Forth word. REGISTER ALLOCATION Next to the threading technique, the usage of the CPU's registers is the most crucial design decision. It's probably the most difficult. The availability of CPU registers can determine what threading technique can be used, and even what the memory map will be! The Classical Forth Registers The classical Forth model has five \"virtual registers.\" These are abstract entities which are used in the primitive operations of Forth. NEXT, ENTER, and EXIT were defined earlier in terms of these abstract registers. Each of these is one cell wide -- i.e., in a 16-bit Forth, these are 16-bit registers. (There are exceptions to this rule, as you will see later.) These may not all be CPU registers. If your CPU doesn't have enough registers, some of these can be kept in memory. I'll describe them in the order of their importance; i.e., the bottom of this list are the best candidates to be stored in memory. W is the Working register. It is used for many things, including memory reference, so it should be an address register; i.e., you must be able to fetch and store memory using the contents of W as the address. You also need to be able to do arithmetic on W. (In DTC Forths, you must also be able to jump indirect using W.) W is used by the interpreter in every Forth word . In a CPU having only one register, you would use it for W and keep everything else in memory (and the system would be incredibly slow). IP is the Interpreter Pointer. This is used by every Forth word (through NEXT, ENTER, or EXIT). IP must be an address register. You also need to be able to increment IP. Subroutine threaded Forths don't need this register. PSP is the Parameter Stack (or \"data stack\") Pointer, sometimes called simply SP. I prefer PSP because SP is frequently the name of a CPU register, and they shouldn't be confused. Most CODE words use this. PSP must be a stack pointer, or an address register which can be incremented and decremented. It's also a plus if you can do indexed addressing from PSP. RSP is the Return Stack Pointer, sometimes called simply RP. This is used by colon definitions in ITC and DTC Forths, and by all words in STC Forths. RSP must be a stack pointer, or an address register which can be incremented and decremented. If at all possible , put W, IP, PSP, and RSP in registers. The virtual registers that follow can be kept in memory, but there is usually a speed advantage to keeping them in CPU registers. X is a working register, not considered one of the \"classical\" Forth registers, even though the classical ITC Forths need it for the second indirection. In ITC you must be able to jump indirect using X. X may also be used by a few CODE words to do arithmetic and such. This is particularly important on processors that cannot use memory as an operand. For example, ADD on a Z80 might be (in pseudo-code) POP W POP X X+W -> W PUSH W Sometimes another working register, Y, is also defined. UP is the User Pointer, holding the base address of the task's user area. UP is usually added to an offset, and used by high-level Forth code, so it can be just stored somewhere. But if the CPU can do indexed addressing from the UP register, CODE words can more easily and quickly access user variables. If you have a surplus of address registers, use one for UP. Single-task Forths don't need UP. X -- if needed -- is more important to keep in register than UP. UP is the easiest of the Forth virtual registers to move into memory. Use of the Hardware Stack Most CPUs have a stack pointer as part of their hardware, used by interrupts and subroutine calls. How does this map into the Forth registers? Should it be the PSP or the RSP? The short answer is, it depends . It is said that the PSP is used more than the RSP in ITC and DTC Forths. If your CPU has few address registers, and PUSH and POP are faster than explicit reference, use the hardware stack as the Parameter Stack. On the other hand, if your CPU is rich in addressing modes -- and allows indexed addressing -- there's a plus in having the PSP as a general-purpose address register. In this case, use the hardware stack as the Return Stack. Sometimes you do neither! The TMS320C25 's hardware stack is only eight cells deep -- all but useless for Forth. So its hardware stack is used only for interrupts, and both PSP and RSP are general-purpose address registers. (ANS Forth specifies a minimum of 32 cells of Parameter Stack and 24 cells of Return Stack; I prefer 64 cells of each.) You will occasionally encounter the dogma that the hardware stack \"must be\" the Parameter Stack, or \"must be\" the Return Stack. Instead, code some sample Forth primitives, such as SWAP OVER @ ! + 0= and see which approach is smaller or faster. (DUP and DROP, by the way, are no test -- they're usually trivial.) Occasionally you reach strange conclusions! Gary Bergstrom has pointed out that a 6809 DTC Forth can be made a few cycles faster by using the 6809 user stack pointer as the IP ; NEXT becomes a POP. He uses an index register for one of Forth's stacks. Top-Of-Stack in Register Forth's performance can be improved considerably by keeping the top element of the Parameter Stack in a register! Many Forth words (such as 0=) then don't need to use the stack. Other words still do the same number of pushes and pops, only in a different place in the code. Only a few Forth words (DROP and 2DROP) become more complicated, since you can no longer simply adjust the stack pointer -- you have to update the TOS register as well. There are a few rules when writing CODE words: A word which removes items from the stack must pop the \"new\" TOS into its register. A word which adds items to the stack must push the \"old\" TOS onto the stack (unless, of course, it's consumed by the word). If you have at least six cell-size CPU registers, I recommend keeping the TOS in a register. I consider TOS more important than UP to have in register, but less important than W, IP, PSP, and RSP. (TOS in register performs many of the functions of the X register.) It's useful if this register can perform memory addressing. PDP-11 s, Z8 s, and 68000s are good candidates. Nine of the 19 IBM PC Forths studied by Guy Kelly [KEL92] keep TOS in register. I think this innovation has been resisted because of the false beliefs that a) it adds instructions, and b) the top stack element must be accessible as memory. It turns out that even such words as PICK, ROLL, and DEPTH are trivially modified for TOS-in-register. What about buffering two stack elements in registers? When you keep the top of stack in a register, the total number of operations performed remains essentially the same. A push remains a push, regardless of whether it is before or after the operation you're performing. On the other hand, buffering two stack elements in registers adds a large number of instructions -- a push becomes a push followed by a move. Only dedicated Forth processors like the RTX2000 and fantastically clever optimizing compilers can benefit from buffering two stack elements in registers. Some examples Here are the register assignments made by Forths for a number of different CPUs. Try to deduce the design decisions of the authors from this list. Register Assignments W IP PSP RSP UP TOS 8086 [1] BX SI SP BP memory memory [LAX84] 8086 [2] AX SI SP BP none BX [SER90] 68000 A5 A4 A3 A7=SP A6 memory [CUR86] PDP-11 R2 R4 R5 R6=SP R3 memory [JAM80] 6809 X Y U S memory memory [TAL80] 6502 Zpage Zpage X SP Zpage memory [KUN81] Z80 DE BC SP IX none memory [LOE81] Z8 RR6 RR12 RR14 SP RR10 RR8 [MPE92] 8051 R0,1 R2,3 R4,5 R6,7 fixed memory [PAY90] [1] F83. [2] Pygmy Forth. \"SP\" refers to the hardware stack pointer. \"Zpage\" refers to values kept in the 6502's memory page zero, which are almost as useful as -- sometimes more useful than -- values kept in registers; e.g., they can be used for memory addressing. \"Fixed\" means that Payne's 8051 Forth has a single, immovable user area, and UP is a hard-coded constant. Narrow Registers Notice anything odd in the previous list? The 6502 Forth -- a 16-bit model -- uses 8-bit stack pointers! It is possible to make PSP, RSP, and UP smaller than the cell size of the Forth. This is because the stacks and user area are both relatively small areas of memory. Each stack may be as small as 64 cells in length, and the user area rarely exceeds 128 cells. You simply need to ensure that either a) these data areas are confined to a small area of memory, so a short address can be used, or b) the high address bits are provided in some other way, e.g., a memory page select. In the 6502, the hardware stack is confined to page one of RAM (addresses 01xxh) by the design of the CPU. The 8-bit stack pointer can be used for the Return Stack. The Parameter Stack is kept in page zero of RAM, which can be indirectly accessed by the 8-bit index register X. (Question for the advanced student: why use the 6502's X, and not Y? Hint: look at the addressing modes available.) In the 8051, you can use the 8-bit registers R0 and R1 to address external RAM, provided that you explicitly output the high 8 bits of address to port 2. This allows a \"page select\" for two stacks. UP is different from PSP and RSP: it simply provides a base address; it is never incremented or decremented. So it's practical to supply only the high bits of this virtual register. The low bits must then be provided by whatever indexed addressing technique is used. For example, on the 6809, you can use the DP register to hold the high 8 bits of UP, and then use Direct Page addressing to access any of the 256 locations in this page. This forces all user areas to begin on an address xx00h, which is no great hardship, and limits the user area to 128 cells in length. On the 8086 you could conceivably use a segment register to specify the base address of the user area. REFERENCES [CUR93a] Curley, Charles , \"Life in the FastForth Lane\", awaiting publication in Forth Dimensions. Description of a 68000 subroutine-threaded Forth. [1] [2] [3] [4] [5] [CUR93b] Curley, Charles, \"Optimizing in a BSR/JSR Threaded Forth\", awaiting publication in Forth Dimensions. Single-pass code optimization for FastForth, in only five screens of code! Includes listing. [1] [2] [3] [4] [KEL92] Kelly, Guy M., \"Forth Systems Comparisons\", Forth Dimensions XIII:6 (Mar/Apr 1992). Also published in the 1991 FORML Conference Proceedings . Both available from the Forth Interest Group, P.O. Box 2154, Oakland, CA 94621. Illustrates design trade offs of many 8086 Forths with code fragments and benchmarks -- highly recommended! [1] [2] [3] [KOG82] Kogge, Peter M., \"An Architectural Trail to Threaded-Code Systems\", IEEE Computer, vol. 15 no. 3 (Mar 1982). Remains the definitive description of various threading techniques. [1] [2] [ROD91] Rodriguez, B.J. , \"B.Y.O. Assembler\", Part 1, The Computer Journal #52 (Sep/Oct 1991). General principles of writing Forth assemblers. [1] [2] [ROD92] Rodriguez, B.J., \"B.Y.O. Assembler\", Part 2, The Computer Journal #54 (Jan/Feb 1992). A 6809 assembler in Forth. [1] [2] [SCO89] Scott, Andrew: \"An Extensible Optimizer for Compiling Forth\", 1989 FORML Conference Proceedings , Forth Interest Group, P.O. Box 2154, Oakland, CA 94621. Good description of a 68000 optimizer; no code provided. \"Extensible Optimizing Compiler\", Forth Dimensions XII:2 (Jul/Aug 1990). [1] [2] Forth Implementations [CUR86] Curley, Charles, real-Forth for the 68000 , privately distributed (1986) . [1] [JAM80] James, John S., fig-Forth for the PDP-11 , Forth Interest Group (1980). [1] [2] [KUN81] Kuntze, Robert E., MVP-Forth for the Apple II , Mountain View Press (1981). [1] [2] [LAX84] Laxen, H. and Perry, M., F83 for the IBM PC , version 2.1.0 (1984). Distributed by the authors, available from the Forth Interest Group or GEnie. [1] [2] [LOE81] Loeliger, R. G., Threaded Interpretive Languages , BYTE Publications (1981), ISBN 0-07-038360-X. May be the only book ever written on the subject of creating a Forth-like kernel (the example used is the Z80). Worth it if you can find a copy. [1] [2] [MPE92] MicroProcessor Engineering Ltd., MPE Z8/Super8 PowerForth Target , MPE Ltd., 133 Hill Lane, Shirley, Southampton, S01 5AF, U.K. (June 1992). A commercial product. [1] [PAY90] Payne, William H., Embedded Controller FORTH for the 8051 Family , Academic Press (1990), ISBN 0-12-547570-5. This is a complete \"kit\" for a 8051 Forth, including a metacompiler for the IBM PC. Hardcopy only; files can be downloaded from GEnie . Not for the novice! [1] [2] [SER90] Sergeant, Frank, Pygmy Forth for the IBM PC , version 1.3 (1990). Distributed by the author, available from the Forth Interest Group. Version 1.4 is now available on GEnie, and worth the extra effort to obtain. [1] [TAL80] Talbot, R. J., fig-Forth for the 6809 , Forth Interest Group (1980). [1] Author's note for web publication: the files formerly available on the GEnie online service are now available from the Forth Interest Group FTP server, ftp://ftp.forth.org/pub/Forth http://www.forth.org/","title":"MOVING FORTH 1"},{"location":"moving1.html#moving-forth-1","text":"Part 1: Design Decisions in the Forth Kernel by Brad Rodriguez This article first appeared in The Computer Journal (TCJ) #59 (January/February 1993) .","title":"MOVING FORTH 1"},{"location":"moving1.html#introduction","text":"Everyone in the Forth community talks about how easy it is to port Forth to a new CPU. But like many \"easy\" and \"obvious\" tasks, not much is written on how to do it! So, when Bill Kibler suggested this topic for an article, I decided to break with the great oral tradition of Forthwrights, and document the process in black and white. Over the course of these articles I will develop Forths for the 6809 , 8051 , and Z80 . I'm doing the 6809 to illustrate an easy and conventional Forth model; plus, I've already published a 6809 assembler [ROD91] [ROD92] , and I'll be needing a 6809 Forth for future TCJ projects. I'm doing the 8051 Forth for a University project, but it also illustrates some rather different design decisions. The Z80 Forth is for all the CP/M readers of TCJ, and for some friends with TRS-80 s gathering dust.","title":"INTRODUCTION"},{"location":"moving1.html#the-essential-hardware","text":"You must choose a CPU. I will not delve into the merits of one CPU over another for Forth, since a CPU choice is usually forced upon you by other considerations. Besides, the object of this article is to show how to move Forth to any CPU. You can expect the usual 16-bit Forth kernel (see below) to occupy about 8 kBytes of program space. For a full kernel that can compile Forth definitions, you should allow a minimum of 1 kByte of RAM. To use Forth's block-management system for disk storage, you should add 3 kBytes or more for buffers. For a 32-bit Forth model, double these numbers. These are the minimums to get a Forth kernel up and running. To run an application on your hardware, you should increase PROM and RAM sizes to suit.","title":"THE ESSENTIAL HARDWARE"},{"location":"moving1.html#16-or-32-bit","text":"The word size used by Forth is not necessarily the same as that of the CPU. The smallest practical Forth is a 16-bit model; i.e., one which uses 16-bit integers and 16-bit addresses. The Forth community calls this the \"cell\" size, since \"word\" refers to a Forth definition. 8-bit CPUs almost invariably support 16-bit Forths. This usually requires explicit coding of double-byte arithmetic, although some 8-bit CPUs do have a few 16-bit operations. 16-bit CPUs commonly run 16-bit Forths, although the same double-precision techniques can be used to write a 32-bit Forth on a 16-bit CPU. At least one 32-bit Forth has been written for the 8086/8088. 32-bit CPUs normally run 32-bit Forths. A smaller Forth model rarely saves code length or processor time. However, I know of at least one 16-bit Forth written for the 68000 . This does shrink application code size by a factor of two, since high-level Forth definitions become a string of 16-bit addresses rather than a string of 32-bit addresses. (This will become evident shortly.) Most 68000s, though, have plenty of RAM. All of the examples described in this article are 16-bit Forths running on 8-bit CPUs.","title":"16 OR 32 BIT?"},{"location":"moving1.html#the-threading-technique","text":"\"Threaded code\" is the hallmark of Forth. A Forth \"thread\" is just a list of addresses of routines to be executed. You can think of this as a list of subroutine calls, with the CALL instructions removed. Over the years many threading variations have been devised, and which one is best depends upon the CPU and the application. To make a decision, you need to understand how they work, and their trade-offs.","title":"THE THREADING TECHNIQUE"},{"location":"moving1.html#indirect-threaded-code-itc","text":"This is the classical Forth threading technique, used in fig-Forth and F83 , and described in most books on Forth. All the other threading schemes are \"improvements\" on this, so you need to understand ITC to appreciate the others. Let's look at the definition of a Forth word SQUARE: : SQUARE DUP * ; In a typical ITC Forth this would appear in memory as shown in Figure 1 . (The Header Field will be discussed in a future article; it holds housekeeping information used for compilation, and isn't involved in threading.) Figure 1. Indirect Threaded Code Assume SQUARE is encountered while executing some other Forth word. Forth's Interpreter Pointer (IP) will be pointing to a cell in memory -- contained within that \"other\" word -- which contains the address of the word SQUARE. (To be precise, that cell contains the address of SQUARE's Code Field .) The interpreter fetches that address, and then uses it to fetch the contents of SQUARE's Code Field . These contents are yet another address -- the address of a machine language subroutine which performs the word SQUARE. In pseudo-code, this is: NEXT (interpreter) (IP) -> W fetch memory pointed by IP into \"W\" register ... W now holds address of the Code Field IP+2 -> IP advance IP, just like a program counter (assuming 2-byte addresses in the thread) (W) -> X fetch memory pointed by W into \"X\" register ... X now holds address of the machine code JP (X) jump to the address in the X register This illustrates an important but rarely-elucidated principle: the address of the Forth word just entered is kept in W. CODE words don't need this information, but all other kinds of Forth words do. If SQUARE were written in machine code, this would be the end of the story: that bit of machine code would be executed, and then jump back to the Forth interpreter -- which, since IP was incremented, is pointing to the next word to be executed. This is why the Forth interpreter is usually called NEXT. But, SQUARE is a high-level \"colon\" definition -- it holds a \"thread\", a list of addresses. In order to perform this definition, the Forth interpreter must be re-started at a new location: the Parameter Field of SQUARE. Of course, the interpreter's old location must be saved, to resume the \"other\" Forth word once SQUARE is finished. This is just like a subroutine call! The machine language action of SQUARE is simply to push the old IP, set IP to a new location, run the interpreter, and when SQUARE is done pop the IP. (As you can see, the IP is the \"program counter\" of high-level Forth.) This is called DOCOLON or ENTER in various Forths: ENTER PUSH IP onto the \"return address stack\" W+2 -> IP W still points to the Code Field , so W+2 is the address of the Body! (Assuming a 2-byte address -- other Forths may be different.) JUMP to interpreter (\"NEXT\") This identical code fragment is used by all high-level (i.e., threaded) Forth definitions! That's why a pointer to this code fragment, not the fragment itself, is included in the Forth definition. Over hundreds of definitions, the savings add up! And this is why it's called Indirect threading. The \"return from subroutine\" is the word EXIT, which gets compiled when Forth sees ';'. (Some Forths call it ;S instead of EXIT.) EXIT just executes a machine language routine which does the following: EXIT POP IP from the \"return address stack\" JUMP to interpreter Walk through a couple of nested Forth definitions, just to assure yourself that this works. Note the characteristics of ITC: every Forth word has a one-cell Code Field . Colon definitions compile one cell for each word used in the definition. And the Forth interpreter must actually perform a double indirection to get the address of the next machine code to run (first through IP, then through W). ITC is neither the smallest nor the fastest threading technique. It may be the simplest; although DTC (described next) is really no more complex. So why are so many Forths indirect-threaded? Mainly because previous Forths, used as models, were indirect-threaded. These days, DTC is becoming more popular. So when should ITC be used? Of the various techniques, ITC produces the cleanest and most elegant definitions -- nothing but addresses. If you're attuned to such considerations, ITC may appeal to you. If your code fiddles around with the insides of definitions, the simplicity and uniformity of the ITC representation may enhance portability. ITC is the classical Forth model, so it may be preferred for education. Finally, on CPUs lacking a subroutine call instruction -- such as the 1802 -- ITC is often more efficient than DTC.","title":"Indirect Threaded Code (ITC)"},{"location":"moving1.html#direct-threaded-code-dtc","text":"Direct Threaded Code differs from ITC in only one respect: instead of the Code Field containing the address of some machine code, the Code Field contains actual machine code itself. I'm not saying that the complete code for ENTER is contained in each and every colon definition! In \"high-level\" Forth words, the Code Field will contain a subroutine call , as shown in Figure 2 . Colon definitions, for instance, will contain a call to the ENTER routine. Figure 2. Direct Threaded Code The NEXT pseudo-code for direct threading is simply: (IP) -> W fetch memory pointed by IP into \"W\" register IP+2 -> IP advance IP (assuming 2-byte addresses) JP (W) jump to the address in the W register This gains speed: the interpreter now performs only a single indirection. On the Z80 this reduces the NEXT routine -- the most-used code fragment in the Forth kernel -- from eleven instructions to seven! This costs space: every high-level definition in a Z80 Forth (for example) is now one byte longer, since a 2-byte address has been replaced by a 3-byte call. But this is not universally true. A 32-bit 68000 Forth may replace a 4-byte address with a 4-byte BSR instruction, for no net loss. And on the Zilog Super8 , which has machine instructions for DTC Forth, the 2-byte address is replaced by a 1-byte ENTER instruction, making a DTC Forth smaller on the Super8! Of course, DTC CODE definitions are two bytes shorter, since they no longer need a pointer at all! I used to think that high-level definitions in DTC Forths required the use of a subroutine call in the Code Field . Frank Sergeant's Pygmy Forth [SER90] demonstrates that a simple jump can be used just as easily, and will usually be faster. Guy Kelly has compiled a superb review of Forth implementations for the IBM PC [KEL92] , which I strongly recommend to all Forth kernel writers. Of the 19 Forths he studied, 10 used DTC, 7 used ITC, and 2 used subroutine threading (discussed next). I recommend the use of Direct-Threaded Code over Indirect-Threaded Code for all new Forth kernels.","title":"Direct Threaded Code (DTC)"},{"location":"moving1.html#jump-to-next-or-code-it-in-line","text":"The Forth inner interpreter, NEXT, is a common routine to all CODE definitions. You might keep just one copy of this common routine, and have all CODE words jump to it. (Note that you Jump to NEXT; a subroutine Call is not necessary.) However, the speed of NEXT is crucial to the speed of the entire Forth system. Also, on many CPUs, the NEXT routine is quite short; often only two or three instructions. So it may be preferable to code NEXT in-line, wherever it is used. This is frequently done by making NEXT an assembler macro. This is a simple speed vs. space decision: in-line NEXT is always faster, but almost always larger. The total size increase is the number of extra bytes required for in-line expansion, times the number of CODE words in the system. Sometimes there's no tradeoff at all: in a 6809 DTC Forth, an in-line NEXT is shorter than a Jump instruction!","title":"Jump to NEXT, or code it in-line?"},{"location":"moving1.html#subroutine-threaded-code-stc","text":"A high-level Forth definition is nothing but a list of subroutines to be executed. You don't need interpreters to accomplish this; you can get the same effect by simply stringing a list of subroutine calls together: SQUARE: CALL DUP CALL * ; or a suitable alphanumeric name RET See Figure 3 . This representation of Forth words has been used as a starting point to explain Forth threading techniques to assembly language programmers [KOG82] . Figure 3. Subroutine Threaded Code STC is an elegant representation; colon definitions and CODE words are now identical. \"Defined words\" (VARIABLEs, CONSTANTs, and the like) are handled the same as in DTC -- the Code Field begins with a jump or call to some machine code elsewhere. The major disadvantage is that subroutine calls are usually larger than simple addresses. On the Z80, for example, the size of colon definitions increases by 50% -- and most of your application is colon definitions! Contrariwise, on a 32-bit 68000 there may be no size increase at all, when 4-byte addresses are replaced with 4-byte BSRs. (But if your code size exceeds 64K, some of those addresses must be replaced with 6-byte JSRs.) Subroutine threading may be faster than direct threading. You save time by not having an interpreter, but you lose time because every reference to a Forth word involves a push and pop of a return address. In a DTC Forth, only high-level words cause activity on the return stack. On the 6809 or Zilog Super8, DTC is faster than STC. There is another advantage to STC: it dispenses with the IP register. Some processors -- like the 8051 -- are desperately short of addressing registers. Eliminating the IP can really simplify and speed up the kernel! The only way to know for sure is to write sample code. This is intimately involved with register selection, discussed in the next section.","title":"Subroutine Threaded Code (STC)"},{"location":"moving1.html#stc-with-in-line-expansion-optimization-direct-compilation","text":"On older and 8-bit CPUs, almost every Forth primitive involves several machine instructions. But on more powerful CPUs, many Forth primitives are written in a single instruction. For example, on the 32-bit 68000, DROP is simply ADDQ #4,An where An is Forth's PSP register In a subroutine-threaded Forth, using DROP in a colon definition would result in the sequence BSR ... BSR DROP -------> DROP: ADDQ #4,An BSR ... <------- RTS ADDQ is a two-byte instruction. Why write a four-byte subroutine call to a two-byte instruction? No matter how many times DROP is used, there's no savings! The code is smaller and faster if the ADDQ is coded directly into the stream of BSRs. Some Forth compilers do this \"in-line expansion\" of CODE words [CUR93a] . The disadvantage of in-line expansion is that decompiling back to the original source code becomes very difficult. As long as subroutine calls are used, you still have pointers (the subroutine addresses) to the Forth words comprising the thread. With pointers to the words, you can obtain their names. But once a word is expanded into in-line code, all knowledge of where that code came from is lost. The advantage of in-line expansion -- aside from speed and size -- is the potential for code optimization. For example, the Forth sequence 3 + would be compiled in 68000 STC as BSR LIT .DW 3 BSR PLUS but could be expanded in-line as a single machine instruction! Optimizing Forth compilers is too broad a topic for this article. This is an active area of Forth language research; see, for instance, [SCO89] and [CUR93b] . The final culmination of optimized STC is a Forth which compiles to \"pure\" machine code, just like a C or Fortran compiler.","title":"STC with in-line expansion; optimization; direct compilation"},{"location":"moving1.html#token-threaded-code-ttc","text":"DTC and STC aim to improve the speed of Forth programs, at some cost in memory. Now let's move the other direction from ITC, toward something slower but smaller. The purpose of a Forth thread is to specify a list of Forth words (subroutines) to be performed. Suppose a 16-bit Forth system only had a maximum of 256 different words. Then each word could be uniquely identified by an 8-bit number. Instead of a list of 16-bit addresses, you would have a list of 8-bit identifiers or \"tokens,\" and the size of the colon definitions would be halved! A token-threaded Forth keeps a table of addresses of all Forth words, as shown in Figure 4 . The token value is then used to index into this table, to find the Forth word corresponding to a given token. This adds one level of indirection to the Forth interpreter, so it is slower than an \"address-threaded\" Forth. Figure 4. Token Threaded Code The principal advantage of token-threaded Forths is small size. TTC is most commonly seen in handheld computers and other severely size-constrained applications. Also, the table of \"entry points\" into all the Forth words can simplify linkage of separately-compiled modules. The disadvantage of TTC is speed: TTC makes the slowest Forths. Also, the TTC compiler is slightly more complex. If you need more than 256 Forth words, it's necessary to have some open-ended encoding scheme to mix 8-bit and larger tokens. I can envision a 32-bit Forth using 16-bit tokens, but how many 32-bit systems are size-constrained?","title":"Token Threaded Code (TTC)"},{"location":"moving1.html#segment-threaded-code","text":"Since there are so many 8086 derivatives in the world, segment threading deserves a brief mention. Instead of using \"normal\" byte addresses within a 64K segment, paragraph addresses are used. (A \"paragraph\" is 16 bytes in the 8086.) Then, the interpreter can load these addresses into segment registers, instead of into the usual address registers. This allows a 16- bit Forth model to efficiently access the full megabyte of 8086 memory. The principal disadvantage of segment threading is the 16-byte \"granularity\" of the memory space. Every Forth word must be aligned to a 16-byte boundary. If Forth words have random lengths, an average of 8 bytes will be wasted per Forth word.","title":"Segment Threaded Code"},{"location":"moving1.html#register-allocation","text":"Next to the threading technique, the usage of the CPU's registers is the most crucial design decision. It's probably the most difficult. The availability of CPU registers can determine what threading technique can be used, and even what the memory map will be!","title":"REGISTER ALLOCATION"},{"location":"moving1.html#the-classical-forth-registers","text":"The classical Forth model has five \"virtual registers.\" These are abstract entities which are used in the primitive operations of Forth. NEXT, ENTER, and EXIT were defined earlier in terms of these abstract registers. Each of these is one cell wide -- i.e., in a 16-bit Forth, these are 16-bit registers. (There are exceptions to this rule, as you will see later.) These may not all be CPU registers. If your CPU doesn't have enough registers, some of these can be kept in memory. I'll describe them in the order of their importance; i.e., the bottom of this list are the best candidates to be stored in memory. W is the Working register. It is used for many things, including memory reference, so it should be an address register; i.e., you must be able to fetch and store memory using the contents of W as the address. You also need to be able to do arithmetic on W. (In DTC Forths, you must also be able to jump indirect using W.) W is used by the interpreter in every Forth word . In a CPU having only one register, you would use it for W and keep everything else in memory (and the system would be incredibly slow). IP is the Interpreter Pointer. This is used by every Forth word (through NEXT, ENTER, or EXIT). IP must be an address register. You also need to be able to increment IP. Subroutine threaded Forths don't need this register. PSP is the Parameter Stack (or \"data stack\") Pointer, sometimes called simply SP. I prefer PSP because SP is frequently the name of a CPU register, and they shouldn't be confused. Most CODE words use this. PSP must be a stack pointer, or an address register which can be incremented and decremented. It's also a plus if you can do indexed addressing from PSP. RSP is the Return Stack Pointer, sometimes called simply RP. This is used by colon definitions in ITC and DTC Forths, and by all words in STC Forths. RSP must be a stack pointer, or an address register which can be incremented and decremented. If at all possible , put W, IP, PSP, and RSP in registers. The virtual registers that follow can be kept in memory, but there is usually a speed advantage to keeping them in CPU registers. X is a working register, not considered one of the \"classical\" Forth registers, even though the classical ITC Forths need it for the second indirection. In ITC you must be able to jump indirect using X. X may also be used by a few CODE words to do arithmetic and such. This is particularly important on processors that cannot use memory as an operand. For example, ADD on a Z80 might be (in pseudo-code) POP W POP X X+W -> W PUSH W Sometimes another working register, Y, is also defined. UP is the User Pointer, holding the base address of the task's user area. UP is usually added to an offset, and used by high-level Forth code, so it can be just stored somewhere. But if the CPU can do indexed addressing from the UP register, CODE words can more easily and quickly access user variables. If you have a surplus of address registers, use one for UP. Single-task Forths don't need UP. X -- if needed -- is more important to keep in register than UP. UP is the easiest of the Forth virtual registers to move into memory.","title":"The Classical Forth Registers"},{"location":"moving1.html#use-of-the-hardware-stack","text":"Most CPUs have a stack pointer as part of their hardware, used by interrupts and subroutine calls. How does this map into the Forth registers? Should it be the PSP or the RSP? The short answer is, it depends . It is said that the PSP is used more than the RSP in ITC and DTC Forths. If your CPU has few address registers, and PUSH and POP are faster than explicit reference, use the hardware stack as the Parameter Stack. On the other hand, if your CPU is rich in addressing modes -- and allows indexed addressing -- there's a plus in having the PSP as a general-purpose address register. In this case, use the hardware stack as the Return Stack. Sometimes you do neither! The TMS320C25 's hardware stack is only eight cells deep -- all but useless for Forth. So its hardware stack is used only for interrupts, and both PSP and RSP are general-purpose address registers. (ANS Forth specifies a minimum of 32 cells of Parameter Stack and 24 cells of Return Stack; I prefer 64 cells of each.) You will occasionally encounter the dogma that the hardware stack \"must be\" the Parameter Stack, or \"must be\" the Return Stack. Instead, code some sample Forth primitives, such as SWAP OVER @ ! + 0= and see which approach is smaller or faster. (DUP and DROP, by the way, are no test -- they're usually trivial.) Occasionally you reach strange conclusions! Gary Bergstrom has pointed out that a 6809 DTC Forth can be made a few cycles faster by using the 6809 user stack pointer as the IP ; NEXT becomes a POP. He uses an index register for one of Forth's stacks.","title":"Use of the Hardware Stack"},{"location":"moving1.html#top-of-stack-in-register","text":"Forth's performance can be improved considerably by keeping the top element of the Parameter Stack in a register! Many Forth words (such as 0=) then don't need to use the stack. Other words still do the same number of pushes and pops, only in a different place in the code. Only a few Forth words (DROP and 2DROP) become more complicated, since you can no longer simply adjust the stack pointer -- you have to update the TOS register as well. There are a few rules when writing CODE words: A word which removes items from the stack must pop the \"new\" TOS into its register. A word which adds items to the stack must push the \"old\" TOS onto the stack (unless, of course, it's consumed by the word). If you have at least six cell-size CPU registers, I recommend keeping the TOS in a register. I consider TOS more important than UP to have in register, but less important than W, IP, PSP, and RSP. (TOS in register performs many of the functions of the X register.) It's useful if this register can perform memory addressing. PDP-11 s, Z8 s, and 68000s are good candidates. Nine of the 19 IBM PC Forths studied by Guy Kelly [KEL92] keep TOS in register. I think this innovation has been resisted because of the false beliefs that a) it adds instructions, and b) the top stack element must be accessible as memory. It turns out that even such words as PICK, ROLL, and DEPTH are trivially modified for TOS-in-register. What about buffering two stack elements in registers? When you keep the top of stack in a register, the total number of operations performed remains essentially the same. A push remains a push, regardless of whether it is before or after the operation you're performing. On the other hand, buffering two stack elements in registers adds a large number of instructions -- a push becomes a push followed by a move. Only dedicated Forth processors like the RTX2000 and fantastically clever optimizing compilers can benefit from buffering two stack elements in registers.","title":"Top-Of-Stack in Register"},{"location":"moving1.html#some-examples","text":"Here are the register assignments made by Forths for a number of different CPUs. Try to deduce the design decisions of the authors from this list. Register Assignments W IP PSP RSP UP TOS 8086 [1] BX SI SP BP memory memory [LAX84] 8086 [2] AX SI SP BP none BX [SER90] 68000 A5 A4 A3 A7=SP A6 memory [CUR86] PDP-11 R2 R4 R5 R6=SP R3 memory [JAM80] 6809 X Y U S memory memory [TAL80] 6502 Zpage Zpage X SP Zpage memory [KUN81] Z80 DE BC SP IX none memory [LOE81] Z8 RR6 RR12 RR14 SP RR10 RR8 [MPE92] 8051 R0,1 R2,3 R4,5 R6,7 fixed memory [PAY90] [1] F83. [2] Pygmy Forth. \"SP\" refers to the hardware stack pointer. \"Zpage\" refers to values kept in the 6502's memory page zero, which are almost as useful as -- sometimes more useful than -- values kept in registers; e.g., they can be used for memory addressing. \"Fixed\" means that Payne's 8051 Forth has a single, immovable user area, and UP is a hard-coded constant.","title":"Some examples"},{"location":"moving1.html#narrow-registers","text":"Notice anything odd in the previous list? The 6502 Forth -- a 16-bit model -- uses 8-bit stack pointers! It is possible to make PSP, RSP, and UP smaller than the cell size of the Forth. This is because the stacks and user area are both relatively small areas of memory. Each stack may be as small as 64 cells in length, and the user area rarely exceeds 128 cells. You simply need to ensure that either a) these data areas are confined to a small area of memory, so a short address can be used, or b) the high address bits are provided in some other way, e.g., a memory page select. In the 6502, the hardware stack is confined to page one of RAM (addresses 01xxh) by the design of the CPU. The 8-bit stack pointer can be used for the Return Stack. The Parameter Stack is kept in page zero of RAM, which can be indirectly accessed by the 8-bit index register X. (Question for the advanced student: why use the 6502's X, and not Y? Hint: look at the addressing modes available.) In the 8051, you can use the 8-bit registers R0 and R1 to address external RAM, provided that you explicitly output the high 8 bits of address to port 2. This allows a \"page select\" for two stacks. UP is different from PSP and RSP: it simply provides a base address; it is never incremented or decremented. So it's practical to supply only the high bits of this virtual register. The low bits must then be provided by whatever indexed addressing technique is used. For example, on the 6809, you can use the DP register to hold the high 8 bits of UP, and then use Direct Page addressing to access any of the 256 locations in this page. This forces all user areas to begin on an address xx00h, which is no great hardship, and limits the user area to 128 cells in length. On the 8086 you could conceivably use a segment register to specify the base address of the user area.","title":"Narrow Registers"},{"location":"moving1.html#references","text":"[CUR93a] Curley, Charles , \"Life in the FastForth Lane\", awaiting publication in Forth Dimensions. Description of a 68000 subroutine-threaded Forth. [1] [2] [3] [4] [5] [CUR93b] Curley, Charles, \"Optimizing in a BSR/JSR Threaded Forth\", awaiting publication in Forth Dimensions. Single-pass code optimization for FastForth, in only five screens of code! Includes listing. [1] [2] [3] [4] [KEL92] Kelly, Guy M., \"Forth Systems Comparisons\", Forth Dimensions XIII:6 (Mar/Apr 1992). Also published in the 1991 FORML Conference Proceedings . Both available from the Forth Interest Group, P.O. Box 2154, Oakland, CA 94621. Illustrates design trade offs of many 8086 Forths with code fragments and benchmarks -- highly recommended! [1] [2] [3] [KOG82] Kogge, Peter M., \"An Architectural Trail to Threaded-Code Systems\", IEEE Computer, vol. 15 no. 3 (Mar 1982). Remains the definitive description of various threading techniques. [1] [2] [ROD91] Rodriguez, B.J. , \"B.Y.O. Assembler\", Part 1, The Computer Journal #52 (Sep/Oct 1991). General principles of writing Forth assemblers. [1] [2] [ROD92] Rodriguez, B.J., \"B.Y.O. Assembler\", Part 2, The Computer Journal #54 (Jan/Feb 1992). A 6809 assembler in Forth. [1] [2] [SCO89] Scott, Andrew: \"An Extensible Optimizer for Compiling Forth\", 1989 FORML Conference Proceedings , Forth Interest Group, P.O. Box 2154, Oakland, CA 94621. Good description of a 68000 optimizer; no code provided. \"Extensible Optimizing Compiler\", Forth Dimensions XII:2 (Jul/Aug 1990). [1] [2]","title":"REFERENCES"},{"location":"moving1.html#forth-implementations","text":"[CUR86] Curley, Charles, real-Forth for the 68000 , privately distributed (1986) . [1] [JAM80] James, John S., fig-Forth for the PDP-11 , Forth Interest Group (1980). [1] [2] [KUN81] Kuntze, Robert E., MVP-Forth for the Apple II , Mountain View Press (1981). [1] [2] [LAX84] Laxen, H. and Perry, M., F83 for the IBM PC , version 2.1.0 (1984). Distributed by the authors, available from the Forth Interest Group or GEnie. [1] [2] [LOE81] Loeliger, R. G., Threaded Interpretive Languages , BYTE Publications (1981), ISBN 0-07-038360-X. May be the only book ever written on the subject of creating a Forth-like kernel (the example used is the Z80). Worth it if you can find a copy. [1] [2] [MPE92] MicroProcessor Engineering Ltd., MPE Z8/Super8 PowerForth Target , MPE Ltd., 133 Hill Lane, Shirley, Southampton, S01 5AF, U.K. (June 1992). A commercial product. [1] [PAY90] Payne, William H., Embedded Controller FORTH for the 8051 Family , Academic Press (1990), ISBN 0-12-547570-5. This is a complete \"kit\" for a 8051 Forth, including a metacompiler for the IBM PC. Hardcopy only; files can be downloaded from GEnie . Not for the novice! [1] [2] [SER90] Sergeant, Frank, Pygmy Forth for the IBM PC , version 1.3 (1990). Distributed by the author, available from the Forth Interest Group. Version 1.4 is now available on GEnie, and worth the extra effort to obtain. [1] [TAL80] Talbot, R. J., fig-Forth for the 6809 , Forth Interest Group (1980). [1] Author's note for web publication: the files formerly available on the GEnie online service are now available from the Forth Interest Group FTP server, ftp://ftp.forth.org/pub/Forth http://www.forth.org/","title":"Forth Implementations"},{"location":"moving2.html","text":"MOVING FORTH 2 Part 2: Benchmarks and Case Studies of Forth Kernels by Brad Rodriguez This article first appeared in The Computer Journal #60 (March/April 1993) . BENCHMARKS By now it must seem that the answer to every design question is \"code it and see.\" Obviously you don't want to write the entire Forth kernel several different ways just to evaluate different schemes. Fortunately, you can get quite a good \"feel\" with just a small subset of the Forth kernel. Guy Kelly [KEL92] examines the following code samples for 19 different IBM PC Forths: NEXT ...the \"inner interpreter\" that chains from one Forth word to another in the \"thread\". This is used at the end of every CODE definition, and is one of the most important factors in speed of Forth execution. You've already seen the pseudo-code for this in ITC and DTC; in STC it's just CALL/RETURN. ENTER ...also called DOCOL or DOCOLON; the Code Field action that causes a high level \"colon\" definition to be executed. This, too, is crucial for speed; it is used at the start of every colon definition. Not needed in STC. EXIT ...called ;S in fig-Forth; the code that ends the execution of a colon definition. This is essentially the high-level subroutine return, and appears at the end of every colon definition. This is just a machine code RETURN in STC. NEXT, ENTER, and EXIT indicate the performance of the threading mechanism. These should be coded to evaluate ITC vs. DTC vs. STC. They also reflect the quality of your register assignments for IP, W, and RSP. DOVAR ...a.k.a. \"variable\"; the machine code fragment that is the Code Field action for all Forth VARIABLEs. DOCON ...a.k.a. \"constant\"; the machine code fragment that is the Code Field action for all Forth CONSTANTs. DOCON and DOVAR, along with ENTER, show how efficiently you can obtain the Parameter Field address of a word being executed. This reflects your choice for the W register. In a DTC Forth, this also indicates whether to put a JUMP or CALL in the Code Field. LIT ...a.k.a. \"literal\"; is a Forth word that fetches a cell value from the high-level thread. Several words use such in-line parameters, and this is a good indicator of their performance. It reflects your choice for the IP register. @ ...the Forth memory-fetch operator, shows how quickly memory can be accessed from high-level Forth. This word usually benefits from TOS in stack. ! ...the Forth memory-store operator, is another indicator of memory access. This consumes two items from the stack, and illustrates efficiency of Parameter Stack access. It's a good indicator of the TOS-in-memory vs. TOS-in-register tradeoff. + ...the addition operator, is a representative example of all the Forth arithmetic and logical operators. Like the ! word, this benchmarks stack access, and it's a clear demonstration of any TOS-in-register benefit. This is an excellent set of code samples. I have a few additional favorites: DODOES ...is the Code Field action for words built with DOES>. This doesn't yield any new benchmark comparisons, although it does reflect the usefulness of W, IP, and RSP. I include it because it's the most convoluted code in the Forth kernel. If you can code the logic of DODOES, everything else is a snap. The intricacies of DODOES will be described in a subsequent article. SWAP ...a simple stack operator, but still educational. OVER ...a more complex stack operator. This gives a good idea of how easily you can access the Parameter Stack. ROT ...a still more complex stack operator, and the one most likely to need an extra temporary register. If you can code ROT without needing an \"X\" register, you probably don't need an \"X\" register for anything. 0= ...one of the few unary arithmetic operators, and one of the most likely to benefit from TOS-in-register. +! ...a most illustrative operator, combining stack access, arithmetic, memory fetch and store. This is one of my favorite benchmarks, although it is less frequently used than the other words in this list. These are among the most-used words in the Forth kernel. It pays to optimize them. I'll show examples of all of these, including pseudo-code, for the 6809. For the other CPUs, I'll use selected examples to illustrate specific decisions. CASE STUDY 1: THE 6809 In the world of 8-bit CPUs, the 6809 is the Forth programmer's dream machine. It supports two stacks! It also has two other address registers, and a wealth of orthogonal addressing modes second only to the PDP-11. (\"Orthogonal\" means they work the same way and have the same options for all address registers.) The two 8-bit accumulators can be treated as a single 16-bit accumulator, and there are many 16-bit operations. The programmer's model of the 6809 is [MOT83]: A - 8 bit accumulator B - 8 bit accumulator Most arithmetic operations use an accumulator as the destination. These can be concatenated and treated as a single 16-bit accumulator D (A high byte, B low). X - 16 bit index register Y - 16 bit index register S - 16 bit stack pointer U - 16 bit stack pointer All addressing modes for X and Y can also be used with the S and U registers. PC - 16 bit program counter CC - 8 bit Condition Code register DP - 8 bit Direct Page register The 6800 family's Direct addressing mode uses an 8-bit address to reach any location in memory page zero. The 6809 allows any page to be Direct-addressed; this register provides the high 8 bits of address. Those two stack pointers are crying out for Forth use. They are equivalent, except that S is used for subroutine calls and interrupts. Let's be consistent and use S for return addresses, leaving U for the Parameter Stack. W and IP both need to be address registers, so these are the logical use for X and Y. X and Y are equivalent, so let's arbitrarily assign X=W, and Y=IP. Now a threading model can be chosen. I'll scratch STC and TTC, to make this a \"conventional\" Forth. The limiting factor in performance is then the NEXT routine. Let's look at this in both ITC and DTC: ITC-NEXT: LDX ,Y++ (8) (IP)->W, increment IP JMP [,X] (6) (W)->temp, jump to adrs in temp DTC-NEXT: JMP [,Y++] (9) (IP)->temp, increment IP, jump to adrs in temp (\"temp\" is internal to the 6809) NEXT is one instruction in a DTC 6809! This means you can code it in-line in two bytes, making it both smaller and faster than JMP NEXT. For comparison, look at the \"NEXT\" logic for subroutine threading: RTS (5) ...at the end of one CODE word JSR nextword (8) ...in the \"thread\" ... ...start of the next CODE word STC takes 13 clocks to thread to the next word, compared with 9 clocks for DTC. This is because subroutine threading has to pop and push a return address, while simple DTC or ITC threading between CODE words does not. Given the choice of DTC, you have to decide: does a high-level word have a Jump or Call in its Code Field? The driving consideration is how quickly can you obtain the address of the parameter field which follows? Let's look at the code to ENTER a colon definition, using symbolic Forth register names, to see this illustrated: using a JSR (Call): JSR ENTER (8) ... ENTER: PULS W (7) get address following JSR into W reg PSHS IP (7) save the old IP on the Return Stack TFR W,IP (6) Parameter Field address -> IP NEXT (9) assembler macro for JMP [,Y++] 37 cycles total using a JMP: JMP ENTER (4) ... ENTER: PSHS IP (7) save the old IP on the Return Stack LDX -2,IP (6) re-fetch the Code Field address LEAY 3,X (5) add 3 and put into IP (Y) register NEXT (9) 31 cycles total (CPU cycle counts are in parentheses.) The DTC 6809 NEXT doesn't use the W register, because the 6809 addressing modes allow an extra level of indirection automatically. The JMP version of ENTER has to re-fetch the Code Field address -- NEXT didn't leave it in any register -- and then add 3 to get the Parameter Field address. The JSR version can get the Parameter Field address directly by popping the return stack. Even so, the JMP version is faster. (Exercise for the student: try coding the JSR ENTER with S=PSP and U=RSP.) Either way, the code for EXIT is the same: EXIT: PULS IP pop \"saved\" IP from return stack NEXT continue Forth interpretation Some registers remain to allocate. You could keep the User Pointer in memory, and this Forth would still be pretty fast. But the DP register would go to waste, and there's not much else it can do. Let's use the \"trick\" described above, and hold the high byte of UP in the DP register. (The low byte of UP is implied to be zero.) One 16-bit register is left: D. Most arithmetic operations need this register. Should it be left free as a scratch register, or used as the Top-Of-Stack? 6809 instructions use memory as one operand, so a second working register may be unnecessary. And if a scratch register is needed, it's easy to push and pop D. Let's write the benchmark primitives both ways, and see which is faster. NEXT, ENTER, and EXIT don't use the stack, and thus have identical code either way. DOVAR, DOCON, LIT, and OVER require the same number of CPU cycles either way. These illustrate the earlier comment that putting TOS in register often just changes where the push or pop takes place: TOS in D TOS in memory pseudo-code ------------- ------------- --------------------- DOVAR: PSHU TOS LDD -2,IP address of CF -> D LDD -2,IP ADDD #3 address of PF -> D ADDD #3 PSHU D push D onto stack NEXT NEXT DOCON: PSHU TOS LDX -2,IP address of CF -> W LDX -2,IP LDD 3,X contents of PF -> D LDD 3,X PSHU D push D onto stack NEXT NEXT LIT: PSHU TOS LDD ,IP++ (IP) -> D, increment IP LDD ,IP++ PSHU D push D onto stack NEXT NEXT OVER: PSHU D LDD 2,PSP 2nd on stack -> D LDD 2,PSP PSHU D push D onto stack NEXT NEXT SWAP, ROT, 0=, @, and especially + are all faster with TOS in register: TOS in D TOS in memory pseudo-code ------------ ------------- ---------------- SWAP: LDX ,PSP (5) LDD ,PSP (5) TOS -> D STD ,PSP (5) LDX 2,PSP (6) 2nd on stack -> X TFR X,D (6) STD 2,PSP (6) D -> 2nd on stack NEXT STX ,PSP (5) X -> TOS NEXT ROT: LDX ,PSP (5) LDX ,PSP (5) TOS -> X STD ,PSP (5) LDD 2,PSP (6) 2nd on stack -> D LDD 2,PSP (6) STX 2,PSP (6) X -> 2nd on stack STX 2,PSP (6) LDX 4,PSP (6) 3rd on stack -> X NEXT STD 4,PSP (6) D -> 3rd on stack STX ,PSP (5) X -> TOS NEXT 0=: CMPD #0 LDD ,PSP TOS -> D BEQ TRUE CMPD #0 does D equal zero? BEQ TRUE FALSE:LDD #0 LDD #0 no...put 0 in TOS NEXT STD ,PSP NEXT TRUE: LDD #-1 LDD #-1 yes...put -1 in TOS NEXT STD ,PSP NEXT @: TFR TOS,W (6) LDD [,PSP] (8) fetch D using TOS adrs LDD ,W (5) STD ,PSP (5) D -> TOS NEXT NEXT +: ADDD ,U++ PULU D pop TOS into D NEXT ADDD ,PSP add new TOS into D STD ,PSP store D into TOS NEXT ! and +! are slower with TOS in register: TOS in D TOS in memory pseudo-code ------------ ------------ ----------------- !: TFR TOS,W (6) PULU W (7) pop adrs into W PULU D (7) PULU D (7) pop data into D STD ,W (5) STD ,W (5) store data to adrs PULU TOS (7) NEXT NEXT +!: TFR TOS,W (6) PULU W (7) pop adrs into W PULU TOS (7) PULU D (7) pop data into D ADDD ,W (6) ADDD ,W (6) add memory into D STD ,W (5) STD ,W (5) store D to memory PULU TOS (7) NEXT NEXT The reason these words are slower is that most Forth memory-reference words expect the address on the top of stack, so an extra TFR instruction is needed. This is why it's a help for the TOS register to be an address register. Unfortunately, all the 6809 address registers are spoken for...and it's much more important for W, IP, PSP, and RSP to be in address registers than TOS. The TOS-in-register penalty for ! and +! should be outweighed by the gains in the many arithmetic and stack operations. CASE STUDY 2: THE 8051 If the 6809 is the Forthwright's dream machine, the 8051 is the nightmare. It has only one general-purpose address register, and one addressing mode, which always uses the one 8-bit accumulator. All of the arithmetic operations, and many of the logical, must use the accumulator. The only 16-bit operation is INC DPTR. The hardware stack must use the 128-byte on-chip register file. [SIG92] Such a CPU could give ulcers. Some 8051 Forths have been written that implement a full 16-bit model, e.g. [PAY90], but they are too slow for my taste. Let's make some tradeoffs and make a faster 8051 Forth. Our foremost reality is the availability of only one address register. So let's use the 8051's Program Counter as IP -- i.e., let's make a subroutine-threaded Forth. If the compiler uses 2-byte ACALLs instead of 3-byte LCALLs whenever possible, most of the STC code will be as small as ITC or DTC code. Subroutine threading implies that the Return Stack Pointer is the hardware stack pointer. There are 64 cells of space in the on-chip register file, not enough room for multiple task stacks. At this point you can a) restrict this Forth to single-task; b) code all of the Forth definitions so that upon entry they move their return address to a software stack in external RAM; or c) do task switches by swapping the entire Return Stack to and from external RAM. Option (b) is slow! Moving 128 bytes on every task switch is faster than moving 2 bytes on every Forth word. For now I choose option (a), leaving the door open for (c) at some future date. The one-and-only \"real\" address register, DPTR, will have to do multiple duty. It becomes W, the multi-purpose working register. In truth, there are two other registers that can address external memory: R0 and R1. They provide only an 8-bit address; the high 8 bits are explicitly output on port 2. But this is a tolerable restriction for stacks, since they can be limited to a 256-byte space. So let's use R0 as the PSP. This same 256-byte space can be used for user data. This makes P2 (port 2) the high byte of the User Pointer, and, like the 6809, the low byte will be implied to be zero. What is the programmer's model of the 8051 so far? reg 8051 Forth adrs name usage ---- ------ ----------------- 0 R0 low byte of PSP 1 R1 2 R2 3 R3 4 R4 5 R5 6 R6 7 R7 8-7Fh 120 bytes of return stack 81h SP low byte of RSP (high byte=00) 82-83h DPTR W register A0h P2 high byte of UP and PSP E0h A F0h B Note that this uses only register bank 0. The additional three register banks from 08h to 1Fh, and the bit-addressable region from 20h to 2Fh, are of no use to Forth. Using bank 0 leaves the largest contiguous space for the return stack. Later the return stack can be shrunk, if desired. The NEXT, ENTER, and EXIT routines aren't needed in a subroutine threaded Forth. What about the top of stack? There are plenty of registers, and memory operations on the 8051 are expensive. Let's put TOS in R3:R2 (with R3 as the high byte, in Intel fashion). Note that B:A can't be used -- the A register is the funnel through which all memory references must move! Harvard architectures The 8051 uses a \"Harvard\" architecture: program and data are kept in separate memories. (The Z8 and TMS320 are two other examples) The 8051 is a degenerate case: there is physically no means to write to the program memory! This means that a Forthwright can do one of two things: a) cross-compile everything, including the application, and give up all hope of putting an interactive Forth compiler on the 8051; or b) cause some or all of the program memory to also appear in the data space. The easiest way is to make the two spaces completely overlap, by logically ORing the active-low PSEN* and RD* strobes with an external AND gate. The Z8 and TMS320C25 are more civilized: they allow write access to program memory. The implications for the design of the Forth kernel will be discussed in subsequent articles. CASE STUDY 3: THE Z80 The Z80 is instructive because it is an extreme example of a non-orthogonal CPU. It has four different kinds of address registers! Some operations use A as destination, some any 8-bit register, some HL, some any 16-bit register, and so on. Many operations (such as EX DE,HL) are only defined for one combination of registers. In a CPU such as the Z80 (or 8086!), the assignment of Forth functions must be carefully matched to the capabilities of the CPU registers. Many more tradeoffs need to be evaluated, and often the only way is to write sample code for a number of different assignments. Rather than burden this article down endless permutations of Forth code, I'll present one register assignment based on many Z80 code experiments. It turns out that these choices can be rationalized in terms of the general principles outlined earlier. I want a \"conventional\" Forth, although I will use direct threading. All of the \"classical\" virtual registers will be needed. Ignoring the alternate register set, the Z80 has six address registers, with the following capabilities: BC,DE - LD A indirect, INC, DEC also exchange DE/HL HL - LD r indirect, ALU indirect, INC, DEC, ADD, ADC, SBC, exchange w/TOS, JP indirect IX,IY - LD r indexed, ALU indexed, INC, DEC, ADD, ADC, SBC, exchange w/TOS, JP indirect (all slow) SP - PUSH/POP 16-bit, ADD/ADC/SUB to HL/IX/IY BC, DE, and HL can also be manipulated in 8-bit pieces. The 8-bit register A must be left as a scratch register, since it's the destination for so many ALU and memory reference operations. HL is undoubtedly the most versatile register, and at one time or another it is tempting to use it for each of the Forth virtual registers. However, because of its versatility -- and because it is the only register which can be fetched byte-wise and used in an indirect jump -- HL should be used for W, Forth's all-purpose working register. IX and IY might be considered for the Forth stack pointers, because of their indexed addressing mode, which can be used in ALU operations. But there are two problems with this: it leaves SP without a job; and, IX/IY are too slow! Most of the operations on either stack involve pushing or popping 16-bit quantities. This is one instruction using SP, but it requires four using IX or IY. One of the Forth stacks should use SP. And this should be the Parameter Stack, since it is used more heavily than the Return Stack. What about Forth's IP? Mostly, IP fetches from memory and autoincrements, so there's no programming advantage to using IX/IY over BC/DE. But speed is of the essence with IP, and BC/DE are faster. Let's put IP in DE: it has the advantage of being able to swap with HL, which adds versatility. A second Z80 register pair (other than W) will be needed for 16-bit arithmetic. Only BC is left, and it can be used for addressing or for ALU operations with A. But should BC be a second working register \"X\", or the top-of-stack? Only code will tell; for now, let's optimistically assume that BC=TOS. This leaves the RSP and UP functions, and the IX and IY registers unused. IX and IY are equivalent, so let's assign IX=RSP, and IY=UP. Thus the Z80 Forth register assignments are: BC = TOS IX = RSP DE = IP IY = UP HL = W SP = PSP Now look at NEXT for the DTC Forth: DTC-NEXT: LD A,(DE) (7) (IP)->W, increment IP LD L,A (4) INC DE (6) LD A,(DE) (7) LD H,A (4) INC DE (6) JP (HL) (4) jump to address in W alternate version (same number of clock cycles) DTC-NEXT: EX DE,HL (4) (IP)->W, increment IP NEXT-HL: LD E,(HL) (7) INC HL (6) LD D,(HL) (7) INC HL (6) EX DE,HL (4) JP (HL) (4) jump to address in W Note that cells are stored low-byte first in memory. Also, although it might seem advantageous to keep IP in HL, it really isn't. This is because the Z80 can't JP (DE). The NEXT-HL entry point will be used shortly. Just for comparison, let's look at an ITC NEXT. The pseudo-code given previously requires another temporary register \"X\", whose contents can be used for an indirect jump. Let DE=X, and BC=IP. TOS will have to be kept in memory. ITC-NEXT: LD A,(BC) (7) (IP)->W, increment IP LD L,A (4) INC BC (6) LD A,(BC) (7) LD H,A (4) INC BC (6) LD E,(HL) (7) (W)->X INC HL (6) LD D,(HL) (7) EX DE,HL (4) jump to address in X JP (HL) (4) This leaves \"W\" incremented by one, and in the DE register. As long as this is done consistently , there's no problem -- code needing the contents of W knows where to find it, and how much to adjust it. The ITC NEXT is 11 instructions, as compared to 7 for DTC. And ITC on the Z80 loses the ability to keep TOS in a register. My choice is DTC. If coded in-line, DTC NEXT would require seven bytes in every CODE word. A jump to a common NEXT routine would only use three bytes, but would add 10 clock cycles. This is another of the tradeoff decisions in designing a Forth kernel. This example is a close call; let's opt for speed with an in-line NEXT. But sometimes NEXT is so huge, or memory is so tight, that the prudent decision is to use a JMP NEXT. Now let's look at the code for ENTER. Using a CALL, the hardware stack is popped to get the Parameter Field address: CALL ENTER (17) ... ENTER: DEC IX (10) push the old IP on the return stack LD (IX+0),D (19) DEC IX (10) LD (IX+0),E (19) POP DE (10) Parameter Field address -> IP NEXT (38) assembler macro for 7 instructions Actually it's faster to POP HL, and then use the last six instructions of NEXT (omitting the EX DE,HL): CALL ENTER (17) ... ENTER: DEC IX (10) push the old IP on the return stack LD (IX+0),D (19) DEC IX (10) LD (IX+0),E (19) POP HL (10) Parameter Field address -> HL NEXT-HL (34) see DTC NEXT code, above 119 cycles total When a JP is used, the W register (HL) is left pointing to the Code Field. The Parameter Field is 3 bytes after: JP ENTER (10) ... ENTER: DEC IX (10) push the old IP on the return stack LD (IX+0),D (19) DEC IX (10) LD (IX+0),E (19) INC HL ( 6) Parameter Field address -> IP INC HL ( 6) INC HL ( 6) NEXT-HL (34) 120 cycles total Again, because of the alternate entry point for NEXT, the new value for IP doesn't actually have to be put into the DE register pair. The CALL version is one cycle faster. On an embedded Z80, a one-byte RST instruction could be used to gain speed and save space. This option is not available on many Z80-based personal computers. CASE STUDY 4: THE 8086 The 8086 is another instructive CPU. Rather than go through the design process, let's look at one of the newer shareware Forths for the IBM PC: Pygmy Forth [SER90]. Pygmy is a direct-threaded Forth with the top-of-stack kept in register. The 8086 register assignments are: AX = W DI = scratch BX = TOS SI = IP CX = scratch BP = RSP DX = scratch SP = PSP Most 8086 Forths use the SI register for IP, so that NEXT can be written with the LODSW instruction. In Pygmy the DTC NEXT is: NEXT: LODSW JMP AX This is short enough to include in-line in every CODE word. High-level and \"defined\" Forth words use a JMP (relative) to their machine code. The ENTER routine (called 'docol' in Pygmy) must therefore get the Parameter Field address from W: ENTER: XCHG SP,BP PUSH SI XCHG SP,BP ADD AX,3 Parameter Field address -> IP MOV SI,AX NEXT Note the use of XCHG to swap the two stack pointers. This allows the use of PUSH and POP instructions for both stacks, which is faster than using indirect access on BP. EXIT: XCHG SP,BP POP SI XCHG SP,BP NEXT Segment model Pygmy Forth is a single-segment Forth; all code and data are contained within a single 64 kByte segment. (This is the \"tiny model\" in Turbo C lingo) All of the Forth standards issued to date assume that everything is contained in a single memory space, accessible with the same fetch and store operators. Nevertheless, IBM PC Forths are beginning to appear that use multiple segments for up to five different kinds of data [KEL92,SEY89]. These are: CODE ...machine code LIST ...high-level Forth threads (a.k.a. THREADS) HEAD ...headers of all Forth words STACK ...parameter and return stacks DATA ...variables and user-defined data This allows PC Forths to break the 64K limit, without going to the expense of implementing a 32-bit Forth on a 16-bit CPU. Implementation of a multi-segment model, and the ramifications for the Forth kernel, are beyond the scope of this article. STILL TO COME... Subsequent articles will look at: design tradeoffs in the Forth header and dictionary search the logic of CONSTANTs, VARIABLEs, and other data structures the defining word mechanisms, CREATE...;CODE and CREATE...DOES> the assembler vs. metacompiler question the assembler and high-level code that comprises a Forth kernel multitasking modifications to the kernel REFERENCES [KEL92] Kelly, Guy M., \"Forth Systems Comparisons,\" Forth Dimensions XIII:6 (Mar/Apr 1992) [1] [2] [3] . Also published in the 1991 FORML Conference Proceedings . Both available from the Forth Interest Group, P.O. Box 2154, Oakland, CA 94621. Illustrates design tradeoffs of many 8086 Forths with code fragments and benchmarks -- highly recommended! [MOT83] Motorola Inc., 8-Bit Microprocessor and Peripheral Data , Motorola data book (1983). [1] [SIG92] Signetics Inc., 80C51-Based 8-Bit Microcontrollers , Signetics data book (1992). [1] Forth Implementations [PAY90] Payne, William H., Embedded Controller FORTH for the 8051 Family , Academic Press (1990), ISBN 0-12-547570-5. This is a complete \"kit\" for a 8051 Forth, including a metacompiler for the IBM PC. Hardcopy only; files can be downloaded from GEnie. Not for the novice! [1] [SER90] Sergeant, Frank, Pygmy Forth for the IBM PC , version 1.3 (1990). Distributed by the author, available from the Forth Interest Group. Version 1.4 is now available on GEnie, and worth the extra effort to obtain. [1] [SEY89] Seywerd, H., Elehew, W. R., and Caven, P., LOVE-83Forth for the IBM PC , version 1.20 (1989). A shareware Forth using a five-segment model. Contact Seywerd Associates, 265 Scarboro Cres., Scarborough, Ontario M1M 2J7 Canada. Author's note for web publication: the files formerly available on the GEnie online service are now available from the Forth Interest Group FTP server, ftp://ftp.forth.org/pub/Forth .","title":"MOVING FORTH 2"},{"location":"moving2.html#moving-forth-2","text":"Part 2: Benchmarks and Case Studies of Forth Kernels by Brad Rodriguez This article first appeared in The Computer Journal #60 (March/April 1993) .","title":"MOVING FORTH 2"},{"location":"moving2.html#benchmarks","text":"By now it must seem that the answer to every design question is \"code it and see.\" Obviously you don't want to write the entire Forth kernel several different ways just to evaluate different schemes. Fortunately, you can get quite a good \"feel\" with just a small subset of the Forth kernel. Guy Kelly [KEL92] examines the following code samples for 19 different IBM PC Forths: NEXT ...the \"inner interpreter\" that chains from one Forth word to another in the \"thread\". This is used at the end of every CODE definition, and is one of the most important factors in speed of Forth execution. You've already seen the pseudo-code for this in ITC and DTC; in STC it's just CALL/RETURN. ENTER ...also called DOCOL or DOCOLON; the Code Field action that causes a high level \"colon\" definition to be executed. This, too, is crucial for speed; it is used at the start of every colon definition. Not needed in STC. EXIT ...called ;S in fig-Forth; the code that ends the execution of a colon definition. This is essentially the high-level subroutine return, and appears at the end of every colon definition. This is just a machine code RETURN in STC. NEXT, ENTER, and EXIT indicate the performance of the threading mechanism. These should be coded to evaluate ITC vs. DTC vs. STC. They also reflect the quality of your register assignments for IP, W, and RSP. DOVAR ...a.k.a. \"variable\"; the machine code fragment that is the Code Field action for all Forth VARIABLEs. DOCON ...a.k.a. \"constant\"; the machine code fragment that is the Code Field action for all Forth CONSTANTs. DOCON and DOVAR, along with ENTER, show how efficiently you can obtain the Parameter Field address of a word being executed. This reflects your choice for the W register. In a DTC Forth, this also indicates whether to put a JUMP or CALL in the Code Field. LIT ...a.k.a. \"literal\"; is a Forth word that fetches a cell value from the high-level thread. Several words use such in-line parameters, and this is a good indicator of their performance. It reflects your choice for the IP register. @ ...the Forth memory-fetch operator, shows how quickly memory can be accessed from high-level Forth. This word usually benefits from TOS in stack. ! ...the Forth memory-store operator, is another indicator of memory access. This consumes two items from the stack, and illustrates efficiency of Parameter Stack access. It's a good indicator of the TOS-in-memory vs. TOS-in-register tradeoff. + ...the addition operator, is a representative example of all the Forth arithmetic and logical operators. Like the ! word, this benchmarks stack access, and it's a clear demonstration of any TOS-in-register benefit. This is an excellent set of code samples. I have a few additional favorites: DODOES ...is the Code Field action for words built with DOES>. This doesn't yield any new benchmark comparisons, although it does reflect the usefulness of W, IP, and RSP. I include it because it's the most convoluted code in the Forth kernel. If you can code the logic of DODOES, everything else is a snap. The intricacies of DODOES will be described in a subsequent article. SWAP ...a simple stack operator, but still educational. OVER ...a more complex stack operator. This gives a good idea of how easily you can access the Parameter Stack. ROT ...a still more complex stack operator, and the one most likely to need an extra temporary register. If you can code ROT without needing an \"X\" register, you probably don't need an \"X\" register for anything. 0= ...one of the few unary arithmetic operators, and one of the most likely to benefit from TOS-in-register. +! ...a most illustrative operator, combining stack access, arithmetic, memory fetch and store. This is one of my favorite benchmarks, although it is less frequently used than the other words in this list. These are among the most-used words in the Forth kernel. It pays to optimize them. I'll show examples of all of these, including pseudo-code, for the 6809. For the other CPUs, I'll use selected examples to illustrate specific decisions.","title":"BENCHMARKS"},{"location":"moving2.html#case-study-1-the-6809","text":"In the world of 8-bit CPUs, the 6809 is the Forth programmer's dream machine. It supports two stacks! It also has two other address registers, and a wealth of orthogonal addressing modes second only to the PDP-11. (\"Orthogonal\" means they work the same way and have the same options for all address registers.) The two 8-bit accumulators can be treated as a single 16-bit accumulator, and there are many 16-bit operations. The programmer's model of the 6809 is [MOT83]: A - 8 bit accumulator B - 8 bit accumulator Most arithmetic operations use an accumulator as the destination. These can be concatenated and treated as a single 16-bit accumulator D (A high byte, B low). X - 16 bit index register Y - 16 bit index register S - 16 bit stack pointer U - 16 bit stack pointer All addressing modes for X and Y can also be used with the S and U registers. PC - 16 bit program counter CC - 8 bit Condition Code register DP - 8 bit Direct Page register The 6800 family's Direct addressing mode uses an 8-bit address to reach any location in memory page zero. The 6809 allows any page to be Direct-addressed; this register provides the high 8 bits of address. Those two stack pointers are crying out for Forth use. They are equivalent, except that S is used for subroutine calls and interrupts. Let's be consistent and use S for return addresses, leaving U for the Parameter Stack. W and IP both need to be address registers, so these are the logical use for X and Y. X and Y are equivalent, so let's arbitrarily assign X=W, and Y=IP. Now a threading model can be chosen. I'll scratch STC and TTC, to make this a \"conventional\" Forth. The limiting factor in performance is then the NEXT routine. Let's look at this in both ITC and DTC: ITC-NEXT: LDX ,Y++ (8) (IP)->W, increment IP JMP [,X] (6) (W)->temp, jump to adrs in temp DTC-NEXT: JMP [,Y++] (9) (IP)->temp, increment IP, jump to adrs in temp (\"temp\" is internal to the 6809) NEXT is one instruction in a DTC 6809! This means you can code it in-line in two bytes, making it both smaller and faster than JMP NEXT. For comparison, look at the \"NEXT\" logic for subroutine threading: RTS (5) ...at the end of one CODE word JSR nextword (8) ...in the \"thread\" ... ...start of the next CODE word STC takes 13 clocks to thread to the next word, compared with 9 clocks for DTC. This is because subroutine threading has to pop and push a return address, while simple DTC or ITC threading between CODE words does not. Given the choice of DTC, you have to decide: does a high-level word have a Jump or Call in its Code Field? The driving consideration is how quickly can you obtain the address of the parameter field which follows? Let's look at the code to ENTER a colon definition, using symbolic Forth register names, to see this illustrated: using a JSR (Call): JSR ENTER (8) ... ENTER: PULS W (7) get address following JSR into W reg PSHS IP (7) save the old IP on the Return Stack TFR W,IP (6) Parameter Field address -> IP NEXT (9) assembler macro for JMP [,Y++] 37 cycles total using a JMP: JMP ENTER (4) ... ENTER: PSHS IP (7) save the old IP on the Return Stack LDX -2,IP (6) re-fetch the Code Field address LEAY 3,X (5) add 3 and put into IP (Y) register NEXT (9) 31 cycles total (CPU cycle counts are in parentheses.) The DTC 6809 NEXT doesn't use the W register, because the 6809 addressing modes allow an extra level of indirection automatically. The JMP version of ENTER has to re-fetch the Code Field address -- NEXT didn't leave it in any register -- and then add 3 to get the Parameter Field address. The JSR version can get the Parameter Field address directly by popping the return stack. Even so, the JMP version is faster. (Exercise for the student: try coding the JSR ENTER with S=PSP and U=RSP.) Either way, the code for EXIT is the same: EXIT: PULS IP pop \"saved\" IP from return stack NEXT continue Forth interpretation Some registers remain to allocate. You could keep the User Pointer in memory, and this Forth would still be pretty fast. But the DP register would go to waste, and there's not much else it can do. Let's use the \"trick\" described above, and hold the high byte of UP in the DP register. (The low byte of UP is implied to be zero.) One 16-bit register is left: D. Most arithmetic operations need this register. Should it be left free as a scratch register, or used as the Top-Of-Stack? 6809 instructions use memory as one operand, so a second working register may be unnecessary. And if a scratch register is needed, it's easy to push and pop D. Let's write the benchmark primitives both ways, and see which is faster. NEXT, ENTER, and EXIT don't use the stack, and thus have identical code either way. DOVAR, DOCON, LIT, and OVER require the same number of CPU cycles either way. These illustrate the earlier comment that putting TOS in register often just changes where the push or pop takes place: TOS in D TOS in memory pseudo-code ------------- ------------- --------------------- DOVAR: PSHU TOS LDD -2,IP address of CF -> D LDD -2,IP ADDD #3 address of PF -> D ADDD #3 PSHU D push D onto stack NEXT NEXT DOCON: PSHU TOS LDX -2,IP address of CF -> W LDX -2,IP LDD 3,X contents of PF -> D LDD 3,X PSHU D push D onto stack NEXT NEXT LIT: PSHU TOS LDD ,IP++ (IP) -> D, increment IP LDD ,IP++ PSHU D push D onto stack NEXT NEXT OVER: PSHU D LDD 2,PSP 2nd on stack -> D LDD 2,PSP PSHU D push D onto stack NEXT NEXT SWAP, ROT, 0=, @, and especially + are all faster with TOS in register: TOS in D TOS in memory pseudo-code ------------ ------------- ---------------- SWAP: LDX ,PSP (5) LDD ,PSP (5) TOS -> D STD ,PSP (5) LDX 2,PSP (6) 2nd on stack -> X TFR X,D (6) STD 2,PSP (6) D -> 2nd on stack NEXT STX ,PSP (5) X -> TOS NEXT ROT: LDX ,PSP (5) LDX ,PSP (5) TOS -> X STD ,PSP (5) LDD 2,PSP (6) 2nd on stack -> D LDD 2,PSP (6) STX 2,PSP (6) X -> 2nd on stack STX 2,PSP (6) LDX 4,PSP (6) 3rd on stack -> X NEXT STD 4,PSP (6) D -> 3rd on stack STX ,PSP (5) X -> TOS NEXT 0=: CMPD #0 LDD ,PSP TOS -> D BEQ TRUE CMPD #0 does D equal zero? BEQ TRUE FALSE:LDD #0 LDD #0 no...put 0 in TOS NEXT STD ,PSP NEXT TRUE: LDD #-1 LDD #-1 yes...put -1 in TOS NEXT STD ,PSP NEXT @: TFR TOS,W (6) LDD [,PSP] (8) fetch D using TOS adrs LDD ,W (5) STD ,PSP (5) D -> TOS NEXT NEXT +: ADDD ,U++ PULU D pop TOS into D NEXT ADDD ,PSP add new TOS into D STD ,PSP store D into TOS NEXT ! and +! are slower with TOS in register: TOS in D TOS in memory pseudo-code ------------ ------------ ----------------- !: TFR TOS,W (6) PULU W (7) pop adrs into W PULU D (7) PULU D (7) pop data into D STD ,W (5) STD ,W (5) store data to adrs PULU TOS (7) NEXT NEXT +!: TFR TOS,W (6) PULU W (7) pop adrs into W PULU TOS (7) PULU D (7) pop data into D ADDD ,W (6) ADDD ,W (6) add memory into D STD ,W (5) STD ,W (5) store D to memory PULU TOS (7) NEXT NEXT The reason these words are slower is that most Forth memory-reference words expect the address on the top of stack, so an extra TFR instruction is needed. This is why it's a help for the TOS register to be an address register. Unfortunately, all the 6809 address registers are spoken for...and it's much more important for W, IP, PSP, and RSP to be in address registers than TOS. The TOS-in-register penalty for ! and +! should be outweighed by the gains in the many arithmetic and stack operations.","title":"CASE STUDY 1: THE 6809"},{"location":"moving2.html#case-study-2-the-8051","text":"If the 6809 is the Forthwright's dream machine, the 8051 is the nightmare. It has only one general-purpose address register, and one addressing mode, which always uses the one 8-bit accumulator. All of the arithmetic operations, and many of the logical, must use the accumulator. The only 16-bit operation is INC DPTR. The hardware stack must use the 128-byte on-chip register file. [SIG92] Such a CPU could give ulcers. Some 8051 Forths have been written that implement a full 16-bit model, e.g. [PAY90], but they are too slow for my taste. Let's make some tradeoffs and make a faster 8051 Forth. Our foremost reality is the availability of only one address register. So let's use the 8051's Program Counter as IP -- i.e., let's make a subroutine-threaded Forth. If the compiler uses 2-byte ACALLs instead of 3-byte LCALLs whenever possible, most of the STC code will be as small as ITC or DTC code. Subroutine threading implies that the Return Stack Pointer is the hardware stack pointer. There are 64 cells of space in the on-chip register file, not enough room for multiple task stacks. At this point you can a) restrict this Forth to single-task; b) code all of the Forth definitions so that upon entry they move their return address to a software stack in external RAM; or c) do task switches by swapping the entire Return Stack to and from external RAM. Option (b) is slow! Moving 128 bytes on every task switch is faster than moving 2 bytes on every Forth word. For now I choose option (a), leaving the door open for (c) at some future date. The one-and-only \"real\" address register, DPTR, will have to do multiple duty. It becomes W, the multi-purpose working register. In truth, there are two other registers that can address external memory: R0 and R1. They provide only an 8-bit address; the high 8 bits are explicitly output on port 2. But this is a tolerable restriction for stacks, since they can be limited to a 256-byte space. So let's use R0 as the PSP. This same 256-byte space can be used for user data. This makes P2 (port 2) the high byte of the User Pointer, and, like the 6809, the low byte will be implied to be zero. What is the programmer's model of the 8051 so far? reg 8051 Forth adrs name usage ---- ------ ----------------- 0 R0 low byte of PSP 1 R1 2 R2 3 R3 4 R4 5 R5 6 R6 7 R7 8-7Fh 120 bytes of return stack 81h SP low byte of RSP (high byte=00) 82-83h DPTR W register A0h P2 high byte of UP and PSP E0h A F0h B Note that this uses only register bank 0. The additional three register banks from 08h to 1Fh, and the bit-addressable region from 20h to 2Fh, are of no use to Forth. Using bank 0 leaves the largest contiguous space for the return stack. Later the return stack can be shrunk, if desired. The NEXT, ENTER, and EXIT routines aren't needed in a subroutine threaded Forth. What about the top of stack? There are plenty of registers, and memory operations on the 8051 are expensive. Let's put TOS in R3:R2 (with R3 as the high byte, in Intel fashion). Note that B:A can't be used -- the A register is the funnel through which all memory references must move!","title":"CASE STUDY 2: THE 8051"},{"location":"moving2.html#harvard-architectures","text":"The 8051 uses a \"Harvard\" architecture: program and data are kept in separate memories. (The Z8 and TMS320 are two other examples) The 8051 is a degenerate case: there is physically no means to write to the program memory! This means that a Forthwright can do one of two things: a) cross-compile everything, including the application, and give up all hope of putting an interactive Forth compiler on the 8051; or b) cause some or all of the program memory to also appear in the data space. The easiest way is to make the two spaces completely overlap, by logically ORing the active-low PSEN* and RD* strobes with an external AND gate. The Z8 and TMS320C25 are more civilized: they allow write access to program memory. The implications for the design of the Forth kernel will be discussed in subsequent articles.","title":"Harvard architectures"},{"location":"moving2.html#case-study-3-the-z80","text":"The Z80 is instructive because it is an extreme example of a non-orthogonal CPU. It has four different kinds of address registers! Some operations use A as destination, some any 8-bit register, some HL, some any 16-bit register, and so on. Many operations (such as EX DE,HL) are only defined for one combination of registers. In a CPU such as the Z80 (or 8086!), the assignment of Forth functions must be carefully matched to the capabilities of the CPU registers. Many more tradeoffs need to be evaluated, and often the only way is to write sample code for a number of different assignments. Rather than burden this article down endless permutations of Forth code, I'll present one register assignment based on many Z80 code experiments. It turns out that these choices can be rationalized in terms of the general principles outlined earlier. I want a \"conventional\" Forth, although I will use direct threading. All of the \"classical\" virtual registers will be needed. Ignoring the alternate register set, the Z80 has six address registers, with the following capabilities: BC,DE - LD A indirect, INC, DEC also exchange DE/HL HL - LD r indirect, ALU indirect, INC, DEC, ADD, ADC, SBC, exchange w/TOS, JP indirect IX,IY - LD r indexed, ALU indexed, INC, DEC, ADD, ADC, SBC, exchange w/TOS, JP indirect (all slow) SP - PUSH/POP 16-bit, ADD/ADC/SUB to HL/IX/IY BC, DE, and HL can also be manipulated in 8-bit pieces. The 8-bit register A must be left as a scratch register, since it's the destination for so many ALU and memory reference operations. HL is undoubtedly the most versatile register, and at one time or another it is tempting to use it for each of the Forth virtual registers. However, because of its versatility -- and because it is the only register which can be fetched byte-wise and used in an indirect jump -- HL should be used for W, Forth's all-purpose working register. IX and IY might be considered for the Forth stack pointers, because of their indexed addressing mode, which can be used in ALU operations. But there are two problems with this: it leaves SP without a job; and, IX/IY are too slow! Most of the operations on either stack involve pushing or popping 16-bit quantities. This is one instruction using SP, but it requires four using IX or IY. One of the Forth stacks should use SP. And this should be the Parameter Stack, since it is used more heavily than the Return Stack. What about Forth's IP? Mostly, IP fetches from memory and autoincrements, so there's no programming advantage to using IX/IY over BC/DE. But speed is of the essence with IP, and BC/DE are faster. Let's put IP in DE: it has the advantage of being able to swap with HL, which adds versatility. A second Z80 register pair (other than W) will be needed for 16-bit arithmetic. Only BC is left, and it can be used for addressing or for ALU operations with A. But should BC be a second working register \"X\", or the top-of-stack? Only code will tell; for now, let's optimistically assume that BC=TOS. This leaves the RSP and UP functions, and the IX and IY registers unused. IX and IY are equivalent, so let's assign IX=RSP, and IY=UP. Thus the Z80 Forth register assignments are: BC = TOS IX = RSP DE = IP IY = UP HL = W SP = PSP Now look at NEXT for the DTC Forth: DTC-NEXT: LD A,(DE) (7) (IP)->W, increment IP LD L,A (4) INC DE (6) LD A,(DE) (7) LD H,A (4) INC DE (6) JP (HL) (4) jump to address in W alternate version (same number of clock cycles) DTC-NEXT: EX DE,HL (4) (IP)->W, increment IP NEXT-HL: LD E,(HL) (7) INC HL (6) LD D,(HL) (7) INC HL (6) EX DE,HL (4) JP (HL) (4) jump to address in W Note that cells are stored low-byte first in memory. Also, although it might seem advantageous to keep IP in HL, it really isn't. This is because the Z80 can't JP (DE). The NEXT-HL entry point will be used shortly. Just for comparison, let's look at an ITC NEXT. The pseudo-code given previously requires another temporary register \"X\", whose contents can be used for an indirect jump. Let DE=X, and BC=IP. TOS will have to be kept in memory. ITC-NEXT: LD A,(BC) (7) (IP)->W, increment IP LD L,A (4) INC BC (6) LD A,(BC) (7) LD H,A (4) INC BC (6) LD E,(HL) (7) (W)->X INC HL (6) LD D,(HL) (7) EX DE,HL (4) jump to address in X JP (HL) (4) This leaves \"W\" incremented by one, and in the DE register. As long as this is done consistently , there's no problem -- code needing the contents of W knows where to find it, and how much to adjust it. The ITC NEXT is 11 instructions, as compared to 7 for DTC. And ITC on the Z80 loses the ability to keep TOS in a register. My choice is DTC. If coded in-line, DTC NEXT would require seven bytes in every CODE word. A jump to a common NEXT routine would only use three bytes, but would add 10 clock cycles. This is another of the tradeoff decisions in designing a Forth kernel. This example is a close call; let's opt for speed with an in-line NEXT. But sometimes NEXT is so huge, or memory is so tight, that the prudent decision is to use a JMP NEXT. Now let's look at the code for ENTER. Using a CALL, the hardware stack is popped to get the Parameter Field address: CALL ENTER (17) ... ENTER: DEC IX (10) push the old IP on the return stack LD (IX+0),D (19) DEC IX (10) LD (IX+0),E (19) POP DE (10) Parameter Field address -> IP NEXT (38) assembler macro for 7 instructions Actually it's faster to POP HL, and then use the last six instructions of NEXT (omitting the EX DE,HL): CALL ENTER (17) ... ENTER: DEC IX (10) push the old IP on the return stack LD (IX+0),D (19) DEC IX (10) LD (IX+0),E (19) POP HL (10) Parameter Field address -> HL NEXT-HL (34) see DTC NEXT code, above 119 cycles total When a JP is used, the W register (HL) is left pointing to the Code Field. The Parameter Field is 3 bytes after: JP ENTER (10) ... ENTER: DEC IX (10) push the old IP on the return stack LD (IX+0),D (19) DEC IX (10) LD (IX+0),E (19) INC HL ( 6) Parameter Field address -> IP INC HL ( 6) INC HL ( 6) NEXT-HL (34) 120 cycles total Again, because of the alternate entry point for NEXT, the new value for IP doesn't actually have to be put into the DE register pair. The CALL version is one cycle faster. On an embedded Z80, a one-byte RST instruction could be used to gain speed and save space. This option is not available on many Z80-based personal computers.","title":"CASE STUDY 3: THE Z80"},{"location":"moving2.html#case-study-4-the-8086","text":"The 8086 is another instructive CPU. Rather than go through the design process, let's look at one of the newer shareware Forths for the IBM PC: Pygmy Forth [SER90]. Pygmy is a direct-threaded Forth with the top-of-stack kept in register. The 8086 register assignments are: AX = W DI = scratch BX = TOS SI = IP CX = scratch BP = RSP DX = scratch SP = PSP Most 8086 Forths use the SI register for IP, so that NEXT can be written with the LODSW instruction. In Pygmy the DTC NEXT is: NEXT: LODSW JMP AX This is short enough to include in-line in every CODE word. High-level and \"defined\" Forth words use a JMP (relative) to their machine code. The ENTER routine (called 'docol' in Pygmy) must therefore get the Parameter Field address from W: ENTER: XCHG SP,BP PUSH SI XCHG SP,BP ADD AX,3 Parameter Field address -> IP MOV SI,AX NEXT Note the use of XCHG to swap the two stack pointers. This allows the use of PUSH and POP instructions for both stacks, which is faster than using indirect access on BP. EXIT: XCHG SP,BP POP SI XCHG SP,BP NEXT","title":"CASE STUDY 4: THE 8086"},{"location":"moving2.html#segment-model","text":"Pygmy Forth is a single-segment Forth; all code and data are contained within a single 64 kByte segment. (This is the \"tiny model\" in Turbo C lingo) All of the Forth standards issued to date assume that everything is contained in a single memory space, accessible with the same fetch and store operators. Nevertheless, IBM PC Forths are beginning to appear that use multiple segments for up to five different kinds of data [KEL92,SEY89]. These are: CODE ...machine code LIST ...high-level Forth threads (a.k.a. THREADS) HEAD ...headers of all Forth words STACK ...parameter and return stacks DATA ...variables and user-defined data This allows PC Forths to break the 64K limit, without going to the expense of implementing a 32-bit Forth on a 16-bit CPU. Implementation of a multi-segment model, and the ramifications for the Forth kernel, are beyond the scope of this article.","title":"Segment model"},{"location":"moving2.html#still-to-come","text":"Subsequent articles will look at: design tradeoffs in the Forth header and dictionary search the logic of CONSTANTs, VARIABLEs, and other data structures the defining word mechanisms, CREATE...;CODE and CREATE...DOES> the assembler vs. metacompiler question the assembler and high-level code that comprises a Forth kernel multitasking modifications to the kernel","title":"STILL TO COME..."},{"location":"moving2.html#references","text":"[KEL92] Kelly, Guy M., \"Forth Systems Comparisons,\" Forth Dimensions XIII:6 (Mar/Apr 1992) [1] [2] [3] . Also published in the 1991 FORML Conference Proceedings . Both available from the Forth Interest Group, P.O. Box 2154, Oakland, CA 94621. Illustrates design tradeoffs of many 8086 Forths with code fragments and benchmarks -- highly recommended! [MOT83] Motorola Inc., 8-Bit Microprocessor and Peripheral Data , Motorola data book (1983). [1] [SIG92] Signetics Inc., 80C51-Based 8-Bit Microcontrollers , Signetics data book (1992). [1]","title":"REFERENCES"},{"location":"moving2.html#forth-implementations","text":"[PAY90] Payne, William H., Embedded Controller FORTH for the 8051 Family , Academic Press (1990), ISBN 0-12-547570-5. This is a complete \"kit\" for a 8051 Forth, including a metacompiler for the IBM PC. Hardcopy only; files can be downloaded from GEnie. Not for the novice! [1] [SER90] Sergeant, Frank, Pygmy Forth for the IBM PC , version 1.3 (1990). Distributed by the author, available from the Forth Interest Group. Version 1.4 is now available on GEnie, and worth the extra effort to obtain. [1] [SEY89] Seywerd, H., Elehew, W. R., and Caven, P., LOVE-83Forth for the IBM PC , version 1.20 (1989). A shareware Forth using a five-segment model. Contact Seywerd Associates, 265 Scarboro Cres., Scarborough, Ontario M1M 2J7 Canada. Author's note for web publication: the files formerly available on the GEnie online service are now available from the Forth Interest Group FTP server, ftp://ftp.forth.org/pub/Forth .","title":"Forth Implementations"},{"location":"moving3.html","text":"MOVING FORTH 3 Part 3: Demystifying DOES> \\ by Brad Rodriguez This article first appeared in The Computer Journal #62 (July/August 1993) . OOPS! There's a colossal mistake in one of my 6809 design decisions in the previous installment. It became evident when I started to code the Forth word EXECUTE. EXECUTE causes the execution of a single Forth word, whose address is given on the Parameter Stack. (To be precise: the compilation address, a.k.a. Code Field Address, is given on the stack.) This can be any kind of Forth word: CODE definition, colon definition, CONSTANT, VARIABLE, or defined word. This differs from the usual Forth interpretation process in that the address of the word-to-execute is given on the stack, and not taken from the \"thread\" (as pointed to by IP). In our direct-threaded 6809 code this can be easily coded: EXECUTE: TFR TOS,W put address of word in W PULU TOS pop new TOS JMP ,W jump to address given in W Note: this is JMP ,W and not JMP [,W], since we already have the code address of the word. We're not fetching from the high-level thread. (If TOS wasn't in register, EXECUTE could be done with simply JMP [,PSP++].) Now suppose that this EXECUTEd word is a colon definition. W will be pointing to its Code Field, which contains JMP ENTER. This does the following (described in the previous article): JMP ENTER ... ENTER: PSHS IP LDX -2,IP re-fetch the Code Field address LEAY 3,X NEXT This is the mistake! We are not executing this word from within a thread, so IP was not pointing to a copy of its Code Field address! (Remember, the address of the word-to-EXECUTE came from the stack .) This form of ENTER will not work with EXECUTE, because there is no way to find the address of the word being executed! This suggests a new general rule for DTC Forths: if NEXT does NOT leave the address of the word-being-executed in a register, you MUST use a Call in the code field. So, the 6809 Forth is back to using a JSR in the Code Field. But to avoid the speed penalty for ENTER -- one of the most-used code fragments in Forth -- I'll complete the \"exercise for the student\" from the last article. Note what happens if you swap the registers assigned to RSP and PSP: with RSP=S, with RSP=U, and PSP=U and PSP=S (previous) (new) JSR ENTER JSR ENTER ... ... ENTER: PULS W PSHU IP push old IP onto R stack PSHS IP PULS IP pop new IP from JSR stack TFR W,IP NEXT NEXT The new version executes in 31 cycles, the same as the JMP version I had wanted to use. The improvement is because the JSR version of ENTER must use both Forth's Return Stack, and the 6809 subroutine-return stack (\"JSR stack\"). Using two different stack pointers means we don't have to \"swap\" the top-of-stack with IP, eliminating the need for a temporary register. This illustrates the usual development process for a new Forth kernel: make some design decisions, write some sample code, discover a bug or a better way to do things, throw out some code, change some design decisions, rewrite some sample code, loop until satisfied. (This is the programming equivalent of a \"rip up\" PC board autorouter.) This teaches an important lesson: make EXECUTE one of your benchmark words! OOPS, AGAIN Carey Bloodworth of Van Buren, AR has pointed out a minor but embarrassing mistake in my 6809 code in the previous installment. For the \"TOS-in-memory\" version of 0=, I showed the code fragment LDD ,PSP CMPD #0 to test for top-of-stack equaling zero. In this case, the CMPD instruction is completely superfluous, since the LDD instruction will set the Zero flag if D is zero! (The TOS-in-D version still requires the CMPD instruction, but remains faster than TOS-in-memory.) Now, on to our main topic: WHAT'S A CODE FIELD? The DOES> concept seems to be one of the most misunderstood and mystifying aspects of Forth. Yet DOES> is also one of Forth's most powerful features -- in many ways, it anticipated object-oriented programming. The action and power of DOES> hinges upon a brilliant innovation of Forth: the Code Field. Recall from Part 1 that the \"body\" of a Forth definition consists of two parts: the Code Field, and the Parameter Field. You can think of these two fields in several ways: The Code Field is the \"action\" taken by this Forth word, and the Parameter Field is the data on which it acts. The Code Field is a subroutine call, and the Parameter Field is parameters that are included \"in-line\" after the call. (The assembly language programmer's view.) The Code Field is the single \"method\" for this \"class\" of words, and the Parameter Field contains the \"instance variables\" for this particular word. (The object-oriented programmer's view.) Common features appear in all these views: The Code Field routine is always called with at least one argument, namely, the address of the Parameter Field for the Forth word being executed. The Parameter Field may contain any number of parameters. There are relatively few distinct actions, i.e., relatively few distinct routines referenced by the Code Field. Each of these routines is widely shared (except for CODE words, as we will see later). Recall, for example, the ENTER routine from Part 2: this common routine is used by all Forth colon definitions. The interpretation of the Parameter Field is implicitly determined by the contents of the Code Field. I.e., each Code Field routine expects the Parameter Field to contain a certain kind of data. A typical Forth kernel will have several Code Field routines predefined. Code Field routine Parameter Field contents ENTER a high-level \"thread\" (series of addresses) DOCON a constant value DOVAR a storage location for data DOVOC vocabulary info (varies by implementation) What makes this feature powerful is that a Forth program is not limited to this set of Code Field routines (or whatever set is provided in your kernel). The programmer can define new Code Field routines, and new Parameter Fields to match. In object-oriented lingo, new \"classes\" and \"methods\" can be created (although each class has only one method). And -- like Forth words themselves -- the Code Field actions can be defined in either assembly language or high-level Forth! To understand the mechanism of the Code Field, and how parameters are passed, we will first look at the case of assembly-language (machine code) actions. We'll start with Indirect Threading (ITC), since it is the easiest to understand, and then see how the logic is modified in Direct-Threaded (DTC) and Subroutine-Threaded (STC) Forths. Then, we'll look at how the Code Field action can be written in high-level Forth. Forthwrights are somewhat inconsistent in their terminology, so I'll define my terms, using the ITC Forth word illustrated in Figure 1 . The Header contains the dictionary information, and isn't involved in the execution of the Forth word. The Body is the \"working\" part of the word, and consists of the fixed-length Code Field, and the variable-length Parameter Field. For any given word, the locations of these two fields in memory are the Code Field Address (CFA) and the Parameter Field Address (PFA), respectively. The Code Field Address of a word is the address in memory where its Code Field is located. This is not to be confused with the contents of the Code Field, which, in ITC Forths, is another different address. To be specific, the contents of the Code Field is the address of a fragment of machine code somewhere else in memory. I will refer to this as the Code Address. Later, when in discussing DTC and STC Forths, I will also refer to the \"Code Field contents,\" which will include more than just the Code Address. Figure 1. An ITC Forth word MACHINE-CODE ACTIONS Forth CONSTANTs are probably the simplest example of a machine-code action. Let's consider some good Francophone constants 1 CONSTANT UN 2 CONSTANT DEUX 3 CONSTANT TROIS Executing the word UN will push the value 1 onto the Forth Parameter Stack. Executing DEUX will push a 2 onto the stack, and so on. (Don't confuse Parameter Stack with Parameter Field; they are entirely separate.) In the Forth kernel there is a single word called CONSTANT. This is not a constant-type word itself; it is a high-level Forth definition. CONSTANT is a \"defining word\": it creates new words in the Forth dictionary. Here we create the new \"constant-type\" words UN, DEUX, and TROIS. (You may think of these as \"instances\" of the \"class\" CONSTANT.) These three words will have their Code Fields pointing to a machine code fragment that does the action of CONSTANT. What must this code fragment do? Figure 2 shows the memory representation of the three constants. All three words point to a common action routine. The difference in the words is entirely contained in their Parameter Fields, which, in this case, simply hold the constant values (\"instance variables\" in object lingo). So, the action of these three words should be fetch the contents of the Parameter Field, and push this onto the stack. The code understands implicitly that the parameter field contains a single-cell value. Figure 2. Three constants To write a machine-code fragment to do this, we need to know how to find the Parameter Field Address, after the Forth interpreter jumps to the machine code. That is, how is the PFA passed to the machine-code routine? This, in turn, depends on how the Forth interpreter NEXT has been coded, which varies from implementation to implementation. To write machine-code actions, we must understand NEXT. The ITC NEXT was described in pseudo-code in Part 1. Here's one implementation for the 6809, using Y=IP and X=W: NEXT: LDX ,Y++ ; (IP) -> W, and IP+2 -> IP JMP [,X] ; (W) -> temp, JMP (temp) Suppose that we're in a high-level thread ... SWAP DEUX + ... with the Interpreter Pointer (IP) pointing to the DEUX \"instruction,\" when NEXT is executed. (This would be at the very end of SWAP.) Figure 3 illustrates what happens. IP (register Y) is pointing within the high-level thread, at a memory cell that contains the address of the Forth word DEUX. To be precise, this cell contains the Code Field Address of DEUX. So, when we fetch a cell using Y, and auto increment Y, we fetch the Code Field Address of DEUX. This goes into W (register X), so W is now pointing to the Code Field. The contents of this field is the address of some machine code. We can fetch the contents of this cell and jump to the machine code with a single 6809 instruction. This leaves register X unchanged, so W is still pointing to the CFA of DEUX. This is how the Parameter Field Address is obtained, since, in this case, it is simply two bytes past the Code Field. Figure 3. ITC Before and After So, the machine code fragment has only to add 2 to W, fetch the cell value at that address, and push that on the stack. This fragment is frequently called DOCON: DOCON: LDD 2,X ; fetch the cell at W+2 PSHU D ; push that on the Parameter Stack NEXT ; (macro) do the next high-level word (For this example, TOS is kept in memory.) Note that the previous NEXT incremented IP by 2, so it is already pointing to the next cell in the thread (\"CFA of +\") when DOCON does NEXT. In general, ITC Forths leave the Parameter Field Address or some \"nearby\" address in the W register. In this case, W contained the CFA, which in this Forth implementation is always PFA-2. Since every class of Forth word except CODE words needs to use the Parameter Field Address, many implementations of NEXT will increment W to leave it pointing to the PFA. We can do this on the 6809 with one small change: NEXT: LDX ,Y++ ; (IP) -> W, and IP+2 -> IP JMP [,X++] ; (W) -> temp, JMP (temp), W+2 -> W This adds three clock cycles to NEXT, and leaves the Parameter Field Address in W. What does it do to the Code Field routines? W=CFA W=PFA DOCON: LDD 2,X (6) PSHU D NEXT DOVAR: LEAX 2,X (5) PSHU X NEXT ENTER: PSHS Y LEAY 2,X (5) NEXT LDD ,X (5) PSHU D NEXT ; no operation PSHU X NEXT PSHS Y LEAY ,X (4, faster than TFR X,Y) NEXT In exchange for a three-cycle penalty in NEXT, the DOCON code is reduced by one clock cycle, DOVAR by five cycles, and ENTER by one cycle. CODE words don't use the value in W, so they gain nothing from the auto increment. The speed gained or lost is determined by the mix of Forth words executed. The usual rule is that most of the words executed are CODE words, thus, incrementing W in NEXT costs a bit of speed overall. (There is a memory savings, but DOCON, DOVAR, and ENTER appear only once, making this gain slight.) The best decision, of course, depends upon the processor. On machines like the Z80, which only access memory by bytes and don't have auto increment address modes, it is often best to leave W pointing to IP+1 (the last byte fetched from the Code Field). On other machines, auto incrementing is \"free,\" and leaving W pointing to the Parameter Field is most convenient. Remember: the decision must be made consistently . If NEXT leaves W pointing to the PFA of the word being executed, then EXECUTE must do likewise! (This was the 'oops' that I corrected at the start of this article.) Direct Threading Direct Threading works just like Indirect Threading, except that instead of the Code Field containing the address of some machine code, it contains a JUMP or CALL to some machine code. This makes the Code Field larger -- e.g., 1 byte larger in the 6809 -- but removes one level of indirection from the NEXT routine. The choice of a JUMP or a CALL instruction in the Code Field hinges upon how the Parameter Field Address can be obtained by the machine code routine. In order to jump to the Code Field, many CPUs require that its address be in a register. For instance, the indirect jump on the 8086 is JMP AX (or some other register), and on the Z80 is JP (HL) (or IX or IY). On these processors, the DTC NEXT involves two operations, which on the 6809 would be: NEXT: LDX ,Y++ ; (IP) -> W, and IP+2 -> IP JMP ,X ; JMP (W) (On the 8086, this can be done with LODSW, JMP AX.) The effect of this is illustrated in Figure 4 as \"case 1\". The Code Field Address of DEUX is fetched from the high-level thread, and IP is incremented. Then, instead of a fetch, a JUMP is made to the Code Field Address (i.e., the CPU jumps directly to the Code Field). The CFA is left in the W register, just like the first ITC example above. Since this address is already in a register, we can simply put a JUMP to DOCON in the Code Field, and the DOCON fragment will work the same as before. Figure 4. DTC Before and After However, some processors -- such as the 6809 and PDP-11 -- can do this DTC NEXT in one instruction: NEXT: JMP [,Y++] ; (IP) -> temp, IP+2 -> IP, JMP (temp) This, too, will cause the CPU to jump to the Code Field of DEUX. But there's one big difference: the CFA is not left in any register! So how is the machine code fragment to find the Parameter Field Address? By putting a CALL (JSR) in the Code Field instead of a JUMP. On most CPUs, the CALL instruction will push the return address -- the address immediately following the CALL instruction -- onto the Return Stack. As Figure 4 illustrates (\"case 2\"), this return address is exactly the Parameter Field Address we want! So, all DOCON has to do is pop the Return Stack -- balancing the JSR in the Code Field -- and then use that address to fetch the constant value. Thus: DOCON: PULS X ; pop the PFA from the Return Stack LDD ,X ; fetch the Parameter Field cell PSHU D ; push that on the Parameter Stack NEXT ; (macro) do the next high-level word Compare this with the ITC version. One instruction has been added to DOCON, but one instruction has been deleted from NEXT. DOVAR and NEXT likewise become one instruction longer: DOVAR: PULS X ; pop the PFA of the word PSHU X ; push that address on the Parameter Stack NEXT ENTER: PULS X ; pop the PFA of the word PSHS Y ; push the old IP TFR X,Y ; the PFA becomes the new IP NEXT Now go back to the beginning of this article, and reread my \"oops,\" to see why we can't just re-fetch the CFA by using the IP. Also note the difference when the assignment of Forth's stack pointers to the 6809's U and S is reversed. Subroutine Threading Subroutine Threading (STC) is like DTC in that the CPU jumps directly to the Code Field of a Forth word. Only now there is no NEXT code, no IP register, and no W register. So, there is no choice but to use a JSR in the Code Field, since this is the only way to obtain the Parameter Field Address. This process is illustrated in Figure 5 . Figure 5. Subroutine Threaded Code The high-level \"thread\" is a series of subroutine calls being executed by the CPU. When the JSR DEUX is executed, the address of the next instruction in the thread is pushed onto the Return Stack. Then, the JSR DOCON within the word DEUX is executed, which causes another return address -- the PFA of DEUX -- to be pushed onto the Return Stack. DOCON can pop that address, use it to fetch the constant, stack the constant, and then do an RTS to return to the thread: DOCON: PULS X ; pop the PFA from the Return Stack LDD ,X ; fetch the Parameter Field cell PSHU D ; push that on the Parameter Stack RTS ; do the next high-level word We can still speak of a Code Field and a Parameter Field in Subroutine-Threaded Code. In every \"class\" of Forth word except CODE and colon definitions, the Code Field is the space occupied by a JSR or CALL instruction (just like DTC), and the Parameter Field is what follows. So, on the 6809, the PFA would equal CFA+3. The meaning of \"Parameter Field\" becomes somewhat fuzzy in CODE and colon definitions, as will be seen in future articles. THE SPECIAL CASE: CODE WORDS There is a significant exception to all of the above generalizations. This is CODE definitions -- Forth words that are defined as a machine code subroutine. This wonderful capability is trivially easy to implement in Forth, since every Forth word executes some piece of machine code! The machine code comprising a CODE word is always contained in the body of the Forth word. In an Indirect-Threaded Forth, the Code Field must contain the address of the machine code to be executed. So the machine code is placed in the Parameter Field, and the Code Field contains the address of the Parameter Field, as shown in Figure 6 . Figure 6. Code Words In Direct- and Subroutine-Threaded Forths, we could -- by analogy -- put, in the Code Field, a JUMP to the Parameter Field. But this would be pointless, since the Parameter Field immediately follows the Code Field! The Code Field could be filled with NOPs for the same result. Better still, the machine code could be started at the Code Field, and continued into the Parameter Field. At this point the distinction of \"Code Field\" and \"Parameter Field\" breaks down. This is no problem, because we don't need this distinction for CODE words. (This does have ramifications for decompilers and certain clever programming tricks, none of which concern us here.) CODE words -- whatever the implementation -- are the one case where the machine code \"action\" routine does not need to be passed the Parameter Field address. The Parameter Field contains, not data, but the code being executed! Only NEXT needs to know this address (or the Code Field Address), so it can jump to the machine code. USING ;CODE Three questions remain unanswered: a. how do we create a new Forth word that has some arbitrary data in its Parameter Field? b. how do we change the Code Field of that word, to point to some machine code of our choosing? c. how do we compile (assemble) this machine code fragment, which exists in isolation from the words using it? The answer to (a) is: we write a Forth word to do this. Since this word, when executed, will define (create) a new word in the Forth dictionary, it is called a \"defining word.\" CONSTANT is one example of a defining word. All of the \"hard work\" of a defining word is done by a kernel word, CREATE, which parses a name from the input stream, builds the header and Code Field for a new word, and links it into the dictionary. (In fig-Forth this word is called \\<BUILDS.) All that remains for the programmer is to build the Parameter Field. The answer to (b) and (c) is embodied in two convoluted words called (;CODE) and ;CODE respectively. To understand how they work, let's look at how the defining word CONSTANT is actually written in Forth. Using the original ITC 6809 example: : CONSTANT ( n -- ) CREATE \\ create the new word , \\ append the TOS value to the dictionary, \\ as the 1st cell of the Parameter Field ;CODE \\ end high-level & start assembler code LDD 2,X \\ the code fragment DOCON PSHU D \\ \" \" \" \" NEXT \\ \" \" \" \" END-CODE There are two parts to this Forth word. Everything from : CONSTANT to ;CODE is the high-level Forth code executed when the word CONSTANT is invoked. Everything from ;CODE to END-CODE is machine code executed when the \"children\" of CONSTANT -- the \"constant-class\" words such as UN and DEUX -- are executed. That is, everything from ;CODE to END-CODE is the code fragment to which constant-type words will point. The name ;CODE signifies that it ends a high-level definition (\";\") and begins a machine- code definition (\"CODE\"). However, this is not put into the dictionary as two separate words. Everything from : CONSTANT to END-CODE is contained in the Parameter Field of CONSTANT, as shown in Figure 7 . Figure 7. ITC ;CODE Derick and Baker [DER82] name three \"sequences\" that help to understand the action of defining words: Sequence 1 is when the word CONSTANT is being defined . This involves both the high-level compiler (for the first part) and the Forth assembler (for the second part). This is when the definition of CONSTANT shown in Figure 7 is added to the dictionary. As we will see shortly, ;CODE -- a compiler directive -- is executed during Sequence 1. Sequence 2 is when the word CONSTANT is being executed , and when some constant-type word is being defined. In the example 2 CONSTANT DEUX Sequence 2 is when the word CONSTANT executes, and the word DEUX is added to the dictionary (as shown in Figure 7 ). During Sequence 2, the high-level part of CONSTANT is executed, including the word (;CODE). Sequence 3 is when the constant-type word is executed. In our example, Sequence 3 is when DEUX is executed to push the value 2 onto the stack. This is when the machine-code part of CONSTANT is executed. (Recall that this fragment is the Code Field action of DEUX.) The words ;CODE and (;CODE) do the following: ;CODE is executed during Sequence 1, when CONSTANT is compiled. This is an example of a Forth IMMEDIATE word -- a word executed during the Forth compilation. ;CODE does three things: a. it compiles the Forth word (;CODE) into CONSTANT, b. it turns off the Forth compiler, and c. it turns on the Forth assembler. (;CODE) is part of the word CONSTANT, so it executes when CONSTANT executes (Sequence 2). It performs the following actions: a. It gets the address of the machine code that immediately follows. This is done by popping IP from the Forth Return Stack. b. It puts that address into the Code Field of the word just defined by CREATE. The Forth word LAST (sometimes LATEST) gets the address of that word. c. It does the action of EXIT (a.k.a. ;S) so that the Forth inner interpreter doesn't try to execute the machine code that follows as part of the Forth thread. This is the high-level \"subroutine return\" which ends a Forth thread. F83 [LAX84] illustrates how these are typically coded in Forth: : ;CODE COMPILE (;CODE) \\ compiles (;CODE) into definition ?CSP [COMPILE] [ \\ turns off the Forth compiler REVEAL \\ (just like \";\" does) ASSEMBLER \\ turns on the assembler ; IMMEDIATE \\ this is an IMMEDIATE word! : (;CODE) R> \\ pops the adrs of the machine code LAST @ NAME> \\ gets the CFA of the latest word ! \\ stores the code address in the ; \\ Code Field (;CODE) is the more subtle of the two. Since it is a high-level Forth definition, the address following it in the CONSTANT thread -- the high-level \"return address\" -- is pushed onto Forth's Return Stack. So, popping the Return Stack while within (;CODE) will yield the address of the machine code that follows. Also, popping this value from the Return Stack will \"bypass\" one level of high-level subroutine return, so that when (;CODE) exits, it will exit to the caller of CONSTANT. This is equivalent to returning to CONSTANT, and then having CONSTANT return immediately. Use Figure 7 and walk through the execution of the words CONSTANT and (;CODE) to see how this works. Direct and Subroutine Threading For DTC and STC, the action of ;CODE and (;CODE) is identical to ITC, with one important exception: instead of holding an address, the Code Field holds a JUMP or CALL instruction. For an absolute JUMP or CALL, probably the only difference is that the address has to be stored at the end of the Code Field, as the operand of the JUMP or CALL instruction. In the case of the 6809, the address would be stored as the last two bytes of the three-byte JSR instruction. But some Forths, such as Pygmy Forth on the 8086, use a relative branch in the code field. In this case, the relative offset must be computed and inserted into the branch instruction. HIGH-LEVEL FORTH ACTIONS We have seen how to make a Forth word execute a chosen fragment of machine language code, and how to pass that fragment the address of the word's Parameter Field. But how do we write the \"action routine\" in high-level Forth? Every Forth word must -- by the action of NEXT -- execute some machine language routine. This is what the Code Field is all about. Therefore, a machine language routine, or a set of routines, is needed to handle the problems of invoking a high- level action. We'll call this routine DODOES. There are three problems to be solved: a. how do we find the address of the high-level action routine associated with this Forth word? b. how do we, from machine code, invoke the Forth interpreter for a high-level action routine? c. how do we pass that routine the address of the Parameter Field for the word we are executing? The answer to (c) -- how do you pass an argument to a high-level Forth routine -- is easy. On the Parameter Stack, of course. Our machine language routine must push the Parameter Field Address on the stack before it invokes the high level routine. (From our previous work, we know how the machine language routine can obtain the PFA.) The answer to (b) is a bit more difficult. Basically, we want to do something like the Forth word EXECUTE, which invokes a Forth word; or perhaps ENTER, which invokes a colon definition. Both are among our \"key\" kernel words. The DODOES code will resemble these. Question (a) is the tricky one. Where to put the address of the high-level routine? Remember, the Code Field does not point to high-level code; it must point to machine code. Two approaches have been used in the past: 1. The fig-Forth solution Fig-Forth reserved the first cell of the Parameter Field to hold the address of the high-level code. The DODOES routine then obtained the Parameter Field address, pushed the address of the actual data (typically PFA+2) onto the stack, fetched the address of the high-level routine, and EXECUTEd. There were two problems with this approach. First, the structure of the Parameter Field was different for machine-code actions and high-level actions. For example, a CONSTANT defined with a machine code action would have its data stored at PFA, but a CONSTANT defined with a high-level action would have its data stored at (typically) PFA+2. Second, every instance of a high-level-action class carried an additional overhead of one cell. That is, if CONSTANT used a high-level action, every constant defined in the program was one cell larger! Fortunately, clever Forth programmers quickly devised a solution which overcame these problems, and the fig-Forth approach has fallen into disuse. 2. The modern solution Most Forths nowadays associate a different machine language fragment with each high-level action routine. So, a high-level constant would have its Code Field pointing to a machine language fragment whose sole function is to invoke the high-level action of CONSTANT. A high-level variable's Code Field would point to the \"startup\" routine for the high-level VARIABLE action, and so on. Is this excessive duplication of code? No, because each of these machine-language fragments is just a subroutine call to a common startup routine, DODOES. (This is different from the fig-Forth DODOES routine.) The address of the high-level code to DODOES is passed as an \"inline\" subroutine parameter. That is, the address of the high-level code is put immediately after the JSR/CALL instruction. DODOES can then pop the CPU stack and do a fetch to obtain this address. Actually, we make two more simplifications. The high-level code itself is put immediately after the JSR/CALL instruction. Then DODOES pops the CPU stack, and obtains this address directly. And since we know this is high-level Forth code, we dispense with its Code Field and just compile the high-level thread...essentially incorporating the action of ENTER into DODOES. Now each \"defined\" word just points to a bit of machine code...no space is consumed in its Parameter Field. This bit of machine code is a JSR or CALL instruction, followed by the high-level action routine. In the 6809 example, we have traded two bytes in every constant for a three-byte JSR that appears only once. This is undoubtedly the most convoluted program logic in the entire Forth kernel! So, let's see how this is implemented in practice, using our trusty ITC 6809 example. Figure 8. ITC DODOES Figure 8 shows the constant DEUX implemented with a high-level action. When the Forth interpreter encounters DEUX -- that is, when the Forth IP is at IP(1) -- it does the usual thing: it fetches the address contained in DEUX's Code Field, and jumps to that address. At that address is a JSR DODOES instruction, so a second jump -- this time a subroutine call -- is immediately taken. DODOES must then perform the following actions: a. Push the address of DEUX's Parameter Field onto the Parameter Stack, for later use by the high-level action routine. Since the JSR instruction does not alter any registers, we expect to find the Parameter Field Address of DEUX (or a \"nearby\" address) still in the W register. b. Obtain the address of the high-level action routine, by popping the CPU stack. (Recall that popping the CPU stack will give the address of whatever immediately follows the JSR instruction.) This is a high-level thread , i.e., the Parameter Field part of a colon definition. c. Save the old value of Forth's Instruction Pointer -- IP(2) -- on Forth's Return Stack, since the IP register will be used to execute the high-level fragment. Essentially, DODOES must \"nest\" the IP, just like ENTER does. Remember that Forth's Return Stack may not be the same as the CPU subroutine stack. d. Put the address of the high-level thread into IP. This is IP(3) in Figure 8 . e. Do a NEXT to continue high-level interpretation at the new location. Assume an indirect-threaded ITC 6809, and the following: W is not incremented by NEXT (i.e., W will contain the CFA of the word entered by NEXT); the 6809 S is Forth's PSP, and U is Forth's RSP (i.e., the CPU stack is not Forth's Return Stack); the 6809 Y is Forth's IP, and X is Forth's W. Recall the definition of NEXT for these conditions: NEXT: LDX ,Y++ ; (IP) -> W, and IP+2 -> IP JMP [,X] ; (W) -> temp, JMP (temp) DODOES can be written as follows: DODOES: LEAX 2,X ; make W point to the Parameter Field PSHU Y ; (c) push old IP onto the Return Stack PULS Y ; (b,d) pop new IP from the CPU stack PSHS X ; (a) push W (the Parameter Field ; Address) onto the Parameter Stack NEXT ; (e) invoke high-level interpreter These operations are slightly out of sequence. As long as the right things go onto the right stacks (or into the right registers) at the right time, the exact order of operations is not critical. In this case, we're taking advantage of the fact that the old IP can be pushed onto Forth's Return Stack before the new IP is popped from the CPU stack. On some processors the CPU stack is used as Forth's Return Stack. In this case, one step involving temporary storage is necessary. If we had chosen S=RSP and U=PSP above, DODOES would be: DODOES: LEAX 2,X ; make W point to the Parameter Field PSHU X ; (a) push W (the Parameter Field ; Address) onto the Parameter Stack PULS X ; (b) pop thread address from CPU stack PSHS Y ; (c) push old IP onto the Return Stack TFR X,Y ; (d) put thread address into IP NEXT ; (e) invoke high-level interpreter Since we are essentially swapping the top of the Return/CPU stack with IP, we need to use X as a temporary holding register. Thus we must push the PFA -- step (a) -- before re-using the X register. Walk through both of these DODOES examples step by step, and track the contents of the registers and the two stacks. I always walk through my DODOES routine, just to make sure I'm not clobbering a register at the wrong time. Direct Threading The logic of DODOES is the same in DTC Forths. But the implementation may be different, depending on whether the DTC Forth uses a JMP or a CALL in the Code Field of a word. a. JMP in Code Field. A DTC Forth can use a JMP in the Code Field if the address of the word being executed is found in a register. This will most likely be the Code Field Address. From the point of view of DODOES, this is identical to ITC. In our example, DODOES sees that the Forth interpreter jumps to the machine code associated with DEUX, and that code is a JSR to DODOES. It doesn't matter that the first jump is now a direct jump rather than an indirect jump; the register and stack contents are the same. So, the code for DODOES will be identical to that for ITC. (Of course, NEXT is different, and W may need a different offset to point to the Parameter Field.) b. CALL/JSR in Code Field. In the DTC 6809, we never explicitly fetch the CFA of the word being executed, so the Forth word must contain a JSR in its Code Field. Instead of finding the Parameter Field Address of the Forth word in a register, we find it on the CPU stack. Figure 9. DTC DODOES The DEUX example in this case is shown in Figure 9 . When the Forth IP is at IP(1), the Forth interpreter jumps to the Code Field of DEUX (and increments IP). In the Code Field is a JSR to DEUX's machine code fragment. At that address is a second JSR, to DODOES. So two things get pushed onto the CPU stack. The return address of the first JSR is the Parameter Field address of DEUX. The return address of the second JSR -- and thus topmost on the CPU stack -- is the address of the high-level thread to be executed. DODOES must ensure that the old IP is pushed onto the Return Stack, the PFA of DEUX is pushed onto the Parameter Stack, and the address of the high-level thread is loaded into IP. This is very sensitive to stack assignments! For S=PSP (CPU stack) and U=RSP, the NEXT and DODOES code is: NEXT: LDX [,Y++] ; (IP) -> temp, IP+2 -> IP, JMP (temp) DODOES: PSHU Y ; push old IP onto the Return Stack PULS Y ; pop new IP from the CPU stack ; note: the CPU stack is the Parameter Stack, and the ; topmost element is now the PFA of the word... ; exactly what we want! NEXT ; invoke high-level interpreter Check for yourself that the flow through NEXT, DEUX, and DODOES pushes a net total of one item -- the PFA of DEUX -- onto the Parameter Stack! Subroutine Threading In STC Forths, there are no IP or W registers, and a high-level \"thread\" is pure machine code (a series of subroutine calls). The only difference between a high-level action and a ;CODE action is that the PFA of the \"defined\" word must be pushed onto the Parameter Stack. \"Defined\" words have a CALL/JSR in the Code Field, and the CPU stack must be Forth's Return Stack, so DODOES is mostly a matter of stack manipulations. Figure 10. STC DODOES Figure 10 shows a 6809 STC example of DEUX with a high-level action. By the time DODOES is entered, three things have been pushed onto the CPU/Return Stack: the return address in the \"main\" thread, the PFA of DEUX, and the address of DEUX's high-level action code. DODOES must pop the last two, push the PFA onto the Parameter Stack, and jump to the action code: DODOES: PULS X,Y ; action code adrs -> X, PFA -> Y PSHU Y ; push PFA onto Parameter Stack JMP ,X ; jump to the action code DODOES for the 6809 is now a three-instruction routine. It can be simplified even further by \"expanding JSR DODOES in-line\", i.e., replacing the JSR DODOES with the equivalent machine code instructions. Since there's one less JSR, this simplifies the stack manipulation to: PULS X ; pop PFA from CPU stack PSHU X ; and push it onto the Parameter Stack ...high level thread for DEUX... This replaces a three-byte JSR with four bytes of explicit code, with a considerable improvement in speed. For the 6809 this would probably be a good choice. For a processor like the 8051, DODOES is long enough that it should be kept as a subroutine. USING DOES> We learned with ;CODE how to create a new Forth word with arbitrary data in its parameter field, and how to make that word's Code Field point to a new machine code fragment. How do we compile a high-level action routine, and make a new word point to it? The answer lies in the two words DOES> and (DOES>), which are the high-level equivalents of ;CODE and (;CODE). To understand them, let's look at an example of their use: : CONSTANT ( n -- ) CREATE \\ create the new word , \\ append the TOS value to the dictionary, \\ as the 1st cell of the Parameter Field DOES> \\ end \"create\" part & start \"action\" part @ \\ given the PFA, fetch its contents ; Compare this with the previous ;CODE example, and observe that DOES> performs a function analogous to ;CODE. Everything from : CONSTANT to DOES> is executed when the word CONSTANT is invoked. This is the code which builds the Parameter Field of the \"defined\" word. Everything from DOES> to ; is the high-level code executed when the \"children\" of CONSTANT (such as DEUX) are invoked, i.e., the high-level fragment to which the Code Field will point. (We'll see that a JSR DODOES is included before this high-level fragment.) Just as with ;CODE, both the \"create\" and the \"action\" clauses are contained within the body of the Forth word CONSTANT, as shown in Figure 11 . Figure 11. ITC DOES> Recall Sequence 1, 2, and 3. The words DOES> and (DOES>) do the following: DOES> is executed during Sequence 1, when CONSTANT is compiled. Thus DOES> is a Forth IMMEDIATE word. It does two things: a. It compiles the Forth word (DOES>) into CONSTANT. b. It compiles a JSR DODOES into CONSTANT. Note that DOES> leaves the Forth compiler running, in order to compile the high-level fragment which follows. Also, even though JSR DODOES is not itself Forth code, an IMMEDIATE word such as DOES> can cause it to be compiled in the middle of Forth code. (DOES>) is part of the word CONSTANT, so it executes when CONSTANT executes (Sequence 2). It does the following: a. It gets the address of the machine code that immediately follows (JSR DODOES), by popping IP from the Forth Return Stack. b. It puts that address into the Code Field of the word just defined by CREATE. c. It performs the action of EXIT, causing CONSTANT to terminate here and not attempt to execute the fragment that follows. The action of (DOES>) is identical to (;CODE)! A separate word is not strictly required. F83, for example, uses (;CODE) in both ;CODE and DOES>. I'll use (;CODE) from now on instead of (DOES>). You've already seen the workings of (;CODE). The F83 definition of DOES> is : DOES> COMPILE (;CODE) \\ compiles (;CODE) into definition 0E8 C, \\ the CALL opcode byte DODOES HERE 2+ - , \\ the relative offset to DODOES ; IMMEDIATE where DODOES is a constant which holds the address of the DODOES routine. (The actual F83 source code is slightly different, due to the requirements of the F83 metacompiler.) DOES> need not fiddle with CSP or the smudge bit, since the Forth compiler is left \"on.\" In the case of the 8086, the CALL instruction expects a relative address...hence the arithmetic involving DODOES and HERE. In the 6809, DOES> would look like : DOES> COMPILE (;CODE) \\ compiles (;CODE) into definition 0BD C, \\ the JSR Extended opcode byte DODOES , \\ the operand: address of DODOES ; IMMEDIATE You can see here how the machine language JSR DODOES is compiled after the high-level (;CODE), and before the high-level \"action\" code. Direct and Subroutine Threading The only difference in DTC and STC is how the Code Field is fiddled to point to a new routine. This is done by (;CODE), and the required changes have already been described. DOES> isn't affected at all, unless you're writing an STC Forth and expanding the JSR DODOES to explicit machine code. In this case, DOES> is modified to assemble the \"in-line\" machine code instead of a JSR DODOES instruction. ONWARD AND UPWARD Who would have thought that so few lines of code would require so much explanation? This is why I admire ;CODE and DOES> so much...I've never before seen seen such intricate, powerful, and flexible constructs coded with such economy. In the next installment I'll discuss the merits of assemblers vs. metacompilers, and provide the actual CODE definitions for our Forth example systems. REFERENCES [DER82] Derick, Mitch and Baker, Linda, Forth Encyclopedia , Mountain View Press (1982). A word-by-word description of fig-Forth in minute detail. Still available from the Forth Interest Group, P.O. Box 2154, Oakland CA 94621. [LAX84] Laxen, H. and Perry, M., F83 for the IBM PC , version 2.1.0 (1984). Distributed by the authors, available from the Forth Interest Group or GEnie. Author's note for web publication: the files formerly available on the GEnie online service are now available from the Forth Interest Group FTP server, ftp://ftp.forth.org/pub/Forth .","title":"MOVING FORTH 3"},{"location":"moving3.html#moving-forth-3","text":"Part 3: Demystifying DOES> \\ by Brad Rodriguez This article first appeared in The Computer Journal #62 (July/August 1993) .","title":"MOVING FORTH 3"},{"location":"moving3.html#oops","text":"There's a colossal mistake in one of my 6809 design decisions in the previous installment. It became evident when I started to code the Forth word EXECUTE. EXECUTE causes the execution of a single Forth word, whose address is given on the Parameter Stack. (To be precise: the compilation address, a.k.a. Code Field Address, is given on the stack.) This can be any kind of Forth word: CODE definition, colon definition, CONSTANT, VARIABLE, or defined word. This differs from the usual Forth interpretation process in that the address of the word-to-execute is given on the stack, and not taken from the \"thread\" (as pointed to by IP). In our direct-threaded 6809 code this can be easily coded: EXECUTE: TFR TOS,W put address of word in W PULU TOS pop new TOS JMP ,W jump to address given in W Note: this is JMP ,W and not JMP [,W], since we already have the code address of the word. We're not fetching from the high-level thread. (If TOS wasn't in register, EXECUTE could be done with simply JMP [,PSP++].) Now suppose that this EXECUTEd word is a colon definition. W will be pointing to its Code Field, which contains JMP ENTER. This does the following (described in the previous article): JMP ENTER ... ENTER: PSHS IP LDX -2,IP re-fetch the Code Field address LEAY 3,X NEXT This is the mistake! We are not executing this word from within a thread, so IP was not pointing to a copy of its Code Field address! (Remember, the address of the word-to-EXECUTE came from the stack .) This form of ENTER will not work with EXECUTE, because there is no way to find the address of the word being executed! This suggests a new general rule for DTC Forths: if NEXT does NOT leave the address of the word-being-executed in a register, you MUST use a Call in the code field. So, the 6809 Forth is back to using a JSR in the Code Field. But to avoid the speed penalty for ENTER -- one of the most-used code fragments in Forth -- I'll complete the \"exercise for the student\" from the last article. Note what happens if you swap the registers assigned to RSP and PSP: with RSP=S, with RSP=U, and PSP=U and PSP=S (previous) (new) JSR ENTER JSR ENTER ... ... ENTER: PULS W PSHU IP push old IP onto R stack PSHS IP PULS IP pop new IP from JSR stack TFR W,IP NEXT NEXT The new version executes in 31 cycles, the same as the JMP version I had wanted to use. The improvement is because the JSR version of ENTER must use both Forth's Return Stack, and the 6809 subroutine-return stack (\"JSR stack\"). Using two different stack pointers means we don't have to \"swap\" the top-of-stack with IP, eliminating the need for a temporary register. This illustrates the usual development process for a new Forth kernel: make some design decisions, write some sample code, discover a bug or a better way to do things, throw out some code, change some design decisions, rewrite some sample code, loop until satisfied. (This is the programming equivalent of a \"rip up\" PC board autorouter.) This teaches an important lesson: make EXECUTE one of your benchmark words!","title":"OOPS!"},{"location":"moving3.html#oops-again","text":"Carey Bloodworth of Van Buren, AR has pointed out a minor but embarrassing mistake in my 6809 code in the previous installment. For the \"TOS-in-memory\" version of 0=, I showed the code fragment LDD ,PSP CMPD #0 to test for top-of-stack equaling zero. In this case, the CMPD instruction is completely superfluous, since the LDD instruction will set the Zero flag if D is zero! (The TOS-in-D version still requires the CMPD instruction, but remains faster than TOS-in-memory.) Now, on to our main topic:","title":"OOPS, AGAIN"},{"location":"moving3.html#whats-a-code-field","text":"The DOES> concept seems to be one of the most misunderstood and mystifying aspects of Forth. Yet DOES> is also one of Forth's most powerful features -- in many ways, it anticipated object-oriented programming. The action and power of DOES> hinges upon a brilliant innovation of Forth: the Code Field. Recall from Part 1 that the \"body\" of a Forth definition consists of two parts: the Code Field, and the Parameter Field. You can think of these two fields in several ways: The Code Field is the \"action\" taken by this Forth word, and the Parameter Field is the data on which it acts. The Code Field is a subroutine call, and the Parameter Field is parameters that are included \"in-line\" after the call. (The assembly language programmer's view.) The Code Field is the single \"method\" for this \"class\" of words, and the Parameter Field contains the \"instance variables\" for this particular word. (The object-oriented programmer's view.) Common features appear in all these views: The Code Field routine is always called with at least one argument, namely, the address of the Parameter Field for the Forth word being executed. The Parameter Field may contain any number of parameters. There are relatively few distinct actions, i.e., relatively few distinct routines referenced by the Code Field. Each of these routines is widely shared (except for CODE words, as we will see later). Recall, for example, the ENTER routine from Part 2: this common routine is used by all Forth colon definitions. The interpretation of the Parameter Field is implicitly determined by the contents of the Code Field. I.e., each Code Field routine expects the Parameter Field to contain a certain kind of data. A typical Forth kernel will have several Code Field routines predefined. Code Field routine Parameter Field contents ENTER a high-level \"thread\" (series of addresses) DOCON a constant value DOVAR a storage location for data DOVOC vocabulary info (varies by implementation) What makes this feature powerful is that a Forth program is not limited to this set of Code Field routines (or whatever set is provided in your kernel). The programmer can define new Code Field routines, and new Parameter Fields to match. In object-oriented lingo, new \"classes\" and \"methods\" can be created (although each class has only one method). And -- like Forth words themselves -- the Code Field actions can be defined in either assembly language or high-level Forth! To understand the mechanism of the Code Field, and how parameters are passed, we will first look at the case of assembly-language (machine code) actions. We'll start with Indirect Threading (ITC), since it is the easiest to understand, and then see how the logic is modified in Direct-Threaded (DTC) and Subroutine-Threaded (STC) Forths. Then, we'll look at how the Code Field action can be written in high-level Forth. Forthwrights are somewhat inconsistent in their terminology, so I'll define my terms, using the ITC Forth word illustrated in Figure 1 . The Header contains the dictionary information, and isn't involved in the execution of the Forth word. The Body is the \"working\" part of the word, and consists of the fixed-length Code Field, and the variable-length Parameter Field. For any given word, the locations of these two fields in memory are the Code Field Address (CFA) and the Parameter Field Address (PFA), respectively. The Code Field Address of a word is the address in memory where its Code Field is located. This is not to be confused with the contents of the Code Field, which, in ITC Forths, is another different address. To be specific, the contents of the Code Field is the address of a fragment of machine code somewhere else in memory. I will refer to this as the Code Address. Later, when in discussing DTC and STC Forths, I will also refer to the \"Code Field contents,\" which will include more than just the Code Address. Figure 1. An ITC Forth word","title":"WHAT'S A CODE FIELD?"},{"location":"moving3.html#machine-code-actions","text":"Forth CONSTANTs are probably the simplest example of a machine-code action. Let's consider some good Francophone constants 1 CONSTANT UN 2 CONSTANT DEUX 3 CONSTANT TROIS Executing the word UN will push the value 1 onto the Forth Parameter Stack. Executing DEUX will push a 2 onto the stack, and so on. (Don't confuse Parameter Stack with Parameter Field; they are entirely separate.) In the Forth kernel there is a single word called CONSTANT. This is not a constant-type word itself; it is a high-level Forth definition. CONSTANT is a \"defining word\": it creates new words in the Forth dictionary. Here we create the new \"constant-type\" words UN, DEUX, and TROIS. (You may think of these as \"instances\" of the \"class\" CONSTANT.) These three words will have their Code Fields pointing to a machine code fragment that does the action of CONSTANT. What must this code fragment do? Figure 2 shows the memory representation of the three constants. All three words point to a common action routine. The difference in the words is entirely contained in their Parameter Fields, which, in this case, simply hold the constant values (\"instance variables\" in object lingo). So, the action of these three words should be fetch the contents of the Parameter Field, and push this onto the stack. The code understands implicitly that the parameter field contains a single-cell value. Figure 2. Three constants To write a machine-code fragment to do this, we need to know how to find the Parameter Field Address, after the Forth interpreter jumps to the machine code. That is, how is the PFA passed to the machine-code routine? This, in turn, depends on how the Forth interpreter NEXT has been coded, which varies from implementation to implementation. To write machine-code actions, we must understand NEXT. The ITC NEXT was described in pseudo-code in Part 1. Here's one implementation for the 6809, using Y=IP and X=W: NEXT: LDX ,Y++ ; (IP) -> W, and IP+2 -> IP JMP [,X] ; (W) -> temp, JMP (temp) Suppose that we're in a high-level thread ... SWAP DEUX + ... with the Interpreter Pointer (IP) pointing to the DEUX \"instruction,\" when NEXT is executed. (This would be at the very end of SWAP.) Figure 3 illustrates what happens. IP (register Y) is pointing within the high-level thread, at a memory cell that contains the address of the Forth word DEUX. To be precise, this cell contains the Code Field Address of DEUX. So, when we fetch a cell using Y, and auto increment Y, we fetch the Code Field Address of DEUX. This goes into W (register X), so W is now pointing to the Code Field. The contents of this field is the address of some machine code. We can fetch the contents of this cell and jump to the machine code with a single 6809 instruction. This leaves register X unchanged, so W is still pointing to the CFA of DEUX. This is how the Parameter Field Address is obtained, since, in this case, it is simply two bytes past the Code Field. Figure 3. ITC Before and After So, the machine code fragment has only to add 2 to W, fetch the cell value at that address, and push that on the stack. This fragment is frequently called DOCON: DOCON: LDD 2,X ; fetch the cell at W+2 PSHU D ; push that on the Parameter Stack NEXT ; (macro) do the next high-level word (For this example, TOS is kept in memory.) Note that the previous NEXT incremented IP by 2, so it is already pointing to the next cell in the thread (\"CFA of +\") when DOCON does NEXT. In general, ITC Forths leave the Parameter Field Address or some \"nearby\" address in the W register. In this case, W contained the CFA, which in this Forth implementation is always PFA-2. Since every class of Forth word except CODE words needs to use the Parameter Field Address, many implementations of NEXT will increment W to leave it pointing to the PFA. We can do this on the 6809 with one small change: NEXT: LDX ,Y++ ; (IP) -> W, and IP+2 -> IP JMP [,X++] ; (W) -> temp, JMP (temp), W+2 -> W This adds three clock cycles to NEXT, and leaves the Parameter Field Address in W. What does it do to the Code Field routines? W=CFA W=PFA DOCON: LDD 2,X (6) PSHU D NEXT DOVAR: LEAX 2,X (5) PSHU X NEXT ENTER: PSHS Y LEAY 2,X (5) NEXT LDD ,X (5) PSHU D NEXT ; no operation PSHU X NEXT PSHS Y LEAY ,X (4, faster than TFR X,Y) NEXT In exchange for a three-cycle penalty in NEXT, the DOCON code is reduced by one clock cycle, DOVAR by five cycles, and ENTER by one cycle. CODE words don't use the value in W, so they gain nothing from the auto increment. The speed gained or lost is determined by the mix of Forth words executed. The usual rule is that most of the words executed are CODE words, thus, incrementing W in NEXT costs a bit of speed overall. (There is a memory savings, but DOCON, DOVAR, and ENTER appear only once, making this gain slight.) The best decision, of course, depends upon the processor. On machines like the Z80, which only access memory by bytes and don't have auto increment address modes, it is often best to leave W pointing to IP+1 (the last byte fetched from the Code Field). On other machines, auto incrementing is \"free,\" and leaving W pointing to the Parameter Field is most convenient. Remember: the decision must be made consistently . If NEXT leaves W pointing to the PFA of the word being executed, then EXECUTE must do likewise! (This was the 'oops' that I corrected at the start of this article.)","title":"MACHINE-CODE ACTIONS"},{"location":"moving3.html#direct-threading","text":"Direct Threading works just like Indirect Threading, except that instead of the Code Field containing the address of some machine code, it contains a JUMP or CALL to some machine code. This makes the Code Field larger -- e.g., 1 byte larger in the 6809 -- but removes one level of indirection from the NEXT routine. The choice of a JUMP or a CALL instruction in the Code Field hinges upon how the Parameter Field Address can be obtained by the machine code routine. In order to jump to the Code Field, many CPUs require that its address be in a register. For instance, the indirect jump on the 8086 is JMP AX (or some other register), and on the Z80 is JP (HL) (or IX or IY). On these processors, the DTC NEXT involves two operations, which on the 6809 would be: NEXT: LDX ,Y++ ; (IP) -> W, and IP+2 -> IP JMP ,X ; JMP (W) (On the 8086, this can be done with LODSW, JMP AX.) The effect of this is illustrated in Figure 4 as \"case 1\". The Code Field Address of DEUX is fetched from the high-level thread, and IP is incremented. Then, instead of a fetch, a JUMP is made to the Code Field Address (i.e., the CPU jumps directly to the Code Field). The CFA is left in the W register, just like the first ITC example above. Since this address is already in a register, we can simply put a JUMP to DOCON in the Code Field, and the DOCON fragment will work the same as before. Figure 4. DTC Before and After However, some processors -- such as the 6809 and PDP-11 -- can do this DTC NEXT in one instruction: NEXT: JMP [,Y++] ; (IP) -> temp, IP+2 -> IP, JMP (temp) This, too, will cause the CPU to jump to the Code Field of DEUX. But there's one big difference: the CFA is not left in any register! So how is the machine code fragment to find the Parameter Field Address? By putting a CALL (JSR) in the Code Field instead of a JUMP. On most CPUs, the CALL instruction will push the return address -- the address immediately following the CALL instruction -- onto the Return Stack. As Figure 4 illustrates (\"case 2\"), this return address is exactly the Parameter Field Address we want! So, all DOCON has to do is pop the Return Stack -- balancing the JSR in the Code Field -- and then use that address to fetch the constant value. Thus: DOCON: PULS X ; pop the PFA from the Return Stack LDD ,X ; fetch the Parameter Field cell PSHU D ; push that on the Parameter Stack NEXT ; (macro) do the next high-level word Compare this with the ITC version. One instruction has been added to DOCON, but one instruction has been deleted from NEXT. DOVAR and NEXT likewise become one instruction longer: DOVAR: PULS X ; pop the PFA of the word PSHU X ; push that address on the Parameter Stack NEXT ENTER: PULS X ; pop the PFA of the word PSHS Y ; push the old IP TFR X,Y ; the PFA becomes the new IP NEXT Now go back to the beginning of this article, and reread my \"oops,\" to see why we can't just re-fetch the CFA by using the IP. Also note the difference when the assignment of Forth's stack pointers to the 6809's U and S is reversed.","title":"Direct Threading"},{"location":"moving3.html#subroutine-threading","text":"Subroutine Threading (STC) is like DTC in that the CPU jumps directly to the Code Field of a Forth word. Only now there is no NEXT code, no IP register, and no W register. So, there is no choice but to use a JSR in the Code Field, since this is the only way to obtain the Parameter Field Address. This process is illustrated in Figure 5 . Figure 5. Subroutine Threaded Code The high-level \"thread\" is a series of subroutine calls being executed by the CPU. When the JSR DEUX is executed, the address of the next instruction in the thread is pushed onto the Return Stack. Then, the JSR DOCON within the word DEUX is executed, which causes another return address -- the PFA of DEUX -- to be pushed onto the Return Stack. DOCON can pop that address, use it to fetch the constant, stack the constant, and then do an RTS to return to the thread: DOCON: PULS X ; pop the PFA from the Return Stack LDD ,X ; fetch the Parameter Field cell PSHU D ; push that on the Parameter Stack RTS ; do the next high-level word We can still speak of a Code Field and a Parameter Field in Subroutine-Threaded Code. In every \"class\" of Forth word except CODE and colon definitions, the Code Field is the space occupied by a JSR or CALL instruction (just like DTC), and the Parameter Field is what follows. So, on the 6809, the PFA would equal CFA+3. The meaning of \"Parameter Field\" becomes somewhat fuzzy in CODE and colon definitions, as will be seen in future articles.","title":"Subroutine Threading"},{"location":"moving3.html#the-special-case-code-words","text":"There is a significant exception to all of the above generalizations. This is CODE definitions -- Forth words that are defined as a machine code subroutine. This wonderful capability is trivially easy to implement in Forth, since every Forth word executes some piece of machine code! The machine code comprising a CODE word is always contained in the body of the Forth word. In an Indirect-Threaded Forth, the Code Field must contain the address of the machine code to be executed. So the machine code is placed in the Parameter Field, and the Code Field contains the address of the Parameter Field, as shown in Figure 6 . Figure 6. Code Words In Direct- and Subroutine-Threaded Forths, we could -- by analogy -- put, in the Code Field, a JUMP to the Parameter Field. But this would be pointless, since the Parameter Field immediately follows the Code Field! The Code Field could be filled with NOPs for the same result. Better still, the machine code could be started at the Code Field, and continued into the Parameter Field. At this point the distinction of \"Code Field\" and \"Parameter Field\" breaks down. This is no problem, because we don't need this distinction for CODE words. (This does have ramifications for decompilers and certain clever programming tricks, none of which concern us here.) CODE words -- whatever the implementation -- are the one case where the machine code \"action\" routine does not need to be passed the Parameter Field address. The Parameter Field contains, not data, but the code being executed! Only NEXT needs to know this address (or the Code Field Address), so it can jump to the machine code.","title":"THE SPECIAL CASE: CODE WORDS"},{"location":"moving3.html#using-code","text":"Three questions remain unanswered: a. how do we create a new Forth word that has some arbitrary data in its Parameter Field? b. how do we change the Code Field of that word, to point to some machine code of our choosing? c. how do we compile (assemble) this machine code fragment, which exists in isolation from the words using it? The answer to (a) is: we write a Forth word to do this. Since this word, when executed, will define (create) a new word in the Forth dictionary, it is called a \"defining word.\" CONSTANT is one example of a defining word. All of the \"hard work\" of a defining word is done by a kernel word, CREATE, which parses a name from the input stream, builds the header and Code Field for a new word, and links it into the dictionary. (In fig-Forth this word is called \\<BUILDS.) All that remains for the programmer is to build the Parameter Field. The answer to (b) and (c) is embodied in two convoluted words called (;CODE) and ;CODE respectively. To understand how they work, let's look at how the defining word CONSTANT is actually written in Forth. Using the original ITC 6809 example: : CONSTANT ( n -- ) CREATE \\ create the new word , \\ append the TOS value to the dictionary, \\ as the 1st cell of the Parameter Field ;CODE \\ end high-level & start assembler code LDD 2,X \\ the code fragment DOCON PSHU D \\ \" \" \" \" NEXT \\ \" \" \" \" END-CODE There are two parts to this Forth word. Everything from : CONSTANT to ;CODE is the high-level Forth code executed when the word CONSTANT is invoked. Everything from ;CODE to END-CODE is machine code executed when the \"children\" of CONSTANT -- the \"constant-class\" words such as UN and DEUX -- are executed. That is, everything from ;CODE to END-CODE is the code fragment to which constant-type words will point. The name ;CODE signifies that it ends a high-level definition (\";\") and begins a machine- code definition (\"CODE\"). However, this is not put into the dictionary as two separate words. Everything from : CONSTANT to END-CODE is contained in the Parameter Field of CONSTANT, as shown in Figure 7 . Figure 7. ITC ;CODE Derick and Baker [DER82] name three \"sequences\" that help to understand the action of defining words: Sequence 1 is when the word CONSTANT is being defined . This involves both the high-level compiler (for the first part) and the Forth assembler (for the second part). This is when the definition of CONSTANT shown in Figure 7 is added to the dictionary. As we will see shortly, ;CODE -- a compiler directive -- is executed during Sequence 1. Sequence 2 is when the word CONSTANT is being executed , and when some constant-type word is being defined. In the example 2 CONSTANT DEUX Sequence 2 is when the word CONSTANT executes, and the word DEUX is added to the dictionary (as shown in Figure 7 ). During Sequence 2, the high-level part of CONSTANT is executed, including the word (;CODE). Sequence 3 is when the constant-type word is executed. In our example, Sequence 3 is when DEUX is executed to push the value 2 onto the stack. This is when the machine-code part of CONSTANT is executed. (Recall that this fragment is the Code Field action of DEUX.) The words ;CODE and (;CODE) do the following: ;CODE is executed during Sequence 1, when CONSTANT is compiled. This is an example of a Forth IMMEDIATE word -- a word executed during the Forth compilation. ;CODE does three things: a. it compiles the Forth word (;CODE) into CONSTANT, b. it turns off the Forth compiler, and c. it turns on the Forth assembler. (;CODE) is part of the word CONSTANT, so it executes when CONSTANT executes (Sequence 2). It performs the following actions: a. It gets the address of the machine code that immediately follows. This is done by popping IP from the Forth Return Stack. b. It puts that address into the Code Field of the word just defined by CREATE. The Forth word LAST (sometimes LATEST) gets the address of that word. c. It does the action of EXIT (a.k.a. ;S) so that the Forth inner interpreter doesn't try to execute the machine code that follows as part of the Forth thread. This is the high-level \"subroutine return\" which ends a Forth thread. F83 [LAX84] illustrates how these are typically coded in Forth: : ;CODE COMPILE (;CODE) \\ compiles (;CODE) into definition ?CSP [COMPILE] [ \\ turns off the Forth compiler REVEAL \\ (just like \";\" does) ASSEMBLER \\ turns on the assembler ; IMMEDIATE \\ this is an IMMEDIATE word! : (;CODE) R> \\ pops the adrs of the machine code LAST @ NAME> \\ gets the CFA of the latest word ! \\ stores the code address in the ; \\ Code Field (;CODE) is the more subtle of the two. Since it is a high-level Forth definition, the address following it in the CONSTANT thread -- the high-level \"return address\" -- is pushed onto Forth's Return Stack. So, popping the Return Stack while within (;CODE) will yield the address of the machine code that follows. Also, popping this value from the Return Stack will \"bypass\" one level of high-level subroutine return, so that when (;CODE) exits, it will exit to the caller of CONSTANT. This is equivalent to returning to CONSTANT, and then having CONSTANT return immediately. Use Figure 7 and walk through the execution of the words CONSTANT and (;CODE) to see how this works.","title":"USING ;CODE"},{"location":"moving3.html#direct-and-subroutine-threading","text":"For DTC and STC, the action of ;CODE and (;CODE) is identical to ITC, with one important exception: instead of holding an address, the Code Field holds a JUMP or CALL instruction. For an absolute JUMP or CALL, probably the only difference is that the address has to be stored at the end of the Code Field, as the operand of the JUMP or CALL instruction. In the case of the 6809, the address would be stored as the last two bytes of the three-byte JSR instruction. But some Forths, such as Pygmy Forth on the 8086, use a relative branch in the code field. In this case, the relative offset must be computed and inserted into the branch instruction.","title":"Direct and Subroutine Threading"},{"location":"moving3.html#high-level-forth-actions","text":"We have seen how to make a Forth word execute a chosen fragment of machine language code, and how to pass that fragment the address of the word's Parameter Field. But how do we write the \"action routine\" in high-level Forth? Every Forth word must -- by the action of NEXT -- execute some machine language routine. This is what the Code Field is all about. Therefore, a machine language routine, or a set of routines, is needed to handle the problems of invoking a high- level action. We'll call this routine DODOES. There are three problems to be solved: a. how do we find the address of the high-level action routine associated with this Forth word? b. how do we, from machine code, invoke the Forth interpreter for a high-level action routine? c. how do we pass that routine the address of the Parameter Field for the word we are executing? The answer to (c) -- how do you pass an argument to a high-level Forth routine -- is easy. On the Parameter Stack, of course. Our machine language routine must push the Parameter Field Address on the stack before it invokes the high level routine. (From our previous work, we know how the machine language routine can obtain the PFA.) The answer to (b) is a bit more difficult. Basically, we want to do something like the Forth word EXECUTE, which invokes a Forth word; or perhaps ENTER, which invokes a colon definition. Both are among our \"key\" kernel words. The DODOES code will resemble these. Question (a) is the tricky one. Where to put the address of the high-level routine? Remember, the Code Field does not point to high-level code; it must point to machine code. Two approaches have been used in the past:","title":"HIGH-LEVEL FORTH ACTIONS"},{"location":"moving3.html#1-the-fig-forth-solution","text":"Fig-Forth reserved the first cell of the Parameter Field to hold the address of the high-level code. The DODOES routine then obtained the Parameter Field address, pushed the address of the actual data (typically PFA+2) onto the stack, fetched the address of the high-level routine, and EXECUTEd. There were two problems with this approach. First, the structure of the Parameter Field was different for machine-code actions and high-level actions. For example, a CONSTANT defined with a machine code action would have its data stored at PFA, but a CONSTANT defined with a high-level action would have its data stored at (typically) PFA+2. Second, every instance of a high-level-action class carried an additional overhead of one cell. That is, if CONSTANT used a high-level action, every constant defined in the program was one cell larger! Fortunately, clever Forth programmers quickly devised a solution which overcame these problems, and the fig-Forth approach has fallen into disuse.","title":"1. The fig-Forth solution"},{"location":"moving3.html#2-the-modern-solution","text":"Most Forths nowadays associate a different machine language fragment with each high-level action routine. So, a high-level constant would have its Code Field pointing to a machine language fragment whose sole function is to invoke the high-level action of CONSTANT. A high-level variable's Code Field would point to the \"startup\" routine for the high-level VARIABLE action, and so on. Is this excessive duplication of code? No, because each of these machine-language fragments is just a subroutine call to a common startup routine, DODOES. (This is different from the fig-Forth DODOES routine.) The address of the high-level code to DODOES is passed as an \"inline\" subroutine parameter. That is, the address of the high-level code is put immediately after the JSR/CALL instruction. DODOES can then pop the CPU stack and do a fetch to obtain this address. Actually, we make two more simplifications. The high-level code itself is put immediately after the JSR/CALL instruction. Then DODOES pops the CPU stack, and obtains this address directly. And since we know this is high-level Forth code, we dispense with its Code Field and just compile the high-level thread...essentially incorporating the action of ENTER into DODOES. Now each \"defined\" word just points to a bit of machine code...no space is consumed in its Parameter Field. This bit of machine code is a JSR or CALL instruction, followed by the high-level action routine. In the 6809 example, we have traded two bytes in every constant for a three-byte JSR that appears only once. This is undoubtedly the most convoluted program logic in the entire Forth kernel! So, let's see how this is implemented in practice, using our trusty ITC 6809 example. Figure 8. ITC DODOES Figure 8 shows the constant DEUX implemented with a high-level action. When the Forth interpreter encounters DEUX -- that is, when the Forth IP is at IP(1) -- it does the usual thing: it fetches the address contained in DEUX's Code Field, and jumps to that address. At that address is a JSR DODOES instruction, so a second jump -- this time a subroutine call -- is immediately taken. DODOES must then perform the following actions: a. Push the address of DEUX's Parameter Field onto the Parameter Stack, for later use by the high-level action routine. Since the JSR instruction does not alter any registers, we expect to find the Parameter Field Address of DEUX (or a \"nearby\" address) still in the W register. b. Obtain the address of the high-level action routine, by popping the CPU stack. (Recall that popping the CPU stack will give the address of whatever immediately follows the JSR instruction.) This is a high-level thread , i.e., the Parameter Field part of a colon definition. c. Save the old value of Forth's Instruction Pointer -- IP(2) -- on Forth's Return Stack, since the IP register will be used to execute the high-level fragment. Essentially, DODOES must \"nest\" the IP, just like ENTER does. Remember that Forth's Return Stack may not be the same as the CPU subroutine stack. d. Put the address of the high-level thread into IP. This is IP(3) in Figure 8 . e. Do a NEXT to continue high-level interpretation at the new location. Assume an indirect-threaded ITC 6809, and the following: W is not incremented by NEXT (i.e., W will contain the CFA of the word entered by NEXT); the 6809 S is Forth's PSP, and U is Forth's RSP (i.e., the CPU stack is not Forth's Return Stack); the 6809 Y is Forth's IP, and X is Forth's W. Recall the definition of NEXT for these conditions: NEXT: LDX ,Y++ ; (IP) -> W, and IP+2 -> IP JMP [,X] ; (W) -> temp, JMP (temp) DODOES can be written as follows: DODOES: LEAX 2,X ; make W point to the Parameter Field PSHU Y ; (c) push old IP onto the Return Stack PULS Y ; (b,d) pop new IP from the CPU stack PSHS X ; (a) push W (the Parameter Field ; Address) onto the Parameter Stack NEXT ; (e) invoke high-level interpreter These operations are slightly out of sequence. As long as the right things go onto the right stacks (or into the right registers) at the right time, the exact order of operations is not critical. In this case, we're taking advantage of the fact that the old IP can be pushed onto Forth's Return Stack before the new IP is popped from the CPU stack. On some processors the CPU stack is used as Forth's Return Stack. In this case, one step involving temporary storage is necessary. If we had chosen S=RSP and U=PSP above, DODOES would be: DODOES: LEAX 2,X ; make W point to the Parameter Field PSHU X ; (a) push W (the Parameter Field ; Address) onto the Parameter Stack PULS X ; (b) pop thread address from CPU stack PSHS Y ; (c) push old IP onto the Return Stack TFR X,Y ; (d) put thread address into IP NEXT ; (e) invoke high-level interpreter Since we are essentially swapping the top of the Return/CPU stack with IP, we need to use X as a temporary holding register. Thus we must push the PFA -- step (a) -- before re-using the X register. Walk through both of these DODOES examples step by step, and track the contents of the registers and the two stacks. I always walk through my DODOES routine, just to make sure I'm not clobbering a register at the wrong time.","title":"2. The modern solution"},{"location":"moving3.html#direct-threading_1","text":"The logic of DODOES is the same in DTC Forths. But the implementation may be different, depending on whether the DTC Forth uses a JMP or a CALL in the Code Field of a word. a. JMP in Code Field. A DTC Forth can use a JMP in the Code Field if the address of the word being executed is found in a register. This will most likely be the Code Field Address. From the point of view of DODOES, this is identical to ITC. In our example, DODOES sees that the Forth interpreter jumps to the machine code associated with DEUX, and that code is a JSR to DODOES. It doesn't matter that the first jump is now a direct jump rather than an indirect jump; the register and stack contents are the same. So, the code for DODOES will be identical to that for ITC. (Of course, NEXT is different, and W may need a different offset to point to the Parameter Field.) b. CALL/JSR in Code Field. In the DTC 6809, we never explicitly fetch the CFA of the word being executed, so the Forth word must contain a JSR in its Code Field. Instead of finding the Parameter Field Address of the Forth word in a register, we find it on the CPU stack. Figure 9. DTC DODOES The DEUX example in this case is shown in Figure 9 . When the Forth IP is at IP(1), the Forth interpreter jumps to the Code Field of DEUX (and increments IP). In the Code Field is a JSR to DEUX's machine code fragment. At that address is a second JSR, to DODOES. So two things get pushed onto the CPU stack. The return address of the first JSR is the Parameter Field address of DEUX. The return address of the second JSR -- and thus topmost on the CPU stack -- is the address of the high-level thread to be executed. DODOES must ensure that the old IP is pushed onto the Return Stack, the PFA of DEUX is pushed onto the Parameter Stack, and the address of the high-level thread is loaded into IP. This is very sensitive to stack assignments! For S=PSP (CPU stack) and U=RSP, the NEXT and DODOES code is: NEXT: LDX [,Y++] ; (IP) -> temp, IP+2 -> IP, JMP (temp) DODOES: PSHU Y ; push old IP onto the Return Stack PULS Y ; pop new IP from the CPU stack ; note: the CPU stack is the Parameter Stack, and the ; topmost element is now the PFA of the word... ; exactly what we want! NEXT ; invoke high-level interpreter Check for yourself that the flow through NEXT, DEUX, and DODOES pushes a net total of one item -- the PFA of DEUX -- onto the Parameter Stack!","title":"Direct Threading"},{"location":"moving3.html#subroutine-threading_1","text":"In STC Forths, there are no IP or W registers, and a high-level \"thread\" is pure machine code (a series of subroutine calls). The only difference between a high-level action and a ;CODE action is that the PFA of the \"defined\" word must be pushed onto the Parameter Stack. \"Defined\" words have a CALL/JSR in the Code Field, and the CPU stack must be Forth's Return Stack, so DODOES is mostly a matter of stack manipulations. Figure 10. STC DODOES Figure 10 shows a 6809 STC example of DEUX with a high-level action. By the time DODOES is entered, three things have been pushed onto the CPU/Return Stack: the return address in the \"main\" thread, the PFA of DEUX, and the address of DEUX's high-level action code. DODOES must pop the last two, push the PFA onto the Parameter Stack, and jump to the action code: DODOES: PULS X,Y ; action code adrs -> X, PFA -> Y PSHU Y ; push PFA onto Parameter Stack JMP ,X ; jump to the action code DODOES for the 6809 is now a three-instruction routine. It can be simplified even further by \"expanding JSR DODOES in-line\", i.e., replacing the JSR DODOES with the equivalent machine code instructions. Since there's one less JSR, this simplifies the stack manipulation to: PULS X ; pop PFA from CPU stack PSHU X ; and push it onto the Parameter Stack ...high level thread for DEUX... This replaces a three-byte JSR with four bytes of explicit code, with a considerable improvement in speed. For the 6809 this would probably be a good choice. For a processor like the 8051, DODOES is long enough that it should be kept as a subroutine.","title":"Subroutine Threading"},{"location":"moving3.html#using-does","text":"We learned with ;CODE how to create a new Forth word with arbitrary data in its parameter field, and how to make that word's Code Field point to a new machine code fragment. How do we compile a high-level action routine, and make a new word point to it? The answer lies in the two words DOES> and (DOES>), which are the high-level equivalents of ;CODE and (;CODE). To understand them, let's look at an example of their use: : CONSTANT ( n -- ) CREATE \\ create the new word , \\ append the TOS value to the dictionary, \\ as the 1st cell of the Parameter Field DOES> \\ end \"create\" part & start \"action\" part @ \\ given the PFA, fetch its contents ; Compare this with the previous ;CODE example, and observe that DOES> performs a function analogous to ;CODE. Everything from : CONSTANT to DOES> is executed when the word CONSTANT is invoked. This is the code which builds the Parameter Field of the \"defined\" word. Everything from DOES> to ; is the high-level code executed when the \"children\" of CONSTANT (such as DEUX) are invoked, i.e., the high-level fragment to which the Code Field will point. (We'll see that a JSR DODOES is included before this high-level fragment.) Just as with ;CODE, both the \"create\" and the \"action\" clauses are contained within the body of the Forth word CONSTANT, as shown in Figure 11 . Figure 11. ITC DOES> Recall Sequence 1, 2, and 3. The words DOES> and (DOES>) do the following: DOES> is executed during Sequence 1, when CONSTANT is compiled. Thus DOES> is a Forth IMMEDIATE word. It does two things: a. It compiles the Forth word (DOES>) into CONSTANT. b. It compiles a JSR DODOES into CONSTANT. Note that DOES> leaves the Forth compiler running, in order to compile the high-level fragment which follows. Also, even though JSR DODOES is not itself Forth code, an IMMEDIATE word such as DOES> can cause it to be compiled in the middle of Forth code. (DOES>) is part of the word CONSTANT, so it executes when CONSTANT executes (Sequence 2). It does the following: a. It gets the address of the machine code that immediately follows (JSR DODOES), by popping IP from the Forth Return Stack. b. It puts that address into the Code Field of the word just defined by CREATE. c. It performs the action of EXIT, causing CONSTANT to terminate here and not attempt to execute the fragment that follows. The action of (DOES>) is identical to (;CODE)! A separate word is not strictly required. F83, for example, uses (;CODE) in both ;CODE and DOES>. I'll use (;CODE) from now on instead of (DOES>). You've already seen the workings of (;CODE). The F83 definition of DOES> is : DOES> COMPILE (;CODE) \\ compiles (;CODE) into definition 0E8 C, \\ the CALL opcode byte DODOES HERE 2+ - , \\ the relative offset to DODOES ; IMMEDIATE where DODOES is a constant which holds the address of the DODOES routine. (The actual F83 source code is slightly different, due to the requirements of the F83 metacompiler.) DOES> need not fiddle with CSP or the smudge bit, since the Forth compiler is left \"on.\" In the case of the 8086, the CALL instruction expects a relative address...hence the arithmetic involving DODOES and HERE. In the 6809, DOES> would look like : DOES> COMPILE (;CODE) \\ compiles (;CODE) into definition 0BD C, \\ the JSR Extended opcode byte DODOES , \\ the operand: address of DODOES ; IMMEDIATE You can see here how the machine language JSR DODOES is compiled after the high-level (;CODE), and before the high-level \"action\" code.","title":"USING DOES>"},{"location":"moving3.html#direct-and-subroutine-threading_1","text":"The only difference in DTC and STC is how the Code Field is fiddled to point to a new routine. This is done by (;CODE), and the required changes have already been described. DOES> isn't affected at all, unless you're writing an STC Forth and expanding the JSR DODOES to explicit machine code. In this case, DOES> is modified to assemble the \"in-line\" machine code instead of a JSR DODOES instruction.","title":"Direct and Subroutine Threading"},{"location":"moving3.html#onward-and-upward","text":"Who would have thought that so few lines of code would require so much explanation? This is why I admire ;CODE and DOES> so much...I've never before seen seen such intricate, powerful, and flexible constructs coded with such economy. In the next installment I'll discuss the merits of assemblers vs. metacompilers, and provide the actual CODE definitions for our Forth example systems.","title":"ONWARD AND UPWARD"},{"location":"moving3.html#references","text":"[DER82] Derick, Mitch and Baker, Linda, Forth Encyclopedia , Mountain View Press (1982). A word-by-word description of fig-Forth in minute detail. Still available from the Forth Interest Group, P.O. Box 2154, Oakland CA 94621. [LAX84] Laxen, H. and Perry, M., F83 for the IBM PC , version 2.1.0 (1984). Distributed by the authors, available from the Forth Interest Group or GEnie. Author's note for web publication: the files formerly available on the GEnie online service are now available from the Forth Interest Group FTP server, ftp://ftp.forth.org/pub/Forth .","title":"REFERENCES"},{"location":"moving4.html","text":"MOVING FORTH 4 Part 4: Assemble or Metacompile? by Brad Rodriguez This article first appeared in The Computer Journal #64 (November/December 1993) . \"Keep it SHORT!\" was the editorial directive for this installment. So I apologize for postponing the source listings to yet another issue. In the meantime, there is a new decision to contemplate: How do you build a Forth system for the Very First Time? You know now that most Forth code is high-level \"threads,\" usually compiled as just a series of addresses. In the early days of fig-Forth, assemblers were often the only programming tools available. This was fine for writing Forth CODE words, but high- level threads had to be written as a series of DW directives. For example, the Forth word : MAX ( n n - n) OVER OVER < IF SWAP THEN DROP ; would be written [TAL80] DW OVER,OVER,LESS,ZBRAN DW MAX2-$ DW SWAP MAX2: DW DROP,SEMIS Later, as working Forth systems became widespread, Forthwrights began modifying the Forth compilers into cross-compilers [CAS80]. Thus with Forth on your CP/M machine (or Apple II, or whatever), you could write Forth programs for some other CPU...up to and including an entirely new Forth system for that CPU. Because they create a new Forth from within Forth, these are often called metacompilers. Computer science purists object to this, so some Forthies use the terms \"cross-compiler\" and \"recompiler.\" The difference is that a recompiler can only generate a new Forth for the same CPU. Most PC Forths are now produced with metacompilers, but opinion is divided in the embedded systems arena [TIN91,ROD91,SER91]. The arguments for using assemblers to write Forth are: Metacompilers are cryptic and hard to understand, and you must thoroughly understand a metacompiler in order to use it. Assemblers are understood by the average programmer. An assembler is almost always available for a new CPU. Assemblers handle many optimizations (e.g. short vs. long branch). Assemblers handle forward references and peculiar address modes; many metacompilers don't. Assemblers use familiar editing and debugging tools. The code generation is completely visible -- nothing is \"hidden\" from the programmer. It's easier to tweak the Forth model, since many design decisions affect the internals of a metacompiler. The arguments for metacompilers: You write \"normal\" looking Forth code, which is easier to read and debug. Once you understand your metacompiler, you can port it easily to new CPUs. The only tool you need to acquire is a Forth for your computer. The last is particularly applicable to those who don't own PCs, since most cross-assemblers require PCs or workstations these days. I've written several Forths each way, so I'm painfully aware of the tradeoffs. I admit a preference for metacompilers: I find the Forth code for MAX much easier to read and understand than its assembler equivalent. Most of the arguments against metacompilers have been overcome by modern \"professional\" compilers, and if you're using Forth for work I strongly recommend investing in a commercial product. Alas, public-domain metacompilers (including my own) are still behind the times, clunky, and arcane. So I'm going to take a radical position for a Forth programmer, and tell you to choose for yourself . I'll publish the 6809 code in metacompiler form, and I'll supply a metacompiler for F83 (IBM PC, CP/M, or Atari ST) [ROD92]. The Z80 code will be written for a CP/M assembler. The 8051 code will be written for a public-domain PC cross-assembler. Forth in C? No discussion of this topic would be complete without mentioning a new trend: Forths written in C. These have the advantage of being more portable than assembler -- in theory, all you have to do is recompile the same source code for any CPU. The disadvantages: Less flexibility in the design decisions; e.g., direct-threaded code is probably not possible, and you can't optimize register assignments. You have to recompile the C source to add new primitives. Forth words carry the C call-and-return overhead. Some C Forths use inefficient threading techniques, e.g. a CASE statement. Most C compilers produce less efficient code than a good assembly-language programmer. But for Unix systems and RISC workstations, which frown upon assembler, this may be the only way to get a Forth up and running. The most complete and widely used of the public-domain C Forths [at the time of publication] is TILE (TILE_21.ZIP, file #2263 on GEnie's Forth Roundtable). If you're not running Unix, you should look instead at the Genie files HENCE4TH_1.2.A (#2490) and CFORTHU.ARC (#2079). To continue the previous comparison, here's the definition of MAX from HENCE4TH [MIS90]. I omit the dictionary headers for clarity: _max() { OVER OVER LESS IF SWAP ENDIF DROP } Instead of assembler, C is used to write the CODE words in the kernel. For example, here is HENCE4TH's SWAP: _swap() { register cell i = *(dsp); *(dsp) = *(dsp + 1); *(dsp + 1) = i; } (Please note: there is quite a variety of techniques for writing Forth words in C, so these words may appear radically different in CFORTH or TILE.) On a 68000 or SPARC, this might produce quite good code. On a Z80 or 8051, quite the opposite. But even if you plan to write a Forth in C, you need to understand how Forth works in assembler. So stay tuned for the next installment of Moving Forth! REFERENCES [CAS80] Cassady, John J., METAFORTH: A Metacompiler for Fig- Forth , Forth Interest Group (1980). [MIS90] HenceFORTH in C , Version 1.2, distributed by The Missing Link, 975 East Ave. Suite 112, Chico, CA 95926, USA (1990). This is a shareware product available from the GEnie Forth Roundtable. [ROD91] Rodriguez, B.J., letter to the editor, Forth Dimensions XIII:3 (Sep/Oct 1991), p.5. [ROD92] Rodriguez, B.J., \"Principles of Metacompilation,\" Forth Dimensions XIV:3 (Sep/Oct 1992), XIV:4 (Nov/Dec 1992), and XIV:5 (Jan/Feb 1993). Note that the published code is for a fig-Forth variant and not F83. The F83 version is on GEnie as CHROMIUM.ZIP [SER91] Sergeant, Frank, \"Metacompilation Made Easy,\" Forth Dimensions XII:6 (Mar/Apr 1991). [TAL80] Talbot, R.J., fig-Forth for 6809 , Forth Interest Group, P.O. Box 2154, Oakland, CA 94621 (1980). [TIN91] Ting, C.H., \"How Metacompilation Stops the Growth Rate of Forth Programmers,\" Forth Dimensions XIII:1 (May/Jun 1991), p.17. Author's note for web publication: the files formerly available on the GEnie online service are now available from the Forth Interest Group FTP server, ftp://ftp.forth.org/pub/Forth . Also, several new Forths-in-C have been published since this article was first written. Consult the \"systems\" FAQ at ftp://ftp.forth.org/pub/Forth/FAQ for a current list.","title":"MOVING FORTH 4"},{"location":"moving4.html#moving-forth-4","text":"Part 4: Assemble or Metacompile? by Brad Rodriguez This article first appeared in The Computer Journal #64 (November/December 1993) . \"Keep it SHORT!\" was the editorial directive for this installment. So I apologize for postponing the source listings to yet another issue. In the meantime, there is a new decision to contemplate:","title":"MOVING FORTH 4"},{"location":"moving4.html#how-do-you-build-a-forth-system-for-the-very-first-time","text":"You know now that most Forth code is high-level \"threads,\" usually compiled as just a series of addresses. In the early days of fig-Forth, assemblers were often the only programming tools available. This was fine for writing Forth CODE words, but high- level threads had to be written as a series of DW directives. For example, the Forth word : MAX ( n n - n) OVER OVER < IF SWAP THEN DROP ; would be written [TAL80] DW OVER,OVER,LESS,ZBRAN DW MAX2-$ DW SWAP MAX2: DW DROP,SEMIS Later, as working Forth systems became widespread, Forthwrights began modifying the Forth compilers into cross-compilers [CAS80]. Thus with Forth on your CP/M machine (or Apple II, or whatever), you could write Forth programs for some other CPU...up to and including an entirely new Forth system for that CPU. Because they create a new Forth from within Forth, these are often called metacompilers. Computer science purists object to this, so some Forthies use the terms \"cross-compiler\" and \"recompiler.\" The difference is that a recompiler can only generate a new Forth for the same CPU. Most PC Forths are now produced with metacompilers, but opinion is divided in the embedded systems arena [TIN91,ROD91,SER91]. The arguments for using assemblers to write Forth are: Metacompilers are cryptic and hard to understand, and you must thoroughly understand a metacompiler in order to use it. Assemblers are understood by the average programmer. An assembler is almost always available for a new CPU. Assemblers handle many optimizations (e.g. short vs. long branch). Assemblers handle forward references and peculiar address modes; many metacompilers don't. Assemblers use familiar editing and debugging tools. The code generation is completely visible -- nothing is \"hidden\" from the programmer. It's easier to tweak the Forth model, since many design decisions affect the internals of a metacompiler. The arguments for metacompilers: You write \"normal\" looking Forth code, which is easier to read and debug. Once you understand your metacompiler, you can port it easily to new CPUs. The only tool you need to acquire is a Forth for your computer. The last is particularly applicable to those who don't own PCs, since most cross-assemblers require PCs or workstations these days. I've written several Forths each way, so I'm painfully aware of the tradeoffs. I admit a preference for metacompilers: I find the Forth code for MAX much easier to read and understand than its assembler equivalent. Most of the arguments against metacompilers have been overcome by modern \"professional\" compilers, and if you're using Forth for work I strongly recommend investing in a commercial product. Alas, public-domain metacompilers (including my own) are still behind the times, clunky, and arcane. So I'm going to take a radical position for a Forth programmer, and tell you to choose for yourself . I'll publish the 6809 code in metacompiler form, and I'll supply a metacompiler for F83 (IBM PC, CP/M, or Atari ST) [ROD92]. The Z80 code will be written for a CP/M assembler. The 8051 code will be written for a public-domain PC cross-assembler. Forth in C? No discussion of this topic would be complete without mentioning a new trend: Forths written in C. These have the advantage of being more portable than assembler -- in theory, all you have to do is recompile the same source code for any CPU. The disadvantages: Less flexibility in the design decisions; e.g., direct-threaded code is probably not possible, and you can't optimize register assignments. You have to recompile the C source to add new primitives. Forth words carry the C call-and-return overhead. Some C Forths use inefficient threading techniques, e.g. a CASE statement. Most C compilers produce less efficient code than a good assembly-language programmer. But for Unix systems and RISC workstations, which frown upon assembler, this may be the only way to get a Forth up and running. The most complete and widely used of the public-domain C Forths [at the time of publication] is TILE (TILE_21.ZIP, file #2263 on GEnie's Forth Roundtable). If you're not running Unix, you should look instead at the Genie files HENCE4TH_1.2.A (#2490) and CFORTHU.ARC (#2079). To continue the previous comparison, here's the definition of MAX from HENCE4TH [MIS90]. I omit the dictionary headers for clarity: _max() { OVER OVER LESS IF SWAP ENDIF DROP } Instead of assembler, C is used to write the CODE words in the kernel. For example, here is HENCE4TH's SWAP: _swap() { register cell i = *(dsp); *(dsp) = *(dsp + 1); *(dsp + 1) = i; } (Please note: there is quite a variety of techniques for writing Forth words in C, so these words may appear radically different in CFORTH or TILE.) On a 68000 or SPARC, this might produce quite good code. On a Z80 or 8051, quite the opposite. But even if you plan to write a Forth in C, you need to understand how Forth works in assembler. So stay tuned for the next installment of Moving Forth! REFERENCES [CAS80] Cassady, John J., METAFORTH: A Metacompiler for Fig- Forth , Forth Interest Group (1980). [MIS90] HenceFORTH in C , Version 1.2, distributed by The Missing Link, 975 East Ave. Suite 112, Chico, CA 95926, USA (1990). This is a shareware product available from the GEnie Forth Roundtable. [ROD91] Rodriguez, B.J., letter to the editor, Forth Dimensions XIII:3 (Sep/Oct 1991), p.5. [ROD92] Rodriguez, B.J., \"Principles of Metacompilation,\" Forth Dimensions XIV:3 (Sep/Oct 1992), XIV:4 (Nov/Dec 1992), and XIV:5 (Jan/Feb 1993). Note that the published code is for a fig-Forth variant and not F83. The F83 version is on GEnie as CHROMIUM.ZIP [SER91] Sergeant, Frank, \"Metacompilation Made Easy,\" Forth Dimensions XII:6 (Mar/Apr 1991). [TAL80] Talbot, R.J., fig-Forth for 6809 , Forth Interest Group, P.O. Box 2154, Oakland, CA 94621 (1980). [TIN91] Ting, C.H., \"How Metacompilation Stops the Growth Rate of Forth Programmers,\" Forth Dimensions XIII:1 (May/Jun 1991), p.17. Author's note for web publication: the files formerly available on the GEnie online service are now available from the Forth Interest Group FTP server, ftp://ftp.forth.org/pub/Forth . Also, several new Forths-in-C have been published since this article was first written. Consult the \"systems\" FAQ at ftp://ftp.forth.org/pub/Forth/FAQ for a current list.","title":"How do you build a Forth system for the Very First Time?"},{"location":"moving5.html","text":"MOVING FORTH 5 Part 5: The Z80 Primitives by Brad Rodriguez This article first appeared in The Computer Journal #67 (May/June 1994) . THE CODE I PROMISED At long last, I am ready to present the complete source code for an (I hope) ANSI compliant Forth, CamelForth [1]. As an intellectual exercise -- and to ensure a clear copyright -- I've written this code entirely from scratch. (Do you know how hard it is to not look at excellent code examples?) Of course, my experience with various Forths has no doubt influenced some design decisions. Due to space limitations, the source code will be presented in four installments (if you can't wait, complete files will be on GEnie): Z80 Forth \"primitives,\" in assembler source 8051 Forth \"primitives,\" likewise Z80/8051 high-level kernel, likewise complete 6809 kernel, in metacompiler source For CamelForth I'm trying to use exclusively public-domain tools: for the Z80, the Z80MR assembler under CP/M [3]; for the 8051, the A51 cross-assembler on an IBM PC [4], and for the 6809, my own metacompiler under F83 for CP/M, IBM PC, or Atari ST. By \"kernel\" I mean the set of words that comprises a basic Forth system, including compiler and interpreter. For CamelForth this is the ANS Forth Core word set, plus any non-ANSI words necessary to implement the Core word set. A Forth kernel is usually written partly in machine code (as CODE words), and partly in high-level Forth. The words which are written in machine code are called the \"primitives,\" since, in the final analysis, the entire Forth system is defined in terms of just these words. Exactly which words should be written in machine code? The selection of the optimal set of primitives is an interesting debate. A smaller set of primitives makes for easier porting, but poorer performance. I've been told that a set of 13 primitives is sufficient to define all of Forth -- a very slow Forth. eForth [2], designed for easy porting, had a more generous set of 31 primitives. My rules are these: Fundamental arithmetic, logic, and memory operators are CODE. If a word can't be easily or efficiently written (or written at all) in terms of other Forth words, it should be CODE (e.g., U\\<, RSHIFT). If a simple word is used frequently, CODE may be worthwhile (e.g., NIP, TUCK). If a word requires fewer bytes when written in CODE, do so (a rule I learned from Charles Curley). If the processor includes instruction support for a word's function, put it in CODE (e.g. CMOVE or SCAN on a Z80 or 8086). If a word juggles many parameters on the stack, but has relatively simple logic, it may be better in CODE, where the parameters can be kept in registers. If the logic or control flow of a word is complex, it's probably better in high-level Forth. For Z80 CamelForth I have a set of about 70 primitives. (See Table 1 ) Having already decided on the Forth model and CPU usage (see my previous TCJ articles), I followed this development procedure: Select the subset of the ANSI Core word set which will be primitives. (Subject to revision, of course.) From the ANSI descriptions, write assembler definitions of these words, plus the processor initialization code. Run this through the assembler, fixing source code errors. Test that you can produce working machine code. I usually add a few lines of assembler code to output a character once the initialization is complete. This seemingly trivial test is crucial! It ensures that your hardware, assembler, \"downloader\" (EPROM emulator or whatever), and serial communications are all working! 5. (Embedded systems only) Add another assembler code fragment to read the serial port and echo it back...thus testing both directions of communications. Write a high-level Forth fragment to output a character, using only Forth primitives. (Usually something like \"LIT,33h,EMIT,BYE\") This tests the Forth register initialization, the stacks, and the threading mechanism. Problems at this stage can usually be traced to logic errors in NEXT or in the initialization, or data stack goofs (e.g. stack in ROM). Write a colon definition to output a character, and include it in the high-level fragment from step 6. (E.g., define BLIP as \"LIT,34h,EMIT,EXIT\" and then test the fragment \"LIT,33h,EMIT, BLIP,BYE\") Problems at this stage are usually with DOCOLON or EXIT logic, or return stack goofs. At this point you can write some tools to help you with debugging, such as words to display in hex a number on the stack. Listing 1 shows a simple test routine to do a never-ending memory dump (useful even if your keyboard doesn't work). This tests the primitives DUP, EMIT, EXIT, C@, >\\<, LIT, 1+, and BRANCH, as well as several levels of nesting. Plus, it doesn't use DO..LOOP, which are often difficult to get working. When this code works, you have some confidence that your basic Forth model is valid. From here on it's just testing the remaining primitives -- DO..LOOP, UM/MOD, UM*, and DODOES are particularly tricky -- and adding high-level definitions. I like to get a rudimentary interpreter going next, so that I can test words interactively. With this set of primitives you can begin writing Forth code. Sure, you have to use an assembler instead of a Forth compiler, but -- as Listing 1 suggests -- you can use high-level control flow and nesting to write useful code that would be more difficult to write in assembler. READ THE CODE! I've run out of abstractions for today. If you want to learn more about how a Forth kernel works and is written, study Listing 2 . It follows the Forth convention for documentation: WORD-NAME stack in -- stack out description WORD-NAME is the name by which Forth knows the word. Often these names include peculiar ASCII characters, so an approximation must be used when defining assembler labels (such as ONEPLUS for the Forth word 1+). stack in are the arguments this word expects to see on the stack, with the topmost stack item always on the right. stack out are the arguments this word will leave on the stack, likewise. If the word has a return stack effect (other than nesting, that is), an additional return stack comment will be added after \"R:\" stack in -- stack out R: stack in -- stack out ANSI Forth defines a number of useful abbreviations for stack arguments, such as \"n\" for a signed single-cell number, \"u\" for an unsigned single-cell number, \"c\" for a character, and so on. See Table 1 . REFERENCES [1] Definition of a camel: a horse designed by committee. [2] Ting, C. H., eForth Implementation Guide , July 1990, available from Offete Enterprises, 1306 South B Stret, San Mateo, CA 94402 USA. [3] Z80MR, a Z80 Macro Assembler by Mike Rubenstein, is public-domain, available on the GEnie CP/M Roundtable as file Z80MR-A.LBR. Warning: do not use the supplied Z1.COM program, use only Z80MR and LOAD. Z1 has a problem with conditional jumps. [4] A51, PseudoCorp's freeware Level 1 cross-assembler for the 8051, is available from the Realtime and Control Forth Board, (303) 278-0364, or on the GEnie Forth Roundtable as file A51.ZIP. PseudoCorp's commercial products are advertised here in TCJ. Source code for Z80 CamelForth is available on this site at http://www.camelforth.com/public_ftp/cam80-12.zip .","title":"MOVING FORTH 5"},{"location":"moving5.html#moving-forth-5","text":"Part 5: The Z80 Primitives by Brad Rodriguez This article first appeared in The Computer Journal #67 (May/June 1994) .","title":"MOVING FORTH 5"},{"location":"moving5.html#the-code-i-promised","text":"At long last, I am ready to present the complete source code for an (I hope) ANSI compliant Forth, CamelForth [1]. As an intellectual exercise -- and to ensure a clear copyright -- I've written this code entirely from scratch. (Do you know how hard it is to not look at excellent code examples?) Of course, my experience with various Forths has no doubt influenced some design decisions. Due to space limitations, the source code will be presented in four installments (if you can't wait, complete files will be on GEnie): Z80 Forth \"primitives,\" in assembler source 8051 Forth \"primitives,\" likewise Z80/8051 high-level kernel, likewise complete 6809 kernel, in metacompiler source For CamelForth I'm trying to use exclusively public-domain tools: for the Z80, the Z80MR assembler under CP/M [3]; for the 8051, the A51 cross-assembler on an IBM PC [4], and for the 6809, my own metacompiler under F83 for CP/M, IBM PC, or Atari ST. By \"kernel\" I mean the set of words that comprises a basic Forth system, including compiler and interpreter. For CamelForth this is the ANS Forth Core word set, plus any non-ANSI words necessary to implement the Core word set. A Forth kernel is usually written partly in machine code (as CODE words), and partly in high-level Forth. The words which are written in machine code are called the \"primitives,\" since, in the final analysis, the entire Forth system is defined in terms of just these words. Exactly which words should be written in machine code? The selection of the optimal set of primitives is an interesting debate. A smaller set of primitives makes for easier porting, but poorer performance. I've been told that a set of 13 primitives is sufficient to define all of Forth -- a very slow Forth. eForth [2], designed for easy porting, had a more generous set of 31 primitives. My rules are these: Fundamental arithmetic, logic, and memory operators are CODE. If a word can't be easily or efficiently written (or written at all) in terms of other Forth words, it should be CODE (e.g., U\\<, RSHIFT). If a simple word is used frequently, CODE may be worthwhile (e.g., NIP, TUCK). If a word requires fewer bytes when written in CODE, do so (a rule I learned from Charles Curley). If the processor includes instruction support for a word's function, put it in CODE (e.g. CMOVE or SCAN on a Z80 or 8086). If a word juggles many parameters on the stack, but has relatively simple logic, it may be better in CODE, where the parameters can be kept in registers. If the logic or control flow of a word is complex, it's probably better in high-level Forth. For Z80 CamelForth I have a set of about 70 primitives. (See Table 1 ) Having already decided on the Forth model and CPU usage (see my previous TCJ articles), I followed this development procedure: Select the subset of the ANSI Core word set which will be primitives. (Subject to revision, of course.) From the ANSI descriptions, write assembler definitions of these words, plus the processor initialization code. Run this through the assembler, fixing source code errors. Test that you can produce working machine code. I usually add a few lines of assembler code to output a character once the initialization is complete. This seemingly trivial test is crucial! It ensures that your hardware, assembler, \"downloader\" (EPROM emulator or whatever), and serial communications are all working! 5. (Embedded systems only) Add another assembler code fragment to read the serial port and echo it back...thus testing both directions of communications. Write a high-level Forth fragment to output a character, using only Forth primitives. (Usually something like \"LIT,33h,EMIT,BYE\") This tests the Forth register initialization, the stacks, and the threading mechanism. Problems at this stage can usually be traced to logic errors in NEXT or in the initialization, or data stack goofs (e.g. stack in ROM). Write a colon definition to output a character, and include it in the high-level fragment from step 6. (E.g., define BLIP as \"LIT,34h,EMIT,EXIT\" and then test the fragment \"LIT,33h,EMIT, BLIP,BYE\") Problems at this stage are usually with DOCOLON or EXIT logic, or return stack goofs. At this point you can write some tools to help you with debugging, such as words to display in hex a number on the stack. Listing 1 shows a simple test routine to do a never-ending memory dump (useful even if your keyboard doesn't work). This tests the primitives DUP, EMIT, EXIT, C@, >\\<, LIT, 1+, and BRANCH, as well as several levels of nesting. Plus, it doesn't use DO..LOOP, which are often difficult to get working. When this code works, you have some confidence that your basic Forth model is valid. From here on it's just testing the remaining primitives -- DO..LOOP, UM/MOD, UM*, and DODOES are particularly tricky -- and adding high-level definitions. I like to get a rudimentary interpreter going next, so that I can test words interactively. With this set of primitives you can begin writing Forth code. Sure, you have to use an assembler instead of a Forth compiler, but -- as Listing 1 suggests -- you can use high-level control flow and nesting to write useful code that would be more difficult to write in assembler.","title":"THE CODE I PROMISED"},{"location":"moving5.html#read-the-code","text":"I've run out of abstractions for today. If you want to learn more about how a Forth kernel works and is written, study Listing 2 . It follows the Forth convention for documentation: WORD-NAME stack in -- stack out description WORD-NAME is the name by which Forth knows the word. Often these names include peculiar ASCII characters, so an approximation must be used when defining assembler labels (such as ONEPLUS for the Forth word 1+). stack in are the arguments this word expects to see on the stack, with the topmost stack item always on the right. stack out are the arguments this word will leave on the stack, likewise. If the word has a return stack effect (other than nesting, that is), an additional return stack comment will be added after \"R:\" stack in -- stack out R: stack in -- stack out ANSI Forth defines a number of useful abbreviations for stack arguments, such as \"n\" for a signed single-cell number, \"u\" for an unsigned single-cell number, \"c\" for a character, and so on. See Table 1 .","title":"READ THE CODE!"},{"location":"moving5.html#references","text":"[1] Definition of a camel: a horse designed by committee. [2] Ting, C. H., eForth Implementation Guide , July 1990, available from Offete Enterprises, 1306 South B Stret, San Mateo, CA 94402 USA. [3] Z80MR, a Z80 Macro Assembler by Mike Rubenstein, is public-domain, available on the GEnie CP/M Roundtable as file Z80MR-A.LBR. Warning: do not use the supplied Z1.COM program, use only Z80MR and LOAD. Z1 has a problem with conditional jumps. [4] A51, PseudoCorp's freeware Level 1 cross-assembler for the 8051, is available from the Realtime and Control Forth Board, (303) 278-0364, or on the GEnie Forth Roundtable as file A51.ZIP. PseudoCorp's commercial products are advertised here in TCJ. Source code for Z80 CamelForth is available on this site at http://www.camelforth.com/public_ftp/cam80-12.zip .","title":"REFERENCES"},{"location":"moving6.html","text":"MOVING FORTH 6 Part 6: the Z80 high-level kernel by Brad Rodriguez This article first appeared in The Computer Journal #69 (September/October 1994) . ERRATA There are two goofs in the CAMEL80.AZM file I presented in TCJ#67. The minor goof is that the name length specified in the HEAD macro for the Forth word > was incorrectly typed as 2 instead of 1. The major goof results from a subtlety of CP/M console I/O. KEY must not echo the typed character, and so used BDOS function 6. KEY? used BDOS function 11 to test non-destructively for the presence of a keypress. Unfortunately, BDOS function 6 does not \"clear\" the keypress detected by function 11! I have now rewritten KEY? to use BDOS function 6 (see Listing 1 ). Since this is a \"destructive\" test, I had to add logic to save the \"consumed\" keypress and return it when KEY is next used. This new logic can be used whenever your hardware (or operating system) provides only a destructive test-for-keypress. HIGH LEVEL DEFINITIONS In the last installment I did not expound greatly on the source code. Each Forth \"primitive\" performs a miniscule, sharply-defined function. It was almost all Z80 assembler code, and if it wasn't obvious why a particular word was included, I hope it was clear what each word did. In this installment I have no such luxury: I will present the high level definitions which embody the elegant (and tortuous) logic of the Forth language. Entire books have been written [1,2,3] describing Forth kernels, and if you want complete mastery I highly recommend you buy one of them. For TCJ I'll limit myself to some of the key words of the compiler and interpreter, given in Listing 2 . TEXT INTERPRETER OPERATION The text or \"outer\" interpreter is the Forth code which accepts input from the keyboard and performs the desired Forth operations. (This is distinct from the address or \"inner\" interpreter, NEXT, which executes compiled threaded code) The best way to understand it is to work through the startup of the Forth system. The CP/M entry point (see listing in previous installment) determines the top of available memory, set the stack pointers (PSP,RSP) and user pointer (UP), establishing the memory map shown in Figure 1 . It then sets the \"inner\" interpreter pointer (IP) to execute the Forth word COLD . COLD initializes the user variables from a startup table, and then does ABORT . ( COLD will also attempt to execute a Forth command from the CP/M command line.) ABORT resets the parameter stack pointer and does QUIT . QUIT resets the return stack pointer, loop stack pointer, and interpret state, and then begins to interpret Forth commands. (The name is apt because QUIT can be used to abort an application and get back to the \"top level\" of Forth. Unlike ABORT , QUIT will leave the parameter stack contents alone) QUIT is an infinite loop which will ACCEPT a line from the keyboard, and then INTERPRET it as Forth commands. When not compiling, QUIT will prompt \"ok\" after each line. INTERPRET is an almost verbatim translation of the algorithm given in section 3.4 of the ANS Forth document. It parses one space-delimited string from the input, and tries to FIND the Forth word of that name. If the word is found, it will be either executed (if it is an IMMEDIATE word, or if in the \"interpret\" state, STATE=0) or compiled into the dictionary (if in the \"compile\" state, STATE\\<>0). If not found, Forth attempts to convert the string as a number. If successful, LITERAL will either place it on the parameter stack (if in \"interpret\" state) or compile it as an in-line literal value (if in \"compile\" state). If not a Forth word and not a valid number, the string is typed, an error message is displayed, and the interpreter ABORT s. This process is repeated, string by string, until the end of the input line is reached. THE FORTH DICTIONARY Whoa! How does the interpreter \"find\" a Forth word by name? Answer: Forth keeps a \"dictionary\" of the names of all Forth words. Each name is connected in some fashion with the executable code for the corresponding word. There are many ways to store a set of strings for searching: a simple array, a linked list, a multiple linked list, hash table, etc. Almost all are valid here -- all Forth asks is that, if you reuse a name, the latest definition is found when you search the dictionary. It's also possible to have several sets of names (\"vocabularies\", or \"wordlists\" in the new ANSI jargon ). This lets you reuse a name without losing its previous meaning. For example, you could have an integer + , a floating-point + , even a + for strings...one way to achieve the \"operator overloading\" so beloved by the object-oriented community. Each string may be connected with its executable code by being physically adjacent in memory -- i.e., the name appears in memory just before the executable code, thus being called the \"head\" or \"header\" of the Forth word. Or the strings may be located in a totally different part of memory, and connected with pointers to executable code (\"separate heads\"). You can even have unnamed (\"headless\") fragments of Forth code, if you know you'll never need to compile or interpret them. ANSI only requires that the ANS Forth words be findable. The design decisions could fill another article. Suffice it to say that CamelForth uses the simplest scheme: a single linked list, with the header located just before the executable code. No vocabularies... although I may add them in a future issue of TCJ. HEADER STRUCTURE ( Figure 2 ) Still more design decisions: what data should be present in the header, and how should it be stored? The minimum data is the name, precedence bit, and pointer (explicit or implicit) to executable code. For simplicity, CamelForth stores the name as a \"counted string\" (one byte of length, followed by N characters). Early Forth Inc. products stored a length but only the first three characters, for faster comparisons (the actual improvement gained is another hot debate). Fig-Forth compromised, flagging the last character with MSB high in order to allow either full-length or truncated names. Other Forths have used packed strings [4], and I suspect even C-style null-terminated strings have been used. The \"precedence bit\" is a flag which indicates if this word has IMMEDIATE status. IMMEDIATE words are executed even during compilation , which is how Forth implements compiler directives and control structures. There are other ways to distinguish compiler directives -- Pygmy Forth [5], for example, puts them in a separate vocabulary. But ANS Forth essentially mandates the use of a precedence bit [6]. Many Forths store this bit in the \"length\" byte. I have chosen to put it in a separate byte, in order to use the \"normal\" string operators on word names (e.g. S= within FIND , and TYPE within WORDS ). If the names are kept in a linked list, there must be a link. Usually the latest word is at the head of the linked list, and the link points to a previous word. This enforces the ANSI (and traditional) requirement for redefined words. Charles Curley [7] has studied the placement of the link field, and found that the compiler can be made significantly faster if the link field comes before the name (rather than after, as was done in Fig-Forth). Figure 2 shows the structure of the CamelForth word header, and the Fig-Forth, F83, and Pygmy Forth headers for comparison. The \"view\" vield of F83 and Pygmy is an example of other useful information which can be stored in the Forth word header. Remember: it's important to distinguish the header from the \"body\" (executable part) of the word. They need not be stored together. The header is only used during compilation and interpretation, and a \"purely executable\" Forth application could dispense with headers entirely. However, headers must be present -- at least for the ANSI word set -- for it to be a legal ANS Forth System. When \"compiling\" a Forth system from assembler source code, you can define macros to build this header (see HEAD and IMMED in CAMEL80.AZM). In the Forth environment the header, and the Code Field , is constructed by the word CREATE . COMPILER OPERATION We now know enough to understand the Forth compiler. The word : starts a new high-level definition, by creating a header for the word ( CREATE ), changing its Code Field to \"docolon\" ( !COLON ), and switching to compile state ( ] ). Recall that, in compile state, every word encountered by the text interpreter is compiled into the dictionary instead of being executed. This will continue until the word ; is encountered. Being an IMMEDIATE word, ; will execute, compiling an EXIT to end the definition, and then switching back to interpret state ( [ ). Also, : will HIDE the new word, and ; will REVEAL it (by setting and clearing the \"smudge\" bit in the name). This is to allow a Forth word to be redefined in terms of its \"prior self\". To force a recursive call to the word being defined, use RECURSE . Thus we see that there is no distinct Forth \"compiler\", in the same sense that we would speak of a C or Pascal compiler. The Forth compiler is embodied in the actions of various Forth words. This makes it easy for you to change or extend the compiler, but makes it difficult to create a Forth application without a built-in compiler! THE DEPENDENCY WORD SET Most of the remaining high-level words are either a) necessary to implement the compiler and interpreter, or b) provided solely for your programming pleasure. But there is one set which deserves special mention: the words I have separated into the file CAMEL80D.AZM ( Listing 3 ). One of the goals of the ANSI Forth Standard was to hide CPU and model dependencies (Direct or Indirect Threaded? 16 or 32 bit?) from the application programmer. Several words were added to the Standard for this purpose. I have taken this one step further, attempting to encapsulate these dependencies even within the kernel . Ideally, the high-level Forth code in the file CAMEL80H.AZM should be the same for all CamelForth targets (although different assemblers will have different syntax). Differences in cell size and word alignment are managed by the ANS Forth words ALIGN ALIGNED CELL+ CELLS CHAR+ CHARS and my own addition, CELL (equivalent to 1 CELLS , but smaller when compiled). The words COMPILE, !CF ,CF !COLON and ,EXIT hide peculiarities of the threading model, such as a) how are the threads represented, and b) how is the Code Field implemented? The value of these words becomes evident when you look at the differences between the direct-threaded Z80 and the subroutine-threaded 8051: word compiles on Z80 compiles on 8051 -------- ----------------- --------------------------- COMPILE, address LCALL address !CF CALL address LCALL address ,CF !CF & allot 3 bytes !CF & allot 3 bytes !COLON CALL docolon nothing! ,EXIT address of EXIT RET ( !CF and ,CF are different for indirect-threaded Forths.) In similar fashion, the words ,BRANCH ,DEST and !DEST hide the implementation of high-level branch and loop operators. I have tried to invent -- without borrowing from existing Forths! -- the minimal set of operators which can factor out all the implementation differences. Only time, expert criticism, and many CamelForths will tell how successful I've been. So far I have not been successful factoring the differences in header structure into a similar set of words. The words FIND and CREATE are so intimately involved with the header contents that I haven't yet found suitable subfactors. I have made a start, with the words NFA>LFA NFA>CFA IMMED? HIDE REVEAL and the ANS Forth words >BODY IMMEDIATE . I'll continue to work on this. Fortunately, it is practical for the time being to use the identical header structure on all CamelForth implementations (since they're all byte-addressed 16-bit Forths). NEXT TIME... I will probably present the 8051 kernel, and talk about how the Forth compiler and interpreter are modified for Harvard architectures (computers that have logically distinct memories for Code and Data, like the 8051). For the 8051 I will print the files CAMEL51 and CAMEL51D, but probably only excerpts from CAMEL51H, since (except for formatting of the assembler file) the high-level code shouldn't be different from what I've presented this issue...and Bill needs the space for other articles! Don't worry, the full code will be uploaded to GEnie. However, I may succumb to demands of Scroungemaster II builders, and publish the 6809 CamelForth configured for the Scroungemaster II board. Whichever I do next, I'll do the other just one installment later. REFERENCES Derick, Mitch and Baker, Linda, Forth Encyclopedia , Mountain View Press, Route 2 Box 429, La Honda, CA 94020 USA (1982). Word-by-word description of Fig-Forth. Ting, C. H., Systems Guide to fig-Forth , Offete Enterprises, 1306 South B Street, San Mateo, CA 94402 USA (1981). Ting, C. H., Inside F83 , Offete Enterprises (1986). Ewing, Martin S., The Caltech Forth Manual , a Technical Report of the Owens Valley Radio Observatory (1978). This PDP-11 Forth stored a length, four characters, and a link in two 16-bit words. Sergeant, Frank, Pygmy Forth for the IBM PC , version 1.4 (1992). Distributed by the author, available from the Forth Interest Group (P.O. Box 2154, Oakland CA 94621 USA) or on GEnie. J. E. Thomas examined this issue thoroughly when converting Pygmy Forth to an ANSI Forth. No matter what tricks you play with relinking words, strict ANSI compliance is violated. A regrettable decision on the part of the ANS Forth team. In private communication. The source code for Z80 CamelForth is now available on GEnie as CAMEL80.ARC in the CP/M and Forth Roundtables. Really. I just uploaded it. (Apologies to those who have been waiting.) Source code for Z80 CamelForth is available on this site at http://www.camelforth.com/public_ftp/cam80-12.zip . FIGURE 1. Z80 CP/M CAMELFORTH MEMORY MAP assuming CP/M BDOS starts at ED00 hex. 0000 +-----------------------+ | CP/M stuff | 0080 +-----------------------+ | Terminal Input Buffer | | | 0100 +-----------------------+ | | | CamelForth Z80 kernel | | | 1700 +-----------------------+ | User definitions | | | | | / EB00 reserved ~~~~~~~~~~~~~~~~~~~~~~~~~ / EB02 >IN | | / EB04 BASE EB00 +-----------------------+/ EB06 STATE | User Area | EB08 DP | |\\ EB0A,EB0C 'SOURCE | | \\ EB0E LATEST | Parameter Stack | \\ EB10 HP EC00 +-----------------------+ \\ EB12 LP | | | HOLD working buffer | EC28 +-----------------------+ | PAD buffer | | | EC80 +-----------------------+ | Leave stack* | | | | | | Return stack | ED00 +-----------------------+ | | | CP/M | | | FFFF +-----------------------+ * used during compilation of DO..LOOPs. FIGURE 2. HEADER STRUCTURES CamelForth Fig-Forth Pygmy Forth F83 D7 D0 D7 D0 D7 D0 D7 D0 +---------------+ +-+-+-+---------+ +---------------+ +---------------+ | | |1|P|S| length | | | | | |- link -| +-+-+-+---------+ |- view -| |- view -| | | | | | | | | +-------------+-+ |- name -| +---------------+ +---------------+ | 0 |P| | | | | | | +-+-----------+-+ ~~~~~~~~~~~~~~~~~ |- link -| |- link -| |S| length | | | | | | | +-+-------------+ +-+ -| +-+-+-+---------+ +-+-+-+---------+ | | |1| | |0|0|S| length | |1|P|S| length | |- name -| +-+-------------+ +-+-+-+---------+ +-+-+-+---------+ | | | | | | | | ~~~~~~~~~~~~~~~~~ |- link -| |- name -| |- name -| | | | | | | | | |- -| +---------------+ ~~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~ | | | | | | +---------------+ |- -| +-+ -| | | |1| | +---------------+ +-+-------------+ Link - in CamelForth and Fig-Forth, points to the previous word's Length byte. In Pygmy Forth and F83, points to the previous word's Link. P - Precedence bit, equals 1 for an IMMEDIATE word (not used in Pygmy). S - Smudge bit, used to prevent FIND from finding this word. 1 - in Fig-Forth and F83, the length byte and the last character of the name are flagged with a 1 in the most significant bit (bit 7). View - in Pygmy Forth and F83, contains the block number of the source code for this word.","title":"MOVING FORTH 6"},{"location":"moving6.html#moving-forth-6","text":"Part 6: the Z80 high-level kernel by Brad Rodriguez This article first appeared in The Computer Journal #69 (September/October 1994) .","title":"MOVING FORTH 6"},{"location":"moving6.html#errata","text":"There are two goofs in the CAMEL80.AZM file I presented in TCJ#67. The minor goof is that the name length specified in the HEAD macro for the Forth word > was incorrectly typed as 2 instead of 1. The major goof results from a subtlety of CP/M console I/O. KEY must not echo the typed character, and so used BDOS function 6. KEY? used BDOS function 11 to test non-destructively for the presence of a keypress. Unfortunately, BDOS function 6 does not \"clear\" the keypress detected by function 11! I have now rewritten KEY? to use BDOS function 6 (see Listing 1 ). Since this is a \"destructive\" test, I had to add logic to save the \"consumed\" keypress and return it when KEY is next used. This new logic can be used whenever your hardware (or operating system) provides only a destructive test-for-keypress.","title":"ERRATA"},{"location":"moving6.html#high-level-definitions","text":"In the last installment I did not expound greatly on the source code. Each Forth \"primitive\" performs a miniscule, sharply-defined function. It was almost all Z80 assembler code, and if it wasn't obvious why a particular word was included, I hope it was clear what each word did. In this installment I have no such luxury: I will present the high level definitions which embody the elegant (and tortuous) logic of the Forth language. Entire books have been written [1,2,3] describing Forth kernels, and if you want complete mastery I highly recommend you buy one of them. For TCJ I'll limit myself to some of the key words of the compiler and interpreter, given in Listing 2 .","title":"HIGH LEVEL DEFINITIONS"},{"location":"moving6.html#text-interpreter-operation","text":"The text or \"outer\" interpreter is the Forth code which accepts input from the keyboard and performs the desired Forth operations. (This is distinct from the address or \"inner\" interpreter, NEXT, which executes compiled threaded code) The best way to understand it is to work through the startup of the Forth system. The CP/M entry point (see listing in previous installment) determines the top of available memory, set the stack pointers (PSP,RSP) and user pointer (UP), establishing the memory map shown in Figure 1 . It then sets the \"inner\" interpreter pointer (IP) to execute the Forth word COLD . COLD initializes the user variables from a startup table, and then does ABORT . ( COLD will also attempt to execute a Forth command from the CP/M command line.) ABORT resets the parameter stack pointer and does QUIT . QUIT resets the return stack pointer, loop stack pointer, and interpret state, and then begins to interpret Forth commands. (The name is apt because QUIT can be used to abort an application and get back to the \"top level\" of Forth. Unlike ABORT , QUIT will leave the parameter stack contents alone) QUIT is an infinite loop which will ACCEPT a line from the keyboard, and then INTERPRET it as Forth commands. When not compiling, QUIT will prompt \"ok\" after each line. INTERPRET is an almost verbatim translation of the algorithm given in section 3.4 of the ANS Forth document. It parses one space-delimited string from the input, and tries to FIND the Forth word of that name. If the word is found, it will be either executed (if it is an IMMEDIATE word, or if in the \"interpret\" state, STATE=0) or compiled into the dictionary (if in the \"compile\" state, STATE\\<>0). If not found, Forth attempts to convert the string as a number. If successful, LITERAL will either place it on the parameter stack (if in \"interpret\" state) or compile it as an in-line literal value (if in \"compile\" state). If not a Forth word and not a valid number, the string is typed, an error message is displayed, and the interpreter ABORT s. This process is repeated, string by string, until the end of the input line is reached.","title":"TEXT INTERPRETER OPERATION"},{"location":"moving6.html#the-forth-dictionary","text":"Whoa! How does the interpreter \"find\" a Forth word by name? Answer: Forth keeps a \"dictionary\" of the names of all Forth words. Each name is connected in some fashion with the executable code for the corresponding word. There are many ways to store a set of strings for searching: a simple array, a linked list, a multiple linked list, hash table, etc. Almost all are valid here -- all Forth asks is that, if you reuse a name, the latest definition is found when you search the dictionary. It's also possible to have several sets of names (\"vocabularies\", or \"wordlists\" in the new ANSI jargon ). This lets you reuse a name without losing its previous meaning. For example, you could have an integer + , a floating-point + , even a + for strings...one way to achieve the \"operator overloading\" so beloved by the object-oriented community. Each string may be connected with its executable code by being physically adjacent in memory -- i.e., the name appears in memory just before the executable code, thus being called the \"head\" or \"header\" of the Forth word. Or the strings may be located in a totally different part of memory, and connected with pointers to executable code (\"separate heads\"). You can even have unnamed (\"headless\") fragments of Forth code, if you know you'll never need to compile or interpret them. ANSI only requires that the ANS Forth words be findable. The design decisions could fill another article. Suffice it to say that CamelForth uses the simplest scheme: a single linked list, with the header located just before the executable code. No vocabularies... although I may add them in a future issue of TCJ.","title":"THE FORTH DICTIONARY"},{"location":"moving6.html#header-structure-figure-2","text":"Still more design decisions: what data should be present in the header, and how should it be stored? The minimum data is the name, precedence bit, and pointer (explicit or implicit) to executable code. For simplicity, CamelForth stores the name as a \"counted string\" (one byte of length, followed by N characters). Early Forth Inc. products stored a length but only the first three characters, for faster comparisons (the actual improvement gained is another hot debate). Fig-Forth compromised, flagging the last character with MSB high in order to allow either full-length or truncated names. Other Forths have used packed strings [4], and I suspect even C-style null-terminated strings have been used. The \"precedence bit\" is a flag which indicates if this word has IMMEDIATE status. IMMEDIATE words are executed even during compilation , which is how Forth implements compiler directives and control structures. There are other ways to distinguish compiler directives -- Pygmy Forth [5], for example, puts them in a separate vocabulary. But ANS Forth essentially mandates the use of a precedence bit [6]. Many Forths store this bit in the \"length\" byte. I have chosen to put it in a separate byte, in order to use the \"normal\" string operators on word names (e.g. S= within FIND , and TYPE within WORDS ). If the names are kept in a linked list, there must be a link. Usually the latest word is at the head of the linked list, and the link points to a previous word. This enforces the ANSI (and traditional) requirement for redefined words. Charles Curley [7] has studied the placement of the link field, and found that the compiler can be made significantly faster if the link field comes before the name (rather than after, as was done in Fig-Forth). Figure 2 shows the structure of the CamelForth word header, and the Fig-Forth, F83, and Pygmy Forth headers for comparison. The \"view\" vield of F83 and Pygmy is an example of other useful information which can be stored in the Forth word header. Remember: it's important to distinguish the header from the \"body\" (executable part) of the word. They need not be stored together. The header is only used during compilation and interpretation, and a \"purely executable\" Forth application could dispense with headers entirely. However, headers must be present -- at least for the ANSI word set -- for it to be a legal ANS Forth System. When \"compiling\" a Forth system from assembler source code, you can define macros to build this header (see HEAD and IMMED in CAMEL80.AZM). In the Forth environment the header, and the Code Field , is constructed by the word CREATE .","title":"HEADER STRUCTURE (Figure 2)"},{"location":"moving6.html#compiler-operation","text":"We now know enough to understand the Forth compiler. The word : starts a new high-level definition, by creating a header for the word ( CREATE ), changing its Code Field to \"docolon\" ( !COLON ), and switching to compile state ( ] ). Recall that, in compile state, every word encountered by the text interpreter is compiled into the dictionary instead of being executed. This will continue until the word ; is encountered. Being an IMMEDIATE word, ; will execute, compiling an EXIT to end the definition, and then switching back to interpret state ( [ ). Also, : will HIDE the new word, and ; will REVEAL it (by setting and clearing the \"smudge\" bit in the name). This is to allow a Forth word to be redefined in terms of its \"prior self\". To force a recursive call to the word being defined, use RECURSE . Thus we see that there is no distinct Forth \"compiler\", in the same sense that we would speak of a C or Pascal compiler. The Forth compiler is embodied in the actions of various Forth words. This makes it easy for you to change or extend the compiler, but makes it difficult to create a Forth application without a built-in compiler!","title":"COMPILER OPERATION"},{"location":"moving6.html#the-dependency-word-set","text":"Most of the remaining high-level words are either a) necessary to implement the compiler and interpreter, or b) provided solely for your programming pleasure. But there is one set which deserves special mention: the words I have separated into the file CAMEL80D.AZM ( Listing 3 ). One of the goals of the ANSI Forth Standard was to hide CPU and model dependencies (Direct or Indirect Threaded? 16 or 32 bit?) from the application programmer. Several words were added to the Standard for this purpose. I have taken this one step further, attempting to encapsulate these dependencies even within the kernel . Ideally, the high-level Forth code in the file CAMEL80H.AZM should be the same for all CamelForth targets (although different assemblers will have different syntax). Differences in cell size and word alignment are managed by the ANS Forth words ALIGN ALIGNED CELL+ CELLS CHAR+ CHARS and my own addition, CELL (equivalent to 1 CELLS , but smaller when compiled). The words COMPILE, !CF ,CF !COLON and ,EXIT hide peculiarities of the threading model, such as a) how are the threads represented, and b) how is the Code Field implemented? The value of these words becomes evident when you look at the differences between the direct-threaded Z80 and the subroutine-threaded 8051: word compiles on Z80 compiles on 8051 -------- ----------------- --------------------------- COMPILE, address LCALL address !CF CALL address LCALL address ,CF !CF & allot 3 bytes !CF & allot 3 bytes !COLON CALL docolon nothing! ,EXIT address of EXIT RET ( !CF and ,CF are different for indirect-threaded Forths.) In similar fashion, the words ,BRANCH ,DEST and !DEST hide the implementation of high-level branch and loop operators. I have tried to invent -- without borrowing from existing Forths! -- the minimal set of operators which can factor out all the implementation differences. Only time, expert criticism, and many CamelForths will tell how successful I've been. So far I have not been successful factoring the differences in header structure into a similar set of words. The words FIND and CREATE are so intimately involved with the header contents that I haven't yet found suitable subfactors. I have made a start, with the words NFA>LFA NFA>CFA IMMED? HIDE REVEAL and the ANS Forth words >BODY IMMEDIATE . I'll continue to work on this. Fortunately, it is practical for the time being to use the identical header structure on all CamelForth implementations (since they're all byte-addressed 16-bit Forths).","title":"THE DEPENDENCY WORD SET"},{"location":"moving6.html#next-time","text":"I will probably present the 8051 kernel, and talk about how the Forth compiler and interpreter are modified for Harvard architectures (computers that have logically distinct memories for Code and Data, like the 8051). For the 8051 I will print the files CAMEL51 and CAMEL51D, but probably only excerpts from CAMEL51H, since (except for formatting of the assembler file) the high-level code shouldn't be different from what I've presented this issue...and Bill needs the space for other articles! Don't worry, the full code will be uploaded to GEnie. However, I may succumb to demands of Scroungemaster II builders, and publish the 6809 CamelForth configured for the Scroungemaster II board. Whichever I do next, I'll do the other just one installment later.","title":"NEXT TIME..."},{"location":"moving6.html#references","text":"Derick, Mitch and Baker, Linda, Forth Encyclopedia , Mountain View Press, Route 2 Box 429, La Honda, CA 94020 USA (1982). Word-by-word description of Fig-Forth. Ting, C. H., Systems Guide to fig-Forth , Offete Enterprises, 1306 South B Street, San Mateo, CA 94402 USA (1981). Ting, C. H., Inside F83 , Offete Enterprises (1986). Ewing, Martin S., The Caltech Forth Manual , a Technical Report of the Owens Valley Radio Observatory (1978). This PDP-11 Forth stored a length, four characters, and a link in two 16-bit words. Sergeant, Frank, Pygmy Forth for the IBM PC , version 1.4 (1992). Distributed by the author, available from the Forth Interest Group (P.O. Box 2154, Oakland CA 94621 USA) or on GEnie. J. E. Thomas examined this issue thoroughly when converting Pygmy Forth to an ANSI Forth. No matter what tricks you play with relinking words, strict ANSI compliance is violated. A regrettable decision on the part of the ANS Forth team. In private communication. The source code for Z80 CamelForth is now available on GEnie as CAMEL80.ARC in the CP/M and Forth Roundtables. Really. I just uploaded it. (Apologies to those who have been waiting.) Source code for Z80 CamelForth is available on this site at http://www.camelforth.com/public_ftp/cam80-12.zip .","title":"REFERENCES"},{"location":"moving6.html#figure-1-z80-cpm-camelforth-memory-map","text":"assuming CP/M BDOS starts at ED00 hex. 0000 +-----------------------+ | CP/M stuff | 0080 +-----------------------+ | Terminal Input Buffer | | | 0100 +-----------------------+ | | | CamelForth Z80 kernel | | | 1700 +-----------------------+ | User definitions | | | | | / EB00 reserved ~~~~~~~~~~~~~~~~~~~~~~~~~ / EB02 >IN | | / EB04 BASE EB00 +-----------------------+/ EB06 STATE | User Area | EB08 DP | |\\ EB0A,EB0C 'SOURCE | | \\ EB0E LATEST | Parameter Stack | \\ EB10 HP EC00 +-----------------------+ \\ EB12 LP | | | HOLD working buffer | EC28 +-----------------------+ | PAD buffer | | | EC80 +-----------------------+ | Leave stack* | | | | | | Return stack | ED00 +-----------------------+ | | | CP/M | | | FFFF +-----------------------+ * used during compilation of DO..LOOPs.","title":"FIGURE 1. Z80 CP/M CAMELFORTH MEMORY MAP"},{"location":"moving6.html#figure-2-header-structures","text":"CamelForth Fig-Forth Pygmy Forth F83 D7 D0 D7 D0 D7 D0 D7 D0 +---------------+ +-+-+-+---------+ +---------------+ +---------------+ | | |1|P|S| length | | | | | |- link -| +-+-+-+---------+ |- view -| |- view -| | | | | | | | | +-------------+-+ |- name -| +---------------+ +---------------+ | 0 |P| | | | | | | +-+-----------+-+ ~~~~~~~~~~~~~~~~~ |- link -| |- link -| |S| length | | | | | | | +-+-------------+ +-+ -| +-+-+-+---------+ +-+-+-+---------+ | | |1| | |0|0|S| length | |1|P|S| length | |- name -| +-+-------------+ +-+-+-+---------+ +-+-+-+---------+ | | | | | | | | ~~~~~~~~~~~~~~~~~ |- link -| |- name -| |- name -| | | | | | | | | |- -| +---------------+ ~~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~ | | | | | | +---------------+ |- -| +-+ -| | | |1| | +---------------+ +-+-------------+ Link - in CamelForth and Fig-Forth, points to the previous word's Length byte. In Pygmy Forth and F83, points to the previous word's Link. P - Precedence bit, equals 1 for an IMMEDIATE word (not used in Pygmy). S - Smudge bit, used to prevent FIND from finding this word. 1 - in Fig-Forth and F83, the length byte and the last character of the name are flagged with a 1 in the most significant bit (bit 7). View - in Pygmy Forth and F83, contains the block number of the source code for this word.","title":"FIGURE 2. HEADER STRUCTURES"},{"location":"moving7.html","text":"MOVING FORTH 7 Part 7: CamelForth for the 8051 by Brad Rodriguez This article first appeared in The Computer Journal #71 (January/February 1995) . Under the prodding of Our Esteemed Editor, I present CamelForth for the 8051. CamelForth for the 6809 will follow soon! This 8051 Forth occupies about 6K of program memory. Alas, the full source listing would take 16 pages of TCJ, so this article includes only the significantly changed portions of the kernel. [Note for web publication: see the end of this page for a link to the 8051 source code.] These should illustrate how the high-level code is modified for the 8051 assembler, and for subroutine threading. The full source code is available in the Forth Roundtable on GEnie as file CAMEL51.ZIP, and the freeware 8051 assembler as file A51.ZIP. But first... Z80 ERRATA In the file CAMEL80H.AZM , the definition of DO is given as ['] xdo ,BRANCH . . . It should be ['] xdo ,XT . . . This is of no consequence on the Z80 (where ,BRANCH and ,XT are identical), but it became embarrassingly obvious on the 8051. Also, in the words S\" and (S\"), the word ALIGN should really be ALIGNED. On the Z80 -- and the 8051 -- both are no-ops, so this mistake didn't make itself evident. 8051 CAMELFORTH MODEL In issue #60 I summarized the design decisions for an 8051 Forth. To recap: the 8051's retarded memory addressing practically demands the use of subroutine threading. This means the hardware stack (in the 8051 register file) is the Return Stack. The Parameter Stack (a.k.a. Data Stack) is in 256 bytes of external RAM, using R0 as the stack pointer. Since that article, I've discovered that it's better to keep the Top Of Stack item (TOS) in DPTR than in R3:R2. Thus: reg adrs 8051 name Forth usage 0 R0 low byte of PSP (Parameter Stack Pointer) 1-5 R1-R5 scratch registers for Forth 6-7 R6-R7 loop index 8 high byte of PSP and UP (also output on P2) 9-7Fh 119 bytes of return stack (more on 8052s!) 81h SP low byte of RSP (Return Stack Pointer) 82-83h DPTR Top-Of-Stack item E0,F0h A,B scratch registers for Forth This incorporates an idea from Charles Curley [CUR93]. On a register-rich machine like the 8051, we can keep the innermost loop index in registers. This makes LOOP and +LOOP much faster. DO must still push two values on the Return Stack: the old loop index, and the new loop limit! UNLOOP must of course restore the loop index from the Return Stack -- kudos to the ANSI team for making UNLOOP a distinct word! Note that R6:R7 are not the topmost Return Stack item, merely the innermost loop index. Port 2 (P2) contains the high byte of the Parameter Stack Pointer (allowing R0 to address external memory), which is also the high byte of the User Pointer -- the low byte of UP is assumed to be 00. I learned the hard way that P2 can't be read while executing from external ROM, so I keep a copy of the P2 byte in register 8. I have a novel implementation of BRANCH and ?BRANCH. Since the 8051 model is subroutine-threaded, high-level Forth is compiled as true machine code. So BRANCH can be implemented with an SJMP (or AJMP or LJMP) instruction. ?BRANCH can be implemented with a JZ instruction, if the zero/nonzero status of the top-of-stack is put in the accumulator (A register). The subroutine ZEROSENSE does this. So, BRANCH and ?BRANCH become BRANCH: SJMP dest ?BRANCH: LCALL ZEROSENSE JZ dest Similar routines LOOPSENSE and PLUSLOOPSENSE allow a JZ instruction to be used for LOOP and +LOOP. For these, a call to UNLOOP must appear after the JZ, to clean up the Return Stack when the program \"falls out\" of the loop. In the assembly language source file I have manually replaced the sequence LCALL word RET with the shorter and faster LJMP word in many places [CUR93]. This works as long as \"word\" isn't a return-stack operator (such as R> or >R). LCALL and LJMP have also been replaced with ACALL and AJMP where possible. The CamelForth compiler does not attempt these optimizations. I wrote the 8051 kernel to use \"Intel\" byte order (low byte first). Then I discovered that the address compiled into an LJMP or LCALL is stored high byte first. Rather than rewrite the entire kernel, I included a byte-swap in those words which compile LCALLs: COMPILE, !CF and ,CF (all in the Dependency word set). Listing 1 gives the 8051 assembly language \"primitives\", and Listing 2 gives the Dependency word set. HARVARD ARCHITECTURES The 8051 uses a \"Harvard\" architecture: program and data are kept in separate memories. In embedded systems, these are typically ROM and RAM, respectively. ANS Forth is the first Forth standard to address the restrictions of a Harvard architecture. Briefly, ANS Forth says that a) application programs can only access Data memory, and b) all of the operators used to access memory and build data structures must operate in Data space. (Ref. section 3.3.3 of the ANS document [ANS94].) This includes the Forth words @ ! C@ C! DP HERE ALLOT , C, COUNT TYPE WORD (S\") S\" CMOVE Yet the Forth compiler still needs to access Program space (also called Code or Instruction space). And Forth needs to maintain a dictionary pointer for Program space as well as Data space. So I've added these new words (shown in Listing 3): I@ I! IC@ IC! IDP IHERE IALLOT I, IC, ICOUNT ITYPE IWORD (IS\") IS\" D->I I->D The \"I\" prefix stands for \"Instruction\" (since \"P\" and \"C\" have other meanings in Forth). ICOUNT and ITYPE are needed to display strings which have been compiled into ROM. IWORD copies the string left by WORD from Data space to Code space -- needed to build Forth word headers and ROMmed strings. D->I and I->D are equivalents of CMOVE, which copy to and from Code space. VARIABLEs must have addresses in Data space. So they can't use the traditional practice of putting the data immediately after the Code field. Instead, the Data space address of the data is stored after the Code field. In essence, a VARIABLE is a CONSTANT whose value is the Data space address. (Note that the traditional CONSTANT is still valid.) CREATEd words, and words built with CREATE...DOES>, must work the same way. Here's how they look in Program space: CODE word: ...header... 8051 machine code high-level: ...header... 8051 machine code CONSTANT: ...header... LCALL-DOCON value VARIABLE: ...header... LCALL-DOCON Data-adrs CREATEd: ...header... LCALL-DOCON Data-adrs Note that CONSTANT must replace the value stored by CREATE, and : must \"un-allot\" both this value and the LCALL DOCON. S\" presents special problems. Strings defined with S\" (\"text literals\") must reside in Data space, where they can be used by such words as TYPE and EVALUATE. But we expect those strings to be part of a definition, and to exist in ROM in a ROM forth environment. We could store the string in Program space, and copy it to HERE when referenced, but the ANS document does not allow text literals to exist in this \"transient\" storage region (ref. sections 3.3.3.4 and 3.3.3.6 [ANS93]). Also, if WORD returns its string at HERE -- as in CamelForth -- text literals must not alter this transient region. My solution is to have S\" store the string in Code space, but permanently reserve space for it in Data space, and copy it from Code to Data when referenced. ANS Forth does not yet fully address the problems of Harvard processors; something like C's \"initialized data\" region may eventually be required. Since .\" strings can never be accessed by the programmer, they can be stored in Code space, using the words (IS\") and IS\". (These are the \"old\" (S\") and S\".) This adds two words to the kernel, but saves quite a bit of Data space. I plan to move the string-literal words into either the Dependency word set, or a new \"Harvard\" word set. WRITING TO PROGRAM SPACE The 8051 can't actually write to Program memory. There's no hardware signal for this, and no machine instruction. Under these circumstances, the CamelForth interpreter will work, but new words can't be compiled. You can get around this by causing some memory to appear in both Program and Data space. Figure 1 shows the modification to my board, an MCB8031 from Blue Ridge Micros (2505 Plymouth Road, Johnson City, TN, 37601, USA, telephone 615-335-6696, fax 615-929-3164). U1A and U1B create a new read strobe which is active for either a Program or Data fetch. EPROM is selected only when A15 is low (lower 32K), and RAM when A15 is high (upper 32K). You still can't write to EPROM, of course, but you can execute programs out of RAM! One disadvantage: this makes @ and I@ equivalent, so it's not immediately obvious if the wrong one was used somewhere. Figure 1 NEXT ISSUE... These modifications to the CamelForth high-level code are intended to be portable to either Harvard or non-Harvard (\"von Neumann\") machines. For the latter, the new Program-space words are simply equated to their Data-space equivalents, e.g. on the Z80, IFETCH EQU FETCH ISTORE EQU STORE ITYPE EQU TYPE etc. In the next installment I shall modify the 8051 source code to work on the 6809...thus approaching a truly portable model by successive approximation. REFERENCES [ANS93] dpANS-6 draft proposed American National Standard for Information Systems - Programming Languages - Forth , June 30, 1993. \"It is distributed solely for the purpose of review and comment and should not be used as a design document. It is inappropriate to claim compatibility with this draft standard.\" Nevertheless, for the last 16 months it's all we've had to go by. http://www.forth.com/forth-books/ ftp://ftp.taygeta.com/pub/Forth/Literature/ [CUR93] Curley, Charles, Optimization Considerations , Forth Dimensions XIV:5 (Jan/Feb 1993), pp. 6-12. Source code for 8051 CamelForth is available on this site at http://www.camelforth.com/public_ftp/cam51-15.zip .","title":"MOVING FORTH 7"},{"location":"moving7.html#moving-forth-7","text":"Part 7: CamelForth for the 8051 by Brad Rodriguez This article first appeared in The Computer Journal #71 (January/February 1995) . Under the prodding of Our Esteemed Editor, I present CamelForth for the 8051. CamelForth for the 6809 will follow soon! This 8051 Forth occupies about 6K of program memory. Alas, the full source listing would take 16 pages of TCJ, so this article includes only the significantly changed portions of the kernel. [Note for web publication: see the end of this page for a link to the 8051 source code.] These should illustrate how the high-level code is modified for the 8051 assembler, and for subroutine threading. The full source code is available in the Forth Roundtable on GEnie as file CAMEL51.ZIP, and the freeware 8051 assembler as file A51.ZIP. But first...","title":"MOVING FORTH 7"},{"location":"moving7.html#z80-errata","text":"In the file CAMEL80H.AZM , the definition of DO is given as ['] xdo ,BRANCH . . . It should be ['] xdo ,XT . . . This is of no consequence on the Z80 (where ,BRANCH and ,XT are identical), but it became embarrassingly obvious on the 8051. Also, in the words S\" and (S\"), the word ALIGN should really be ALIGNED. On the Z80 -- and the 8051 -- both are no-ops, so this mistake didn't make itself evident.","title":"Z80 ERRATA"},{"location":"moving7.html#8051-camelforth-model","text":"In issue #60 I summarized the design decisions for an 8051 Forth. To recap: the 8051's retarded memory addressing practically demands the use of subroutine threading. This means the hardware stack (in the 8051 register file) is the Return Stack. The Parameter Stack (a.k.a. Data Stack) is in 256 bytes of external RAM, using R0 as the stack pointer. Since that article, I've discovered that it's better to keep the Top Of Stack item (TOS) in DPTR than in R3:R2. Thus: reg adrs 8051 name Forth usage 0 R0 low byte of PSP (Parameter Stack Pointer) 1-5 R1-R5 scratch registers for Forth 6-7 R6-R7 loop index 8 high byte of PSP and UP (also output on P2) 9-7Fh 119 bytes of return stack (more on 8052s!) 81h SP low byte of RSP (Return Stack Pointer) 82-83h DPTR Top-Of-Stack item E0,F0h A,B scratch registers for Forth This incorporates an idea from Charles Curley [CUR93]. On a register-rich machine like the 8051, we can keep the innermost loop index in registers. This makes LOOP and +LOOP much faster. DO must still push two values on the Return Stack: the old loop index, and the new loop limit! UNLOOP must of course restore the loop index from the Return Stack -- kudos to the ANSI team for making UNLOOP a distinct word! Note that R6:R7 are not the topmost Return Stack item, merely the innermost loop index. Port 2 (P2) contains the high byte of the Parameter Stack Pointer (allowing R0 to address external memory), which is also the high byte of the User Pointer -- the low byte of UP is assumed to be 00. I learned the hard way that P2 can't be read while executing from external ROM, so I keep a copy of the P2 byte in register 8. I have a novel implementation of BRANCH and ?BRANCH. Since the 8051 model is subroutine-threaded, high-level Forth is compiled as true machine code. So BRANCH can be implemented with an SJMP (or AJMP or LJMP) instruction. ?BRANCH can be implemented with a JZ instruction, if the zero/nonzero status of the top-of-stack is put in the accumulator (A register). The subroutine ZEROSENSE does this. So, BRANCH and ?BRANCH become BRANCH: SJMP dest ?BRANCH: LCALL ZEROSENSE JZ dest Similar routines LOOPSENSE and PLUSLOOPSENSE allow a JZ instruction to be used for LOOP and +LOOP. For these, a call to UNLOOP must appear after the JZ, to clean up the Return Stack when the program \"falls out\" of the loop. In the assembly language source file I have manually replaced the sequence LCALL word RET with the shorter and faster LJMP word in many places [CUR93]. This works as long as \"word\" isn't a return-stack operator (such as R> or >R). LCALL and LJMP have also been replaced with ACALL and AJMP where possible. The CamelForth compiler does not attempt these optimizations. I wrote the 8051 kernel to use \"Intel\" byte order (low byte first). Then I discovered that the address compiled into an LJMP or LCALL is stored high byte first. Rather than rewrite the entire kernel, I included a byte-swap in those words which compile LCALLs: COMPILE, !CF and ,CF (all in the Dependency word set). Listing 1 gives the 8051 assembly language \"primitives\", and Listing 2 gives the Dependency word set.","title":"8051 CAMELFORTH MODEL"},{"location":"moving7.html#harvard-architectures","text":"The 8051 uses a \"Harvard\" architecture: program and data are kept in separate memories. In embedded systems, these are typically ROM and RAM, respectively. ANS Forth is the first Forth standard to address the restrictions of a Harvard architecture. Briefly, ANS Forth says that a) application programs can only access Data memory, and b) all of the operators used to access memory and build data structures must operate in Data space. (Ref. section 3.3.3 of the ANS document [ANS94].) This includes the Forth words @ ! C@ C! DP HERE ALLOT , C, COUNT TYPE WORD (S\") S\" CMOVE Yet the Forth compiler still needs to access Program space (also called Code or Instruction space). And Forth needs to maintain a dictionary pointer for Program space as well as Data space. So I've added these new words (shown in Listing 3): I@ I! IC@ IC! IDP IHERE IALLOT I, IC, ICOUNT ITYPE IWORD (IS\") IS\" D->I I->D The \"I\" prefix stands for \"Instruction\" (since \"P\" and \"C\" have other meanings in Forth). ICOUNT and ITYPE are needed to display strings which have been compiled into ROM. IWORD copies the string left by WORD from Data space to Code space -- needed to build Forth word headers and ROMmed strings. D->I and I->D are equivalents of CMOVE, which copy to and from Code space. VARIABLEs must have addresses in Data space. So they can't use the traditional practice of putting the data immediately after the Code field. Instead, the Data space address of the data is stored after the Code field. In essence, a VARIABLE is a CONSTANT whose value is the Data space address. (Note that the traditional CONSTANT is still valid.) CREATEd words, and words built with CREATE...DOES>, must work the same way. Here's how they look in Program space: CODE word: ...header... 8051 machine code high-level: ...header... 8051 machine code CONSTANT: ...header... LCALL-DOCON value VARIABLE: ...header... LCALL-DOCON Data-adrs CREATEd: ...header... LCALL-DOCON Data-adrs Note that CONSTANT must replace the value stored by CREATE, and : must \"un-allot\" both this value and the LCALL DOCON. S\" presents special problems. Strings defined with S\" (\"text literals\") must reside in Data space, where they can be used by such words as TYPE and EVALUATE. But we expect those strings to be part of a definition, and to exist in ROM in a ROM forth environment. We could store the string in Program space, and copy it to HERE when referenced, but the ANS document does not allow text literals to exist in this \"transient\" storage region (ref. sections 3.3.3.4 and 3.3.3.6 [ANS93]). Also, if WORD returns its string at HERE -- as in CamelForth -- text literals must not alter this transient region. My solution is to have S\" store the string in Code space, but permanently reserve space for it in Data space, and copy it from Code to Data when referenced. ANS Forth does not yet fully address the problems of Harvard processors; something like C's \"initialized data\" region may eventually be required. Since .\" strings can never be accessed by the programmer, they can be stored in Code space, using the words (IS\") and IS\". (These are the \"old\" (S\") and S\".) This adds two words to the kernel, but saves quite a bit of Data space. I plan to move the string-literal words into either the Dependency word set, or a new \"Harvard\" word set.","title":"HARVARD ARCHITECTURES"},{"location":"moving7.html#writing-to-program-space","text":"The 8051 can't actually write to Program memory. There's no hardware signal for this, and no machine instruction. Under these circumstances, the CamelForth interpreter will work, but new words can't be compiled. You can get around this by causing some memory to appear in both Program and Data space. Figure 1 shows the modification to my board, an MCB8031 from Blue Ridge Micros (2505 Plymouth Road, Johnson City, TN, 37601, USA, telephone 615-335-6696, fax 615-929-3164). U1A and U1B create a new read strobe which is active for either a Program or Data fetch. EPROM is selected only when A15 is low (lower 32K), and RAM when A15 is high (upper 32K). You still can't write to EPROM, of course, but you can execute programs out of RAM! One disadvantage: this makes @ and I@ equivalent, so it's not immediately obvious if the wrong one was used somewhere. Figure 1","title":"WRITING TO PROGRAM SPACE"},{"location":"moving7.html#next-issue","text":"These modifications to the CamelForth high-level code are intended to be portable to either Harvard or non-Harvard (\"von Neumann\") machines. For the latter, the new Program-space words are simply equated to their Data-space equivalents, e.g. on the Z80, IFETCH EQU FETCH ISTORE EQU STORE ITYPE EQU TYPE etc. In the next installment I shall modify the 8051 source code to work on the 6809...thus approaching a truly portable model by successive approximation.","title":"NEXT ISSUE..."},{"location":"moving7.html#references","text":"[ANS93] dpANS-6 draft proposed American National Standard for Information Systems - Programming Languages - Forth , June 30, 1993. \"It is distributed solely for the purpose of review and comment and should not be used as a design document. It is inappropriate to claim compatibility with this draft standard.\" Nevertheless, for the last 16 months it's all we've had to go by. http://www.forth.com/forth-books/ ftp://ftp.taygeta.com/pub/Forth/Literature/ [CUR93] Curley, Charles, Optimization Considerations , Forth Dimensions XIV:5 (Jan/Feb 1993), pp. 6-12. Source code for 8051 CamelForth is available on this site at http://www.camelforth.com/public_ftp/cam51-15.zip .","title":"REFERENCES"},{"location":"moving8.html","text":"MOVING FORTH 8 Part 8: CamelForth for the 6809 \\ by Brad Rodriguez This article first appeared in The Computer Journal #74 (July/August 1995) . Finally, the last installment of \"Moving Forth!\" Here is the long-promised ANSI CamelForth for the Motorola 6809, and specifically for the Scroungmaster II processor board. Unlike the Z80 and 8051 CamelForth, the 6809 Forth was produced with my \"Chromium 2\" Forth metacompiler [ROD92]. Right away you'll notice two things: first, the metacompiler runs on an older Forth (F83), and so the source code is contained in 16x64 Forth \"screens\". I've converted these to an ASCII file for TCJ, but the original formatting is still evident. Second, source code for a Forth metacompiler looks like ordinary Forth code (with a few changes, which I'll discuss shortly). Thus the definition of 1+ is given as CODE 1+ 1 # ADDD, NEXT ;C The assembler used is the 6809 assembler I've described previously in TCJ [ROD91]. I typed the high-level source code directly from the already-published listings (converting to the Forth syntax in the process). Unfortunately, this was done over the space of a few days, and sometimes I worked from the Z80 listing, and sometimes the 8051... with the result that the Harvard-architecture constructs (such as I@ and IALLOT) are not consistently used in the 6809 code. This is of no consequence for the non-Harvard 6809, but I'll have to correct this before porting the Forth code to a Harvard CPU. Also, since I was working from published listings, I often neglected typing the detailed comments for the high-level words. For this I apologize. You can find how any word works by consulting the previous listings, but I shouldn't force you to do this. 6809 CAMELFORTH SOURCE CODE The 6809 CamelForth model holds top-of-stack in D, and uses the S stack pointer for the Parameter Stack. The U stack pointer is the Return Stack Pointer, and Y is the Interpreter Pointer. X is the temporary register \"W\". The 6809 direct page pointer DPR holds the high byte of the User Pointer (the low byte is assumed to be zero). The memory map for a Scroungemaster II with 8K of RAM and 8K of EPROM is as follows: 6000-797Fh RAM dictionary (for new definitions) 7980-79FFh Terminal Input Buffer 7A00-7A7Fh User Area (USER variables) 7A80-7AFFh Parameter Stack (grows downward) 7B00-7B27h HOLD area (grows downward) 7B28-7B7Fh PAD area (general purpose buffer) 7B80-7BFFh Return Stack (grows downward) E000-FFFFh Forth kernel in EPROM All of the RAM data areas are referenced to the User Pointer, whose starting value is given by UP-INIT: in this case, 7A00h. (Note the use of UP-INIT-HI for the high byte of this value) When CamelForth starts, it will set its Dictionary Pointer to DP-INIT, which must be in RAM so you can add new definitions to the Forth dictionary. These are all specified with the metacompiler's EQU directive. An EQU is like a CONSTANT, except that it is only known to the metacompiler. These EQUates take up no space in the 6809 kernel, and will not appear in the 6809 Forth's dictionary. DICTIONARY tells the metacompiler where to compile the code, in this case for an 8K EPROM from E000-FFFFh. The new dictionary is named \"ROM\", and then ROM is specified to select that dictionary. (If you're familiar with Forth vocabularies, you'll see a strong resemblance.) AKA (\"also known as\") defines a synonym for a Forth word. Since the 6809 is a non-Harvard machine, we should compile @ wherever I@ appears in the source code, and likewise for the other \"I-prefix\" (instruction-space) words. AKA will do this. These synonyms are like EQUates -- they don't appear in the 6809 dictionary. The metacompiler allows you to use forward references, i.e., Forth words which haven't been defined yet. (You must of course define them before you finish!) Often this is automatic, but AKA requires you to explicitly declare a forward reference with PRESUME. Thus PRESUME WORD AKA WORD IWORD is needed to create the IWORD synonym. @ ! HERE ALLOT and the others are PRESUMEd by the metacompiler, so we don't have to do so here. The CODE definitions are conventional. Note that you can use HERE EQU labelname to generate a label when metacompiling. (This is a function of the metacompiler, not the assembler) Also, ASM: begins a \"fragment\" of assembler code (i.e., not part of a CODE word). The phrase HERE RESOLVES name is used to resolve certain forward references which are made by the metacompiler (for example, the metacompiler has to know where the code for the DOCOLON action is). You should leave these alone. Otherwise, feel free to add any CODE definitions to the source code. The code for defining words and control structures (IMMEDIATE words) is rather opaque. This is because these words must also perform some action while metacompiling. For example: the 6809 Forth includes the standard word CONSTANT, to define new constants. But CONSTANTs may also appear in the 6809 kernel; we may have to define a CONSTANT while metacompiling . The EMULATE: phrase instructs the metacompiler how to handle the word CONSTANT if it is encountered. This phrase is written entirely using metacompiler words, and so may appear to be total gibberish. Likewise, IF THEN and their ilk include the metacompiler phrases to build and resolve branches in the 6809 image. Some Forth metacompilers bury this code inside the compiler. This makes for prettier target code, but if you change the way branches work (for example), you have to perform surgery on the metacompiler. I preferred to make these actions easily changeable, and so I designed Chromium to put them in the target source code. (The most horrific examples are the definitions of TENDLOOP and TS\", which actually extend the metacompiler vocabulary in the middle of the target source code.) If you're new to Forth and the metacompiler, it's best to just accept these as given. \"Ordinary\" colon definitions are easy to add. Just follow the example of the rest of the 6809 source code. You can even make CREATE..DOES> definitions, as long as you don't need to use them within the metacompiler. FUTURE WORK On a 1 MHz 6809, a line of text input takes a noticeable time to process (up to 1 second at a rough estimate). This is partly becuase so much of the interpreter is written in high-level Forth, and partly because CamelForth uses a single-linked-list dictionary. These handicaps only affect compilation speed, not execution speed, but the delays can be annoying. Maybe someday I'll do an article on \"Accelerating Forth\". Currently, the User Pointer never changes. The reason we have a User Pointer is to support multitasking -- each task having separate user area, stacks, etc. I'll be working on this soon. I may also explore using the SM II's memory management to give each task a full 32K private dictionary. And of course, I intend to write a true multiprocessor Forth kernel using the shared bus. If I live long enough, a distributed Forth kernel using the serial ports (a la Transputer) is the logical next step. The source code for 6809 CamelForth, version 1.0, is available on GEnie's Forth Roundtable in the file CAM09-10.ZIP. This file includes the Chromium 2 metacompiler, complete and ready to run. You'll need a copy of F83. Then you merely type F83 CHROMIUM.SCR 1 LOAD BYE This will load the metacompiler, compile the 6809 CamelForth, and write the result to an Intel hex file 6809.HEX. Note: if you're using the CP/M or Atari ST versions of F83, you'll have to edit the load screen to delete the hex file utility, since this only works under MS- DOS. I haven't yet tested Chromium 2 with CP/M or Atari ST, so if you need assistance, please contact me. Which reminds me: I have a new email address! You can now reach me as bj@genie.com, or just BJ if you're a GEnie user. It's a lot easier to type. [Note for web publication: my current email address is here .] ERRATA There were some errors in the Harvard memory access in CamelForth/8051. The corrected file is on GEnie as CAM51-11.ZIP. I've also uploaded the current Z80 CamelForth, CAM80-12.ZIP, which incorporates all the fixes which have been published in TCJ. REFERENCES [ROD91] Rodriguez, B. J., \"B.Y.O. Assembler\", The Computer Journal [#52 (Sep/Oct 1991)] and [#54 (Jan/Feb 1992)] . [ROD92] Rodriguez, B. J., \"Principles of Metacompilation\", Forth Dimensions [XIV:3 (Sep/Oct 1992)] , [XIV:4 (Nov/Dec 1992)] , and [XIV:5 (Jan/Feb 1993)] . Describes the \"Chromium 1\" metacompiler. Source code for 6809 CamelForth is available on this site at http://www.camelforth.com/public_ftp/cam09-10.zip .","title":"MOVING FORTH 8"},{"location":"moving8.html#moving-forth-8","text":"Part 8: CamelForth for the 6809 \\ by Brad Rodriguez This article first appeared in The Computer Journal #74 (July/August 1995) . Finally, the last installment of \"Moving Forth!\" Here is the long-promised ANSI CamelForth for the Motorola 6809, and specifically for the Scroungmaster II processor board. Unlike the Z80 and 8051 CamelForth, the 6809 Forth was produced with my \"Chromium 2\" Forth metacompiler [ROD92]. Right away you'll notice two things: first, the metacompiler runs on an older Forth (F83), and so the source code is contained in 16x64 Forth \"screens\". I've converted these to an ASCII file for TCJ, but the original formatting is still evident. Second, source code for a Forth metacompiler looks like ordinary Forth code (with a few changes, which I'll discuss shortly). Thus the definition of 1+ is given as CODE 1+ 1 # ADDD, NEXT ;C The assembler used is the 6809 assembler I've described previously in TCJ [ROD91]. I typed the high-level source code directly from the already-published listings (converting to the Forth syntax in the process). Unfortunately, this was done over the space of a few days, and sometimes I worked from the Z80 listing, and sometimes the 8051... with the result that the Harvard-architecture constructs (such as I@ and IALLOT) are not consistently used in the 6809 code. This is of no consequence for the non-Harvard 6809, but I'll have to correct this before porting the Forth code to a Harvard CPU. Also, since I was working from published listings, I often neglected typing the detailed comments for the high-level words. For this I apologize. You can find how any word works by consulting the previous listings, but I shouldn't force you to do this. 6809 CAMELFORTH SOURCE CODE The 6809 CamelForth model holds top-of-stack in D, and uses the S stack pointer for the Parameter Stack. The U stack pointer is the Return Stack Pointer, and Y is the Interpreter Pointer. X is the temporary register \"W\". The 6809 direct page pointer DPR holds the high byte of the User Pointer (the low byte is assumed to be zero). The memory map for a Scroungemaster II with 8K of RAM and 8K of EPROM is as follows: 6000-797Fh RAM dictionary (for new definitions) 7980-79FFh Terminal Input Buffer 7A00-7A7Fh User Area (USER variables) 7A80-7AFFh Parameter Stack (grows downward) 7B00-7B27h HOLD area (grows downward) 7B28-7B7Fh PAD area (general purpose buffer) 7B80-7BFFh Return Stack (grows downward) E000-FFFFh Forth kernel in EPROM All of the RAM data areas are referenced to the User Pointer, whose starting value is given by UP-INIT: in this case, 7A00h. (Note the use of UP-INIT-HI for the high byte of this value) When CamelForth starts, it will set its Dictionary Pointer to DP-INIT, which must be in RAM so you can add new definitions to the Forth dictionary. These are all specified with the metacompiler's EQU directive. An EQU is like a CONSTANT, except that it is only known to the metacompiler. These EQUates take up no space in the 6809 kernel, and will not appear in the 6809 Forth's dictionary. DICTIONARY tells the metacompiler where to compile the code, in this case for an 8K EPROM from E000-FFFFh. The new dictionary is named \"ROM\", and then ROM is specified to select that dictionary. (If you're familiar with Forth vocabularies, you'll see a strong resemblance.) AKA (\"also known as\") defines a synonym for a Forth word. Since the 6809 is a non-Harvard machine, we should compile @ wherever I@ appears in the source code, and likewise for the other \"I-prefix\" (instruction-space) words. AKA will do this. These synonyms are like EQUates -- they don't appear in the 6809 dictionary. The metacompiler allows you to use forward references, i.e., Forth words which haven't been defined yet. (You must of course define them before you finish!) Often this is automatic, but AKA requires you to explicitly declare a forward reference with PRESUME. Thus PRESUME WORD AKA WORD IWORD is needed to create the IWORD synonym. @ ! HERE ALLOT and the others are PRESUMEd by the metacompiler, so we don't have to do so here. The CODE definitions are conventional. Note that you can use HERE EQU labelname to generate a label when metacompiling. (This is a function of the metacompiler, not the assembler) Also, ASM: begins a \"fragment\" of assembler code (i.e., not part of a CODE word). The phrase HERE RESOLVES name is used to resolve certain forward references which are made by the metacompiler (for example, the metacompiler has to know where the code for the DOCOLON action is). You should leave these alone. Otherwise, feel free to add any CODE definitions to the source code. The code for defining words and control structures (IMMEDIATE words) is rather opaque. This is because these words must also perform some action while metacompiling. For example: the 6809 Forth includes the standard word CONSTANT, to define new constants. But CONSTANTs may also appear in the 6809 kernel; we may have to define a CONSTANT while metacompiling . The EMULATE: phrase instructs the metacompiler how to handle the word CONSTANT if it is encountered. This phrase is written entirely using metacompiler words, and so may appear to be total gibberish. Likewise, IF THEN and their ilk include the metacompiler phrases to build and resolve branches in the 6809 image. Some Forth metacompilers bury this code inside the compiler. This makes for prettier target code, but if you change the way branches work (for example), you have to perform surgery on the metacompiler. I preferred to make these actions easily changeable, and so I designed Chromium to put them in the target source code. (The most horrific examples are the definitions of TENDLOOP and TS\", which actually extend the metacompiler vocabulary in the middle of the target source code.) If you're new to Forth and the metacompiler, it's best to just accept these as given. \"Ordinary\" colon definitions are easy to add. Just follow the example of the rest of the 6809 source code. You can even make CREATE..DOES> definitions, as long as you don't need to use them within the metacompiler.","title":"MOVING FORTH 8"},{"location":"moving8.html#future-work","text":"On a 1 MHz 6809, a line of text input takes a noticeable time to process (up to 1 second at a rough estimate). This is partly becuase so much of the interpreter is written in high-level Forth, and partly because CamelForth uses a single-linked-list dictionary. These handicaps only affect compilation speed, not execution speed, but the delays can be annoying. Maybe someday I'll do an article on \"Accelerating Forth\". Currently, the User Pointer never changes. The reason we have a User Pointer is to support multitasking -- each task having separate user area, stacks, etc. I'll be working on this soon. I may also explore using the SM II's memory management to give each task a full 32K private dictionary. And of course, I intend to write a true multiprocessor Forth kernel using the shared bus. If I live long enough, a distributed Forth kernel using the serial ports (a la Transputer) is the logical next step. The source code for 6809 CamelForth, version 1.0, is available on GEnie's Forth Roundtable in the file CAM09-10.ZIP. This file includes the Chromium 2 metacompiler, complete and ready to run. You'll need a copy of F83. Then you merely type F83 CHROMIUM.SCR 1 LOAD BYE This will load the metacompiler, compile the 6809 CamelForth, and write the result to an Intel hex file 6809.HEX. Note: if you're using the CP/M or Atari ST versions of F83, you'll have to edit the load screen to delete the hex file utility, since this only works under MS- DOS. I haven't yet tested Chromium 2 with CP/M or Atari ST, so if you need assistance, please contact me. Which reminds me: I have a new email address! You can now reach me as bj@genie.com, or just BJ if you're a GEnie user. It's a lot easier to type. [Note for web publication: my current email address is here .]","title":"FUTURE WORK"},{"location":"moving8.html#errata","text":"There were some errors in the Harvard memory access in CamelForth/8051. The corrected file is on GEnie as CAM51-11.ZIP. I've also uploaded the current Z80 CamelForth, CAM80-12.ZIP, which incorporates all the fixes which have been published in TCJ.","title":"ERRATA"},{"location":"moving8.html#references","text":"[ROD91] Rodriguez, B. J., \"B.Y.O. Assembler\", The Computer Journal [#52 (Sep/Oct 1991)] and [#54 (Jan/Feb 1992)] . [ROD92] Rodriguez, B. J., \"Principles of Metacompilation\", Forth Dimensions [XIV:3 (Sep/Oct 1992)] , [XIV:4 (Nov/Dec 1992)] , and [XIV:5 (Jan/Feb 1993)] . Describes the \"Chromium 1\" metacompiler. Source code for 6809 CamelForth is available on this site at http://www.camelforth.com/public_ftp/cam09-10.zip .","title":"REFERENCES"},{"location":"aux/editor%27s%20notes.html","text":"Editor's Notes The github sources for this website are available at: http://github.com/efurlanm/ldi/tree/main/movingforth The markdown source documents were edited using also Mark Text which is a good offline markdown document reader, and can exports the document to PDF or HTML The MkDocs static site generator was used to build the website Tables are edited in Libreoffice Calc (LC) using an html template. Once ready, just ctrl-c/ctrl-v from LC to the text Figures are edited using Libreoffice Drawn (LD) and exported as SVG. In trial-and-error tests, what looks best on both the laptop monitor and the smartphone screen are ~7 x 3-inch-sized pictures with font size 10 or 12 The original documents were converted from html to markdown using pandoc PDF files were converted to TXT using pdftotext (poppler-utils) The sources directory contains the original files that were converted to markdown Instructions to obtain a local copy of this repository: cloning-a-repository","title":"Editor's Notes"},{"location":"aux/editor%27s%20notes.html#editors-notes","text":"The github sources for this website are available at: http://github.com/efurlanm/ldi/tree/main/movingforth The markdown source documents were edited using also Mark Text which is a good offline markdown document reader, and can exports the document to PDF or HTML The MkDocs static site generator was used to build the website Tables are edited in Libreoffice Calc (LC) using an html template. Once ready, just ctrl-c/ctrl-v from LC to the text Figures are edited using Libreoffice Drawn (LD) and exported as SVG. In trial-and-error tests, what looks best on both the laptop monitor and the smartphone screen are ~7 x 3-inch-sized pictures with font size 10 or 12 The original documents were converted from html to markdown using pandoc PDF files were converted to TXT using pdftotext (poppler-utils) The sources directory contains the original files that were converted to markdown Instructions to obtain a local copy of this repository: cloning-a-repository","title":"Editor's Notes"},{"location":"aux/pandoc.html","text":"Pandoc markdown to html Example of using pandoc to convert markdown to html: $ pandoc --self-contained --from=gfm --to=html --css=github-markdown.css --template=template.html moving1.md -o moving1.html github-markdown.css comes from https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.1.0/github-markdown.css --self-contained creates a single .html file with no external dependencies, including images the template.html file can be changed as needed alternatively we can use panserver to view the markdown files: http://github.com/Marfisc/panserver","title":"Pandoc markdown to html"},{"location":"aux/pandoc.html#pandoc-markdown-to-html","text":"Example of using pandoc to convert markdown to html: $ pandoc --self-contained --from=gfm --to=html --css=github-markdown.css --template=template.html moving1.md -o moving1.html github-markdown.css comes from https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.1.0/github-markdown.css --self-contained creates a single .html file with no external dependencies, including images the template.html file can be changed as needed alternatively we can use panserver to view the markdown files: http://github.com/Marfisc/panserver","title":"Pandoc markdown to html"},{"location":"mvp/index.html","text":"MVP-Forth for the Apple II I downloaded these files from https://mirrors.apple2.org.za/ftp.apple.asimov.net/images/programming/forth/ and I tried to extract the content using CiderPress https://a2ciderpress.com/ but I only managed to extract the disk MVP Forth v1.0103.03 (1983)(Mountain View Press) - Assembly Source Code.dsk and I have no idea how to extract the others.","title":"MVP-Forth for the Apple II"},{"location":"mvp/index.html#mvp-forth-for-the-apple-ii","text":"I downloaded these files from https://mirrors.apple2.org.za/ftp.apple.asimov.net/images/programming/forth/ and I tried to extract the content using CiderPress https://a2ciderpress.com/ but I only managed to extract the disk MVP Forth v1.0103.03 (1983)(Mountain View Press) - Assembly Source Code.dsk and I have no idea how to extract the others.","title":"MVP-Forth for the Apple II"}]}