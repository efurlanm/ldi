{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<pre><code> _       ____    ___ \n| |     |  _ \\  |_ _|\n| |     | | | |  | | \n| |___  | |_| |  | | \n|_____| |____/  |___|\nLanguage Design and Implementation\n</code></pre> <p>Last edited: 2024-11-25 Website: http://efurlanm.github.io/ldi/ Repository: https://github.com/efurlanm/ldi/</p> <p>My personal notes on language design, implementation, theory, internals, performance, computer architecture, programming, applications, books, links, tips and tricks, excerpts, curiosities, and related topics.</p> <p>Please use the menu on the left of this page (or the drop-down menu if your screen is small) to access the pages on this web site. The following are just a few topics of interest.</p>"},{"location":"#works","title":"Works","text":"<ul> <li>Python Cheat Sheet - my attempt to help build the cheat sheet by describing some functions and modules that are not yet in the sheet.</li> <li>Python - my personal notes on Python-related topics that I find interesting.</li> <li>SoYouThinkYouKnowC.ipynb - based on Excerpts that are difficult to read in C.</li> <li>Moving Forth - my personal notes on Brad Rodriguez's Moving Forth.</li> </ul>"},{"location":"#repositories","title":"Repositories","text":"<p>Work I develop in other repositories.</p> <ul> <li> <p>HPC - my personal High-Performance Computing (HPC) notes. Efficient language design and implementation are crucial for HPC because they directly impact the performance, scalability, and usability of HPC applications. Languages designed specifically for HPC, such as domain-specific languages (DSLs), can optimize parallelism, manage complex computations, and provide abstractions that simplify the development of high-performance code. Additionally, well-designed compilers and interpreters for these languages can further enhance performance by optimizing code execution on HPC systems.</p> </li> <li> <p>Fortran - my personal Fortran notes. Fortran, a high-level programming language, is historically linked to HPC due to its efficient handling of numerical and scientific computations. Its syntax and features are optimized for high performance, making it ideal for large-scale simulations and mathematical models in scientific research. Consequently, Fortran remains a staple in the HPC community for its unparalleled computational efficiency.</p> </li> </ul>"},{"location":"#internals","title":"Internals","text":"<p>\"Internals\" in this case refers to the inner workings of compilers or interpreters, detailing how they are structured and operate, documenting their internal structures such as the low-level runtime library, intermediate representations, control graph analysis and optimization, machine descriptions, and more.</p> <ul> <li>GNU Compiler Collection Internals</li> <li>GNU Fortran Compiler Internals</li> <li>GNU C Compiler Internals</li> <li>CPython\u2019s internals</li> </ul>"},{"location":"#vintage-computer","title":"Vintage computer","text":"<p>Vintage computer internals, or \"computer archeology\". The first personal computers were designed with both the operating system and programming language embedded in Read-Only Memory (ROM). This integration allowed users to power on the machine and immediately start programming without the need for additional software installation. This seamless access was crucial during the early days of computing, as it enabled users to interact directly with the hardware and develop software efficiently. The built-in programming languages, often BASIC, provided a user-friendly environment for both novice and experienced programmers, making these early computers a significant step in the democratization of computing technology.</p> <ul> <li>Applesoft ROM internals: [1] [2]</li> <li>TRS-80 ROM internals: [1]</li> <li>C64 ROM internals: [1] [2]</li> <li>The Complete Spectrum ROM Disassembly: [1]</li> <li>Spectrum ROM Disassemblies: [1]</li> <li>Altair BASIC Annotated Disassembly: [1]</li> <li>HP-41 internals: [1] (or select using the menu on the left)</li> </ul>"},{"location":"#selected-books","title":"Selected books","text":"<ul> <li> <p>SETZER, V. W.; MELO, I. S. H. A Constru\u00e7\u00e3o de um Compilador (in Portuguese) - the link points to a page (in Portuguese) with my personal notes about the book.</p> </li> <li> <p>LOELIGER, R. G. Threaded Interpretive Languages: Their Design and Implementation - explores the principles and architecture of threaded interpretive languages, with a specific focus on Forth-like languages. The book provides practical examples in assembly language and discusses various implementation techniques. It serves as a comprehensive guide for understanding and creating efficient interpreters.</p> </li> <li> <p>Library with several books on compilers, computers, and programming.</p> </li> </ul>"},{"location":"#reddit","title":"Reddit","text":"<ul> <li>Programming Languages: discussion of programming languages, programming language theory, design, their syntax and compilers</li> <li>Compilers: theory and development of compilers</li> </ul>"},{"location":"#usenet","title":"Usenet","text":"<ul> <li>The comp.compilers newsgroup - forum within Usenet dedicated to discussions about compiler design, implementation, and usage. It serves as a platform for experts, enthusiasts, and learners to share knowledge, ask questions, and collaborate on projects related to compilers. Topics often include discussions on compiler construction, optimization techniques, language design, and the challenges faced in developing efficient compilers. The newsgroup is a valuable resource for anyone interested in the technical and theoretical aspects of compilers.</li> </ul>"},{"location":"#wikibooks","title":"Wikibooks","text":"<ul> <li>Compiler - from the book Introduction to Software Engineering</li> <li>Compiler Construction</li> </ul>"},{"location":"#wikipedia","title":"Wikipedia","text":"<ul> <li>Compiler</li> <li>History of compiler construction</li> <li>Threaded code</li> </ul>"},{"location":"#links-of-interest","title":"Links of interest","text":"<ul> <li>Threaded code designs for Forth interpreters, by P. Joseph Hong - techniques for implementing threaded code in Forth interpreters. It classifies these techniques to better understand the mechanisms underlying threaded interpretive languages (TILs) and discusses elements such as thread-codes, primitives, secondaries, and the interpreter's instruction pointer and return stack.</li> </ul>"},{"location":"#license","title":"License","text":"<p>My work follows the CC-BY-4.0 license. The works of other authors follow their licenses.</p> <p></p> This website is permanently under construction, so its content changes constantly."},{"location":"buildcomp/","title":"Building a Compiler (book)","text":"<p>Minhas notas pessoais sobre o livro \"A Constru\u00e7\u00e3o de um Compilador\" de W. Setzer, e I. Melo.</p> <p>O livro est\u00e1 hospedado no Internet Archive (https://archive.org/details/a-construcao-de-um-compilador-r1.2), e tamb\u00e9m est\u00e1 dispon\u00edvel na p\u00e1gina do autor.</p> <p>\u00c8 uma obra fundamental para quem deseja entender a teoria e pr\u00e1tica da constru\u00e7\u00e3o de compiladores. Publicado pela primeira vez em 1986, o livro aborda de forma did\u00e1tica e abrangente os conceitos essenciais, desde a an\u00e1lise l\u00e9xica at\u00e9 a gera\u00e7\u00e3o de c\u00f3digo-objeto. \u00c9 uma refer\u00eancia valiosa para estudantes e profissionais da \u00e1rea de ci\u00eancia da computa\u00e7\u00e3o, oferecendo uma vis\u00e3o detalhada e pr\u00e1tica sobre o desenvolvimento de compiladores.</p>"},{"location":"buildcomp/#extensao-do-analisador-sintatico","title":"Extens\u00e3o do analisador sint\u00e1tico","text":"<ul> <li>PINTO, T. T. S. GGLL: um gerador de analisadores sint\u00e1ticos para gram\u00e1ticas gr\u00e1ficas LL(1). 2014. text \u2013 Universidade de S\u00e3o Paulo, 2014. DOI 10.11606/D.45.2014.tde-23012015-075452. Available at: http://www.teses.usp.br/teses/disponiveis/45/45134/tde-23012015-075452/.</li> </ul> <p>Resumo: Este trabalho tem como fulcro o desenvolvimento de um gerador de analisadores sint\u00e1ticos do tipo top-down para gram\u00e1ticas LL(1) com entrada gr\u00e1fica da gram\u00e1tica, bem como uma compara\u00e7\u00e3o do mesmo com outros geradores em uso no mercado. Como resultado foi obtido um gerador totalmente funcional, e foi mostrado como ele \u00e9 superior aos outros analisadores. S\u00e3o descritos detalhes da implementa\u00e7\u00e3o e foi elaborado um manual de uso do sistema implementado em Java independente de ambientes de programa\u00e7\u00e3o.</p>"},{"location":"buildcomp/#referencias","title":"Refer\u00eancias","text":"<ul> <li>AHO, A. V.; ULLMAN, J. D. The Theory of Parsing, Translation, and Compiling. Later Printing edition. Englewood Cliffs, N.J: Prentice Hall, 1972. Available at: https://www.google.com.br/books/edition/_/EZImAAAAMAAJ/.</li> <li>BRESSAN, G. Linguagens de Implementa\u00e7\u00e3o de Sistemas e a Linguagem LAPA. 1977. text \u2013 Universidade de S\u00e3o Paulo, 1977. DOI 10.11606/D.45.1977.tde-20230303-172219. Available at: https://teses.usp.br/teses/disponiveis/45/45132/tde-20230303-172219/.</li> <li>FAPESP. Tomasz Kowaltowski - Biblioteca Virtual da FAPESP. [s. d.]. Available at: https://bv.fapesp.br/pt/pesquisador/92611/tomasz-kowaltowski/.</li> <li>GRIES, D. Compiler Construction for Digital Computers. New York: Wiley, 1971. Available at: https://www.google.com.br/books/edition/Compiler_Construction_for_Digital_Comput/CJUEAQAAIAAJ/.</li> <li>HOPCROFT, J. E.; ULLMAN, J. D. Formal languages and their relation to automata. USA: Addison-Wesley Longman Publishing Co., Inc., 1969. Available at: https://dl.acm.org/doi/book/10.5555/1096945.</li> <li>JENSEN, K.; WIRTH, N. PASCAL User Manual and Report. New York: Springer-Verlag, 1974. Available at: https://archive.org/details/h42_Pascal_User_Manual_and_Report_Second_Edition.</li> <li>KNUTH, D. E. The Art of Computer Programming. [S. l.]: Reading, Mass.\u202f: Addison-Wesley, 1997. Available at: http://archive.org/details/artofcomputerpro0001knut_l0h13rdedition.</li> <li>KOWALTOWSKI, T. Implementa\u00e7\u00e3o de linguagens de programa\u00e7\u00e3o. [S. l.]: Guanabara Dois, 1983. Available at: https://scholar.google.com/scholar?cluster=6128347645525656087&amp;hl=en&amp;oi=scholarr.</li> <li>LEWIS, P. M.; STEARNS, R. E. Syntax-Directed Transduction. J. ACM, vol. 15, no. 3, p. 465\u2013488, 1 Jul. 1968. DOI 10.1145/321466.321477. Available at: https://dl.acm.org/doi/10.1145/321466.321477.</li> <li>MELO, I. S. H. de. Alguns t\u00f3picos de compila\u00e7\u00e3o e uma implementa\u00e7\u00e3o da Linguagem Lapa para o Computador Pade. 1978. 1978. Available at: https://bdtd.ibict.br/vufind/Record/USP_25471acc314b810d90b5496267a6b02a.</li> <li>NAUR, P. Revised Report on the Algorithmic Language ALGOL 60. Annual Review in Automatic Programming, vol. 4, p. 217\u2013258, 1964. Available at: https://www.sciencedirect.com/science/article/pii/0066413864900205.</li> <li>RECHENBERG, P. Sackgassenfreie Syntaxanalyse. Elektronische Rechenanlagen, vol. 15, no. 3,4, p. 119-125,170-176, 1973. Available at: https://www.degruyter.com/document/doi/10.1524/itit.1973.15.16.119/pdf.</li> <li>RIPLEY, G. D.; DRUSEIKIS, F. C. Towards a Compiler Error Recovery Effectiveness Rating. Technical Report. Tucson, Arizona: Computer Science Department, The University of Arizona, Apr. 1970. Available at: https://www.amazon.com/Towards-compiler-recovery-effectiveness-rating/dp/B0006XBO2O.</li> <li>ROSENKRANTZ, D. J.; STEARNS, R. E. Properties of Deterministic Top-Down Grammars. Information and Control, vol. 17, no. 3, p. 226\u2013256, 1970. Available at: https://core.ac.uk/download/pdf/82034929.pdf.</li> <li>SALOMAA, A. Theory of Automata. Oxford: Pergamon Press, 1969. Available at: https://archive.org/details/theoryofautomata0000salo.</li> <li>SANCHES, M. M. Portabilidade de Compiladores. 1979. Master\u2019s Thesis \u2013 Instituto de Matem\u00e1tica e Estat\u00edstica da USP, S\u00e3o Paulo, 1979. Available at: https://repositorio.usp.br/item/000711147/.</li> <li>SETZER, V. W. Non-recursive Top-down Syntax Analysis. Software: Practice and Experience, vol. 9, no. 3, p. 237\u2013245, 1979. Available at: https://www.academia.edu/113474332/Non_recursive_top_down_syntax_analysis/.</li> <li>VELOSO, P. A. S. M\u00e1quinas e Linguagens: uma Introdu\u00e7\u00e3o \u00e0 Teoria de Aut\u00f4matos. S\u00e3o Paulo: Escola de Computa\u00e7\u00e3o, Instituto de Matem\u00e1tica e Estat\u00edstica da USP, 1979.</li> <li>WIJNGAARDEN, A. van; OTHERS. Revised Report on the Algorithmic Language ALGOL 68. Acta Informatica, vol. 5, no. 1\u20133, p. 1\u2013236, 1975. Available at: https://archive.org/details/revisedreportona0000unse.</li> <li>WIRTH, N. The Design of a PASCAL Compiler. Software: Practice and Experience, vol. 1, no. 4, p. 309\u2013333, 1971. DOI 10.1002/spe.4380010403. Available at: https://onlinelibrary.wiley.com/doi/abs/10.1002/spe.4380010403.</li> <li>WIRTH, Niklaus. Algorithms + Data Structures = Programs. Englewood Cliffs, New York: Prentice-Hall, 1976. Available at: https://archive.org/details/algorithms-and-data-structures-niklaus-wirth/.</li> <li>WIRTH, Niklaus. On \u201cPASCAL\u201d, Code Generation, and the CDC 6000 Computer, n. STAN-CS-72-257. Stanford, California: Computer Science Department, Stanford University, Feb. 1972. Available at: https://archive.org/download/bitsavers_stanfordcs2576600PASCALFeb72_1515774/STAN-CS-72-257_6600_PASCAL_Feb72_text.pdf.</li> </ul>"},{"location":"buildcomp/#referencias-com-comentarios","title":"Refer\u00eancias com coment\u00e1rios","text":"<ul> <li>RECHENBERG, P. Sackgassenfreie Syntaxanalyse. Elektronische Rechenanlagen, vol. 15, no. 3,4, p. 119-125,170-176, 1973. Available at: https://www.degruyter.com/document/doi/10.1524/itit.1973.15.16.119/pdf.<ul> <li>O artigo discute um m\u00e9todo inovador para a an\u00e1lise sint\u00e1tica que elimina a possibilidade de deadlocks. Rechenberg prop\u00f5e a integra\u00e7\u00e3o de t\u00e9cnicas de an\u00e1lise top-down e bottom-up, desenvolvendo um algoritmo que transforma gram\u00e1ticas complexas em vers\u00f5es mais manej\u00e1veis. Este algoritmo facilita a an\u00e1lise sint\u00e1tica de diversas linguagens de programa\u00e7\u00e3o, proporcionando uma abordagem mais eficiente e robusta. Os resultados demonstram que a t\u00e9cnica \u00e9 aplic\u00e1vel a uma ampla gama de contextos, potencialmente revolucionando a forma como a an\u00e1lise sint\u00e1tica \u00e9 conduzida em sistemas de compila\u00e7\u00e3o modernos.</li> </ul> </li> </ul> <p>\u00daltima edi\u00e7\u00e3o: 2017-11-25</p>"},{"location":"Moving_Forth/","title":"MOVING FORTH","text":"<pre><code> __  __            _               _____          _   _     \n|  \\/  | _____   _(_)_ __   __ _  |  ___|__  _ __| |_| |__  \n| |\\/| |/ _ \\ \\ / / | '_ \\ / _` | | |_ / _ \\| '__| __| '_ \\ \n| |  | | (_) \\ V /| | | | | (_| | |  _| (_) | |  | |_| | | |\n|_|  |_|\\___/ \\_/ |_|_| |_|\\__, | |_|  \\___/|_|   \\__|_| |_|\n                           |___/ \nAuthor: Brad Rodriguez\nEditor: Eduardo Furlan\n</code></pre> <p>Last edited: 2022-02-04 Repository: http://github.com/efurlanm/ldi/tree/main/docs-src/Moving_Forth/ Sources: http://www.bradrodriguez.com/papers/</p> <p>I decided to create this documentation because it was difficult for me to read, study and learn easily using the original documentation, plus the fact that I enjoy taking notes as I read. There were broken links, bad formatting on the smartphone screen, files were scattered, and so on, so I decided to put everything in one place, fix broken links, add more useful links and comments, move the pictures to SVG, and format it a little better to make the consultation and study easier. Everything I've done is under the CC BY 4.0 license, and all original sources are under the author's original license.</p> <p>Forth is a procedural, stack-oriented programming language and interactive environment designed by Charles H. Moore in 1968 at the United States National Radio Astronomy Observatory (NRAO), to help control radio telescopes. Today it is used in numerous spacecraft, such as the Rosetta/Philae probe which uses 10 RTX2010 processors that support direct execution of Forth. NASA has a list of space-related applications of the Forth, compiled by James Rash, at Goddard Space Flight Center Greenbelt, Maryland. Forth is generally targeted at small embedded systems and microcontrollers like the STM8 used in various consumer devices like chinese gadgets. What draws my attention to Forth is the possibility of running it directly on the microcontroller using a REPL (Read-Eval-Print Loop) programming environment that allows the programmer to interact with a running program, experiment and obtain immediate results on the microcontroller, without the need, for example, for cross-compilation and complex tools, which ends up reducing development time. Other features are also useful, such as the ease of interfacing and, because it is relatively simple, it is easy to implement and optimize for a specific architecture.</p>"},{"location":"Moving_Forth/#moving-forth-a-series-on-writing-forth-kernels","title":"Moving Forth: a series on writing Forth kernels","text":"<p>This series originally appeared in The Computer Journal. Accompanying source code can be found on the CamelForth page.</p> <ul> <li>Part 1: Design Decisions in the Forth Kernel</li> <li>Part 2: Benchmarks and Case Studies of Forth Kernels</li> <li>Part 3: Demystifying DOES&gt;</li> <li>Part 4: Assemble or Metacompile?</li> <li>Part 5: The Z80 Primitives</li> <li>Part 6: The Z80 High-level Kernel</li> <li>Part 7: CamelForth for the 8051</li> <li>Part 8: CamelForth for the 6809</li> <li>Multitasking 8051 CamelForth</li> </ul>"},{"location":"Moving_Forth/#listings","title":"Listings","text":"<p>These listings are part of Moving Forth and are described in the text.</p> <ul> <li>Glossary: Glossary of words in CAMEL80.AZM</li> <li>Primitive testing code: The \"minimal\" test of the CamelForth kernel</li> <li>CAMEL80.AZM: Code Primitives</li> <li>CAMEL80H.AZM: High Level Words</li> <li>CAMEL80D.AZM: CPU and Model Dependencies</li> <li>CAMEL09: Direct-Threaded Forth model for Motorola 6809</li> </ul>"},{"location":"Moving_Forth/#the-computer-journal-tcj","title":"The Computer Journal (TCJ)","text":"<ul> <li>The Computer Journal Home Page (Wayback Machine link)</li> </ul> <p>Scanned PDF files source: http://archive.org/details/the-computer-journal</p> <ul> <li>TCJ #52: B.Y.O. Assembler (1) (3.9 MB PDF file) [1]</li> <li>TCJ #54: B.Y.O. Assembler (2) (2.7 MB PDF file) [1]</li> <li>TCJ #59: Moving Forth (2.6 MB PDF file) [1]</li> <li>TCJ #60: Moving Forth Part II (2.9 MB PDF file) [1]</li> <li>TCJ #62: Moving Forth Part III (3.0 MB PDF file) [1]</li> <li>TCJ #64: Moving Forth Part IV (3.4 MB PDF file) [1] </li> <li>TCJ #67: Moving Forth Part 5 (3.1 MB PDF file) [1] </li> <li>TCJ #69: Moving Forth Part 6 (3.7 MB PDF file) [1] </li> <li>TCJ #71: Moving Forth Part 7 (3.2 MB PDF file) [1] </li> <li>TCJ #72: Moving Forth Part 7.5 (3.1 MB PDF file) [1]</li> <li>TCJ #74: Moving Forth Part 8 (4.0 MB PDF file) [1] </li> </ul>"},{"location":"Moving_Forth/#forth-dimensions-fd","title":"Forth Dimensions (FD)","text":"<p>Source 1 : http://archive.org/details/forthdimension (scanned PDF files) Source 2 : http://www.forth.org/fd/FDcover.html (scanned PDF files)</p> <ul> <li>FD #XIII:6 \"Forth Systems Comparisons\" (21 MB PDF file) [1] [2]</li> <li>FD #XIV:3 \"Principles of Metacompilation 1\" (21 MB PDF file) [1] [2]</li> <li>FD #XIV:4 \"Principles of Metacompilation 2\" (21 MB PDF file) [1] [2]</li> <li>FD #XIV:5 \"Principles of Metacompilation 3\" &amp; \"Life in the FastForth Lane\" (22 MB PDF file) [1] [2]</li> <li>FD #XIV:5 \"Principles of Metacompilation 3\" &amp; \"Optimizing in a BSR/JSR Threaded Forth\" (22 MB PDF file) [1] [2]</li> </ul>"},{"location":"Moving_Forth/8051task/","title":"MULTITASKING 8051 CAMELFORTH","text":"<p>Brad Rodriguez, T-Recursive Technology</p> <p>This article describes a multitasking extension to the 8051 CamelForth system (described in TCJ #71 and #72). The techniques described here are not limited to Forth; they should be useful to any 8051 assembly-language programmer.</p>"},{"location":"Moving_Forth/8051task/#context-switching","title":"CONTEXT SWITCHING","text":"<p>When several tasks are sharing a processor, the information which is specific to any one task is called that task\u2019s \u201ccontext.\u201d This includes the current instruction pointer, CPU registers, subroutine return stack, and any other private data. CamelForth uses the 8051 registers as follows:</p> <p> Figure 1. 8051 register usage</p> <p></p> <p>The registers labelled \u201cscratch\u201d may be used within Forth words, but have no guaranteed value between Forth words (except that the register select bits in PSW must always be 00 in 8051 CamelForth).</p> <p>The 8051 stack pointer SP points to the last byte actually stored in the Return stack. This stack grows from internal RAM location (register) 09 upward to 7F.</p> <p>In CamelForth, each task\u2019s private data is contained within a 768-byte \u201ctask area,\u201d organized as in Figure 2.</p> <p> Figure 2. CamelForth task area</p> <p></p> <p>All of this data is addressed relative to a pointer, UAREA, whose high byte is stored in register 8. (The Task Area is page-aligned, so the low byte of this pointer is always 00.) To make another Task Area current, only this pointer need be changed. Note that the start of the Task Area is 100h bytes before UAREA.</p> <p>So, to switch the from one task\u2019s context to another, the following steps must be taken:</p> <ol> <li>Save the \u201cimportant\u201d registers and the Return stack in external RAM, with the task\u2019s private data. This is is purpose of the \u201cTask Save Area\u201d in Figure 2.</li> <li>Switch the UAREA pointer to the new task\u2019s User Variables area.</li> <li>Restore the previously-saved registers and Return stack from the new task\u2019s Task Save Area.</li> <li>Resume execution.</li> </ol> <p>The code to do this is shown in Listing 1, as a Forth word SWITCH. This word expects the address of the new task\u2019s Task Save Area on top of stack (i.e., in DPTR). Obviously, copying the Return stack out to the Task Save Area is the time-consuming step, so SWITCH includes a tight loop to copy registers N to 1 to external RAM, using R0 as the loop counter. The number of the highest register to be saved is contained in the Return stack pointer SP; this number is saved in the first byte of the Task Save Area.</p> <p>Since SWITCH is called as a subroutine, the program counter will already be pushed on the return stack (and thus saved by the copy loop). Register R0 (the Data stack pointer) is saved by copying it to R1 before the loop. DPTR doesn\u2019t need to be saved, since its contents can be discarded after the task is switched. On the other hand, R2-R5 are saved needlessly, since they don\u2019t need to be preserved across Forth words. But including them simplifies the loop, and will come in handy later.</p> <p>After SWITCH copies the current task\u2019s context out to RAM, it fetches the new task\u2019s context (specified by the address parameter passed to SWITCH). The process is simply the reverse of what was done to save the context. This assumes that the new Task Save Area contains the data saved when that task did a SWITCH. What about a brand-new task?</p> <p>The Forth word INITTASK sets up the Task Save Area for a new task. It saves 10 bytes in the Task Save Area: two bytes of return stack, and the eight registers 1 through 8. For register 8, the high byte of the User Variables area address is stored. For register 1, the low byte of the Parameter stack pointer, 0FD, is stored (this value will cause an empty stack once the task starts running). The \u201csaved\u201d return stack contains only a return address, which is where execution will begin when the task is started.</p> <p>So, to create and launch a new task:</p> <ol> <li>Reserve 768 bytes of storage for the Task Area. Call this area <code>taskname</code>. This name can be defined as a Forth CONSTANT, or by using CREATE if care is taken to keep the area page-aligned.</li> <li>Initialize the task to perform a Forth <code>word</code>, with the command <code>\u2018 word taskname INITTASK</code></li> <li>Launch the new task with the command <code>taskname SWITCH</code></li> </ol> <p>The \u201cmain\u201d CamelForth task will be suspended, and the new task will run. Beware: if the new task never does a SWITCH back to the main task, it will retain control forever!</p> <p>Listing 2 shows an example of how to define a task area in high RAM, by offsetting it below the main task\u2019s user area (thus ensuring page alignment). It also shows how to write a task that will do something and then return to the main task: after loading this program, every time you type <code>TASK1 SWITCH</code>, the 8051 will emit a bell character.</p>"},{"location":"Moving_Forth/8051task/#round-robin-task-switching","title":"ROUND-ROBIN TASK SWITCHING","text":"<p>For true multitasking, each task must run for a short time, and then hand off control to another task...making sure that all of the defined tasks get a turn. One way to do this is to have each task switch to the \u201cnext\u201d task in the list. This can be done, clumsily, with SWITCH statements, as long as the list never changes (since task addresses are hard-coded in the program). A better way is to maintain a dynamic linked list of all tasks in RAM.</p> <p>Listing 3 shows high-level words to manage a linked list of tasks. The first cell of the user variables (at offset 0 from UAREA) is reserved in CamelForth for a task link. MYTASK always returns the address of the running task area, by offseting -100h from UAREA. DETACH empties the task list, by making the running task link back to itself. (This causes an inadvertent PAUSE to simply save and restore to the running task\u2019s context.) ATTACH adds a task to the list, inserting it immediately after the running task. Finally, PAUSE just causes a switch to the next task in the list. The secret to PAUSE is that it fetches a User variable, TASKLINK. User variables are always addressed relative to the current UAREA pointer, so whenever a task runs PAUSE, it fetches its link to the \u201cnext\u201d task. In this manner, all of the tasks are linked together in a circular list. (See Figure 3.)</p> <p> Figure 3. Linked list of two tasks</p> <p></p> <p>Listing 3 also includes the \u201cbell\u201d demo, this time written with PAUSE. Every time PAUSE is typed at the keyboard, a bell character is output.</p> <p>SWITCH can also be used to implement more complex task schedulers, by defining a \u201cdispatcher\u201d task (or a \u201cdispatcher\u201d Forth word). The dispatcher might, for example, select the task having highest-priority according to some rule. This is left as an exercise for the student.</p>"},{"location":"Moving_Forth/8051task/#pre-emptive-task-switching","title":"PRE-EMPTIVE TASK SWITCHING","text":"<p>SWITCH and PAUSE require a task to voluntarily give up the CPU to other tasks. This \u201ccooperative\u201d multitasking is simple and efficient, and avoids many of the synchronization problems that can occur when many tasks share a resource. But poorly written tasks can \u201chog\u201d the CPU, and with even the best-written tasks, it\u2019s difficult to parcel out CPU time evenly.</p> <p>A preemptive multitasker uses some external event -- typically a timer interrupt -- to force a task switch. This ensures that tasks are switched regularly. But since a task switch can occur at any time -- not just between Forth words -- we must take pains to save all of the working registers that are used by CamelForth.</p> <p>SWITCH saves all of the working registers except R1-R3, DPH, DPL, ACC, B, and PSW. The simplest solution is for the interrupt to push these onto the return stack, and then call SWITCH with the address of the next task. When the round-robin returns to this task, SWITCH will return to the interrupt service routine, which will then pop these eight registers and return to wherever this task was suspended. A subroutine PREEMPT to do this is given in Listing 4.</p> <p>Note that PREEMPT fetches the same task link as does PAUSE. We can\u2019t use <code>ACALL PAUSE</code>, since the phrase <code>TASKLINK @</code> in PAUSE may destroy some registers that we haven\u2019t saved. (We could learn this by examining the kernel listing for USER and @, but it\u2019s bad form to build such hidden dependencies into kernel words.)</p> <p>Also, PREEMPT saves all of the \u201cextra\u201d registers on the Return stack, except DPH and DPL. This is because SWITCH, before returning to PREEMPT, pops DPH and DPL from the Data stack.</p> <p>Listing 4 also shows how to link PREEMPT to a timer interrupt, and initialize the timer. Listing 5 is the corresponding high-level test code. Once TASK1 is ATTACHed, the variable TICKS should increment every 65.536 msec (with a 12 MHz oscillator), and yet there should be no visible effect on normal Forth operation. Note the use of PAUSE to return control immediately to the \u201cmain\u201d task, after the interrupt is processed.</p> <p>A disadvantage of this approach is that the RETI instruction, required by the 8051\u2019s interrupt processing hardware, is not executed until the preempted task is resumed. For a simple example this is tolerable. To avoid this problem, PREEMPT should call a second copy of SWITCH, identical except that it ends with a RETI. Then PREEMPT should end with a RET.</p> <p>Also, the preemptive multitasker could be made slightly more efficient if SWITCH saved all working registers (i.e., if PREEMPT were merged into the SWITCH routine). But this adds unnecessary overhead to the \u201ccooperative\u201d SWITCH. The code presented here clearly shows the extra context-switching overhead of a preemptive multitasker.</p>"},{"location":"Moving_Forth/8051task/#listing-1","title":"LISTING 1","text":"<pre><code>;   ===============================================\n;   CamelForth Multitasker for the Intel 8051\n;   (c) 1996 Bradford J. Rodriguez\n;   Permission is granted to freely copy, modify,\n;   and distribute this program for personal or\n;   educational use. Commercial inquiries should\n;   be directed to the author at 115 First St.,\n;   #105, Collingwood, Ontario L9Y 4W3 Canada\n;   ===============================================\n\n          .equ dr1,h'01   ; r1 as direct register\n\n;   The key word of the multitasker is SWITCH.\n;   It saves the working registers AND the return\n;   stack of the currently executing task to a\n;   storage area in external RAM. Then it gets\n;   the saved registers and return stack of the\n;   new task, restores them, and continues\n;   execution wherever the new task left off.\n;\n;   Registers as they are saved:\n;   01 (R1): saved Parameter Stack pointer.\n;   02 (R2): future use\n;   03 (R3):     \"\n;   04 (R4):     \"\n;   05 (R5):     \"\n;   06 (R6): loop index\n;   07 (R7):     \"\n;   08:      P2, User Area pointer high\n;   09...N: return stack (N is given by SP)\n;\n;   DPTR is not saved, since it is consumed by\n;   SWITCH. (It is the address of the new task's\n;   save area, UAREA-100h.)\n;\n;   Note that these are stored backwards in\n;   external RAM, starting at address UAREA-100h.\n;   Thus the save area of a newly created task\n;   should look like:\n;   SP:     0Ah\n;   0A,09: init'l Program Counter, hi byte first\n;   08:     task's User Pointer high (stack page)\n;   07,06: xxx\n;   05,04: xxx\n;   03,02: xxx\n;   01:     0FDh, initial stack pointer\n;   The initial stack pointer must be FDh because\n;   of the poptos at the end of SWITCH.\n; SWITCH     a --      switch to new task\n        .drw link\n        .set link,*+1\n        .db 0,6,\"SWITCH\"\nSWITCH: mov r2,dph      ; stash new task adrs\n        mov r3,dpl\n        mov dph,UP      ; save me at UAREA-100h\n        dec dph\n        mov dpl,#h'0\n        mov dr1,r0      ; save my Pstack pointer\n; This loop copies internal RAM, from location\n; (SP) down to 01, to external RAM. 6+7n cycles.\n; The length is saved as the first byte.\n        mov a,sp        ; sp=high address,\n        movx @dptr,a    ;    =length.\n        inc dptr\n        mov r0,a        ; 00 won't be moved\nsaveregs: mov a,@r0       ; 1 cycle\n        movx @dptr,a      ; 2 cycles\n        inc dptr          ; 2 cycles\n        djnz r0,saveregs ; 2 cycles\n\n        mov dph,r2      ; now get new task\n        mov dpl,r3\n; This loop copies external RAM to internal RAM,\n; and restores SP accordingly. 6+7n cycles.\n        movx a,@dptr    ; get high address\n        inc dptr\n        mov sp,a        ; restore Rstack pointer\n        mov r0,a\ngetregs: movx a,@dptr\n        inc dptr\n        mov @r0,a\n        djnz r0,getregs\n\n;   The top of this restored return stack contains\n;   a return address in the new task. DPTR no\n;   longer contains its top-of-stack; so pop the\n;   new top of stack from RAM.\n        mov r0,dr1      ; restore Pstack pointer\n        mov p2,UP       ; set new stack page\n        ljmp poptos     ; pop TOS and return\n\n;   -----------------------------------------------\n;   INITTASK   xt a --     initialize a task area\n;   Given the xt (code address) of a Forth word to\n;   execute, and the address of a task's save area,\n;   fill in that save area so the given word will\n;   execute when that task is started.\n        .drw link\n        .set link,*+1\n        .db 0,8,\"INITTASK\"\nINITTASK: mov a,#h'0a  ; length\n        movx @dptr,a\n        inc dptr\n        movx a,@r0     ; low byte of xt\n        inc r0\n        mov r2,a\n        movx a,@r0     ; high byte of xt\n        inc r0\n        movx @dptr,a   ; store high byte first\n        inc dptr\n        mov a,r2\n        movx @dptr,a\n        inc dptr\n        mov a,dph      ; UAREA=SaveArea+100h, so\n        inc a          ; DPH+1 = UAREA high byte\n        movx @dptr,a\n        inc dptr\n        inc dptr       ; skip 6 don't-cares\n        inc dptr\n        inc dptr\n        inc dptr\n        inc dptr\n        inc dptr\n        mov a,#h'fd    ; initial Pstack pointer\n        movx @dptr,a\n        ljmp poptos\n\n</code></pre>"},{"location":"Moving_Forth/8051task/#listing-2","title":"LISTING 2","text":"<p>(MULTITASKER TEST)</p> <pre><code>HEX U0 100 - CONSTANT TASK0   ( start of \"main\" Task Area)\nTASK0 300 - CONSTANT TASK1    ( new Task Area, 768 bytes )\n                              ( lower)\n\n: TEST1   BEGIN 7 EMIT   TASK0 SWITCH AGAIN ;\n' TEST1 TASK1 INITTASK\n</code></pre>"},{"location":"Moving_Forth/8051task/#listing-3","title":"LISTING 3","text":"<p>(ROUND-ROBIN TASK LIST)</p> <pre><code>HEX -100 USER MYTASK     ( start of current Task Area)\n       0 USER TASKLINK   ( link to next task in list)\n\n( Initialize the task list to \"empty\".)\n: DETACH\n   MYTASK TASKLINK ! ;\n\n( Insert a new task into the linked list, immediately)\n( after the current task.)\n: ATTACH ( a -- )\n   TASKLINK @           ( my previous successor)\n   OVER TASKLINK !      ( new task becomes my successor)\n   SWAP 100 + ! ;       ( prev. successor becomes new)\n                        ( task's successor)\n\n( Switch to the next task in the list.)\n: PAUSE   TASKLINK @ SWITCH ;\n\n( EXAMPLE)\nDETACH\nMYTASK CONSTANT TASK0\nTASK0 300 - CONSTANT TASK1\n: TEST1    BEGIN 7 EMIT PAUSE AGAIN ;\n' TEST1 TASK1 INITTASK\nTASK1 ATTACH\n</code></pre>"},{"location":"Moving_Forth/8051task/#listing-4","title":"LISTING 4","text":"<pre><code>; -----------------------------------------------\n; PREEMPT                     force a task switch\n; If entered from an interrupt, this will cause\n; a switch to the next task in the round robin.\n; The task link must be in the first cell of the\n; user area (user variable U0). Note that this\n; is an assembler subroutine and must not be\n; called as a Forth word.\nPREEMPT: push psw     ; save regs used by SWITCH\n        push acc\n        push b\n        push dr1\n        push dr2\n        push dr3\n        lcall pushtos ; DPTR saved on Data stack!\n        mov dph,UP    ; fetch task link...\n        mov dpl,#0\n        movx a,@dptr\n        mov r2,a\n        inc dptr\n        movx a,@dptr\n        mov dpl,r2\n        mov dph,a     ; ...to DPTR\n        acall SWITCH ; switch to next task\n; Execution will resume here when the round-robin\n; comes back to this task. Note that the last\n; action of SWITCH is to restore DPH:DPL from the\n; Data stack, with \"poptos\".\n        pop dr3       ; restore regs\n        pop dr2\n        pop dr1\n        pop b\n        pop acc\n        pop psw\n        reti\n\n; -----------------------------------------------\n; Sample timer 0 interrupt, entered when timer 0\n; rolls over from FFFF to 0000. The interrupt\n; flag is automatically cleared when the\n; interrupt service routine is entered.\nCLOCK:    sjmp PREEMPT\n\n; CLOCKON starts timer 0 &amp;   enables the interrupt\n        .drw link\n        .set link,*+1\n        .db 0,7,\"CLOCKON\"\nCLOCKON: mov tmod,#h'21 ;    T1 mode 2, T0 mode 1\n        mov th0,#h'0\n        mov tl0,#h'0\n        setb tcon.4      ;   enable timer 0\n        mov ie,#h'82     ;   enable timer 0 irpt\n        ret\n\n; CLOCKOFF stops timer 0 &amp; disables the interrupt\n        .drw link\n        .set link,*+1\n        .db 0,8,\"CLOCKOFF\"\nCLOCKOFF: clr tcon.4    ; disable timer 0\n        clr ie.1        ; enable timer 0 irpt\n        ret\n</code></pre>"},{"location":"Moving_Forth/8051task/#listing-5","title":"LISTING 5","text":"<p>(PREEMPTIVE MULTITASKING TEST) (requires round-robin support words)</p> <pre><code>DETACH                     ( reset task list)\nVARIABLE TICKS\n: TEST2   BEGIN 1 TICKS +! PAUSE AGAIN ;\n' TEST2 TASK1 INITTASK\nTASK1 ATTACH               ( add TASK1 to task list)\n</code></pre>"},{"location":"Moving_Forth/camel09/","title":"Camel09","text":"<pre><code>CamelForth for the Motorola 6809  (c) 1995 Bradford J. Rodriguez\n*   Permission is granted to freely copy, modify, and          *\n*   distribute this program for personal or educational use.   *\n*   Commercial inquiries should be directed to the author at   *\n*   221 King St. E., #32, Hamilton, Ontario L8N 1B5 Canada     *\n\nDirect-Threaded Forth model for Motorola 6809\n16 bit cell, 8 bit char, 8 bit (byte) adrs unit\n  X = Forth W   temporary address register\n  Y =       IP  Interpreter Pointer\n  U =       RSP Return Stack Pointer\n  S =       PSP Parameter Stack Pointer\n  D =       TOS top parameter stack item\n DP =       UP  User Pointer (high byte)\n\nv1.0  alpha test version, 28 Apr 95\n\n\\ 6809 Source Code: boot parameters              (c) 28apr95 bjr\nHEX 0E000 FFFF DICTIONARY ROM  ROM\n   7A00 EQU UP-INIT      \\ UP must be page aligned.  Stacks,\n   7A   EQU UP-INIT-HI   \\   TIB, etc. init'd relative to UP.\n\n   6000 EQU DP-INIT      \\ starting RAM adrs for dictionary\n   \\ SM2 memory map with 8K RAM: 6000-7BFF RAM, 7C00-7FFF I/O\n\n\\ Harvard synonyms - these must all be PRESUMEd\nAKA , I,     AKA @ I@     AKA ! I!\nAKA C, IC,   AKA C@ IC@   AKA C! IC!\nAKA HERE IHERE     AKA ALLOT IALLOT\nPRESUME WORD       AKA WORD IWORD\n\n\\   6809 DTC: SCC initialization                 (c) 17apr95 bjr\nHERE EQU SCCATBL HEX\n   7C02 ,  2500 ,   \\ port address, #bytes, reset reg ptr\n   09C0 ,  0444 ,  0100 ,  0200 ,  03C0 ,  0560 ,\n   0901 ,  0A00 ,  0B50 ,  0C18 ,  0D00 ,  0E02 ,\n   0E03 ,  03C1 ,  0568 ,  0F00 ,  1010 ,  0100 ,\n\nHERE EQU SCCBTBL\n   7C00 ,  1F00 ,   \\ port address, #bytes, reset reg ptr\n   0444 ,  0100 ,  03C0 ,  0560 ,  0A00 ,  0B50 ,\n   0C18 ,  0D00 ,  0E02 ,  0E03 ,  03C1 ,  0568 ,\n   0F00 ,  1010 ,  0100 ,  \\ 0909 ,\n\nASM: HERE EQU SCCINIT   \\ set up on-board i/o\n   X ,++ LDY,   X ,+ LDB,\n   BEGIN,   X ,+ LDA,   Y 0, STA,   DECB,   EQ UNTIL,   RTS, ;C\n\n\\   6809 DTC: serial I/O                         (c) 31mar95 bjr\nHEX 7C02 EQU SCCACMD   7C03 EQU SCCADTA\n\nCODE KEY    \\ -- c    get char from serial port\n   6 # ( D) PSHS,   BEGIN,   SCCACMD LDB,   1 # ANDB,  NE UNTIL,\n   SCCADTA LDB,   CLRA,   NEXT ;C\n\nCODE KEY?   \\ -- f    return true if char waiting\n   6 # ( D) PSHS,   CLRA,   SCCACMD LDB,   1 # ANDB,\n   NE IF,   -1 # LDB,   THEN,   NEXT ;C\n\nCODE EMIT   \\ c --    output character to serial port\n   BEGIN,   SCCACMD LDA,   4 # ANDA,   NE UNTIL,\n   SCCADTA STB,   6 # ( D) PULS,   NEXT ;C\n\n\\   6809 DTC: interpreter logic                  (c) 17apr95 bjr\nASM:  HERE RESOLVES DOCOLON   HERE EQU &lt;DOCOLON&gt;\n    HEX 20 # ( Y) PSHU,   20 # PULS,   NEXT, ;C\n\nASM:  HERE RESOLVES DOCREATE   HERE EQU &lt;DOCREATE&gt;\n    10 # ( X) PULS,   6 # ( D) PSHS,   X D TFR,   NEXT, ;C\n\nCODE EXIT    \\ --     exit a colon definition\n    HEX 20 # ( Y) PULU,   NEXT ;C\n\nCODE LIT     \\ -- x   fetch inline literal to stack\n    6 # ( D) PSHS,   Y ,++ LDD,   NEXT ;C\n\nCODE EXECUTE  \\ i*x xt -- j*x   execute Forth word at 'xt'\n    D X TFR,   6 # ( D) PULS,   X 0, JMP, ;C\n\n\\   6809 DTC: stack operations                   (c) 31mar95 bjr\nCODE DUP    \\ x -- x x       duplicate top of stack\n    6 # ( D) PSHS,   NEXT ;C\n\nCODE ?DUP   \\ x -- 0 | x x   DUP if nonzero\n    0 # CMPD,   NE IF,   6 # ( D) PSHS,   THEN,   NEXT ;C\n\nCODE DROP   \\ x --           drop top of stack\n    6 # ( D) PULS,   NEXT ;C\n\nCODE SWAP   \\ x1 x2 -- x2 x1  swap top two items\n    S 0, LDX,   S 0, STD,   X D TFR,   NEXT ;C\n\nCODE OVER   \\ x1 x2 -- x1 x2 x1   per stack diagram\n    6 # ( D) PSHS,   S 2 , LDD,   NEXT ;C\n\n\\   6809 DTC: stack operations                   (c) 31mar95 bjr\nCODE ROT     \\ x1 x2 x3 -- x2 x3 x1   per stack diagram\n    S 0, LDX,   S 0, STD,   S 2 , LDD,   S 2 , STX,   NEXT ;C\n\nCODE NIP     \\ x1 x2 -- x2            per stack diagram\n    S 2 , LEAS,   NEXT ;C\n\nCODE TUCK    \\ x1 x2 -- x2 x1 x2      per stack diagram\n    S 0, LDX,   S 0, STD,   HEX 10 # ( X) PSHS,   NEXT ;C\n\nCODE &gt;R      \\ x --   R: -- x        push to return stack\n    6 # ( D) PSHU,   6 # ( D) PULS,   NEXT ;C\n\nCODE R&gt;      \\ -- x   R: x --        pop from return stack\n    6 # ( D) PSHS,   6 # ( D) PULU,   NEXT ;C\n\n\\   6809 DTC: stack operations                   (c) 31mar95 bjr\nCODE R@     \\ -- x   R: x -- x   fetch from return stack\n    6 # ( D) PSHS,   U 0, LDD,   NEXT ;C\n\nCODE SP@    \\ -- a-addr         get data stack pointer\n    6 # ( D) PSHS,   S D TFR,   NEXT ;C\n\nCODE SP!    \\ a-addr --         set data stack pointer\n    D S TFR,   6 # ( D) PULS,   NEXT ;C\n\nCODE RP@    \\ -- a-addr         get return stack pointer\n    6 # ( D) PSHS,   U D TFR,   NEXT ;C\n\nCODE RP!    \\ a-addr --         set return stack pointer\n    D U TFR,   6 # ( D) PULS,   NEXT ;C\n\n\\   6809 DTC: memory operations                  (c) 31mar95 bjr\nCODE !      \\ x a-addr --     store cell in memory\n    D X TFR,   6 # ( D) PULS,   X 0, STD,   6 # ( D) PULS,\n    NEXT ;C\n\nCODE C!     \\ char c-addr --     store char in memory\n    D X TFR,   6 # ( D) PULS,   X 0, STB,   6 # ( D) PULS,\n    NEXT ;C\n\nCODE @      \\ a-addr -- x        fetch cell from memory\n    D X TFR,   X 0, LDD,   NEXT ;C\n\nCODE C@     \\ c-addr -- char     fetch char from memory\n    D X TFR,   X 0, LDB,   CLRA,   NEXT ;C\n\n\\   6809 DTC: arithmetic operations              (c) 26apr95 bjr\nCODE +      \\ n1/u1 n2/u2 -- n3/u3   add n1+n2\n    S ,++ ADDD,   NEXT ;C\n\nCODE M+     \\ d n -- d            add single to double\n    S 2 , ADDD,   S 2 , STD,\n    6 # ( D) PULS,   0 # ADCB,   0 # ADCA,   NEXT ;C\n\nCODE -      \\ n1/u1 n2/u2 -- n3/u3   subtract n1-n2\n    S ,++ SUBD,   COMA,   COMB,   1 # ADDD,   NEXT ;C\n\nCODE NEGATE   \\ x1 -- x2     two's complement\n    COMA,   COMB,   1 # ADDD,   NEXT ;C\n\n\\   6809 DTC: logical operations                 (c) 31mar95 bjr\nCODE AND    \\ x1 x2 -- x3     logical AND\n    S ,+ ANDA,   S ,+ ANDB,   NEXT ;C\n\nCODE OR     \\ x1 x2 -- x3     logical OR\n    S ,+ ORA,    S ,+ ORB,    NEXT ;C\n\nCODE XOR    \\ x1 x2 -- c3     logical XOR\n    S ,+ EORA,   S ,+ EORB,   NEXT ;C\n\nCODE INVERT   \\ x1 -- x2       bitwise inversion\n    COMA,   COMB,   NEXT ;C\n\nCODE &gt;&lt;       \\ x1 -- x2      swap bytes\n    A B EXG,   NEXT ;C\n\n\\   6809 DTC: arithmetic operations              (c) 31mar95 bjr\nCODE 1+     \\ n1/u1 -- n2/u2         add 1 to TOS\n    1 # ADDD,   NEXT ;C\n\nCODE 1-     \\ n1/u1 -- n2/u2         subtract 1 from TOS\n    1 # SUBD,   NEXT ;C\n\nCODE 2*     \\ x1 -- x2              arithmetic left shift\n    ASLB,   ROLA,   NEXT ;C\n\nCODE 2/     \\ x1 -- x2              arithmetic right shift\n    ASRA,   RORB,   NEXT ;C\n\nCODE +!     \\ n/u a-addr --         add cell to memory\n    D X TFR,   6 # ( D) PULS,   X 0, ADDD,   X 0, STD,\n    6 # ( D) PULS,   NEXT ;C\n\n\\   6809 DTC: arithmetic operations              (c) 31mar95 bjr\nCODE LSHIFT    \\ x1 u -- x2      logical shift left u places\n    D X TFR,   6 # ( D) PULS,   X 0, LEAX,   NE IF,\n        BEGIN,   LSLB,   ROLA,   X -1 , LEAX,   EQ UNTIL,\n    THEN,   NEXT ;C\n\nCODE RSHIFT    \\ x1 u -- x2      logical shift right u places\n    D X TFR,   6 # ( D) PULS,   X 0, LEAX,   NE IF,\n        BEGIN,   LSRA,   RORB,   X -1 , LEAX,   EQ UNTIL,\n    THEN,   NEXT ;C\n\n\\   6809 DTC: comparison operations              (c) 31mar95 bjr\nCODE 0=     \\ n/u -- flag     return true if TOS=0\n    0 # CMPD,   EQ IF,\n        HERE EQU TOSTRUE   -1 # LDD,  NEXT\n    THEN,   CLRA,   CLRB,   NEXT ;C\n\nCODE 0&lt;     \\ n/u -- flag     true if TOS negative\n    TSTA,   TOSTRUE BMI,   CLRA,   CLRB,   NEXT ;C\n\nCODE =      \\ x1 x2 -- flag   test x1=x2\n    S ,++ SUBD,   TOSTRUE BEQ,   CLRA,   CLRB,   NEXT ;C\n\nCODE &lt;&gt;     \\ x1 x2 -- flag   test not equal\n    S ,++ SUBD,   TOSTRUE BNE,   CLRA,   CLRB,   NEXT ;C\n\n\\   6809 DTC: comparison operations              (c) 31mar95 bjr\nCODE &lt;      \\ n1 n2 -- flag     test n1&lt;n2, signed\n    S ,++ SUBD,   TOSTRUE BGT,   CLRA,   CLRB,   NEXT ;C\n\nCODE &gt;      \\ n1 n2 -- flag     test n1&gt;n2, signed\n    S ,++ SUBD,   TOSTRUE BLT,   CLRA,   CLRB,   NEXT ;C\n\nCODE U&lt;     \\ n1 n2 -- flag     test n1&lt;n2, unsigned\n    S ,++ SUBD,   TOSTRUE BHI,   CLRA,   CLRB,   NEXT ;C\n\nCODE U&gt;     \\ n1 n2 -- flag     test n1&gt;n2, unsigned\n    S ,++ SUBD,   TOSTRUE BLO,   CLRA,   CLRB,   NEXT ;C\n\n\\   6809 DTC: branch and loop operations         (c) 31mar95 bjr\nCODE BRANCH   \\ --         branch always\n    Y 0, LDY,   NEXT ;C\n\nCODE ?BRANCH  \\ x --      branch if TOS zero\n    0 # CMPD,   EQ IF,   6 # ( D) PULS,   Y 0, LDY,   NEXT\n                THEN,   6 # ( D) PULS,   Y 2 , LEAY,   NEXT ;C\n\nCODE (DO)     \\ n1|u1 n2|u2 --    R: -- sys1 sys2\n    D X TFR,   HEX 8000 # LDD,   S ,++ SUBD,   \\ fudg=8000-limit\n    6 # ( D) PSHU,   X D, LEAX,   10 # ( X) PSHU,   \\ start+fudg\n    6 # ( D) PULS,   NEXT ;C\n\nCODE UNLOOP   \\ --    R: sys1 sys2 --     drop loop parameters\n    U 4 , LEAU,   NEXT ;C\n\n\\   6809 DTC: branch and loop operations         (c) 31mar95 bjr\nCODE (LOOP)   \\ R: sys1 sys2 -- | sys1 sys2   run-time for LOOP\n    6 # ( D) PSHS,   U 0, LDD,   1 # ADDD,   VC IF,\n        HERE EQU TAKELOOP   U 0, STD,   Y 0, LDY,\n        6 # PULS,   NEXT\n    THEN,   Y 2 , LEAY,   U 4 , LEAU,   6 # PULS,   NEXT ;C\n\nCODE (+LOOP)  \\ n --   R: sys1 sys2 -- | sys1 sys2    for +LOOP\n    U 0, ADDD,   TAKELOOP BVC,\n    Y 2 , LEAY,   U 4 , LEAU,   6 # PULS,   NEXT ;C\n\nCODE I        \\ -- n   R: sys1 sys2 -- sys1 sys2     loop index\n    6 # ( D) PSHS,   U 0, LDD,   U 2 , SUBD,   NEXT ;C\n\nCODE J        \\ -- n   R: 4*sys -- 4*sys         2nd loop index\n    6 # ( D) PSHS,   U 4 , LDD,   U 6 , SUBD,   NEXT ;C\n\n\\   6809 DTC: multiply                           (c) 25apr95 bjr\nCODE UM*      \\ u1 u2 -- ud   16*16-&gt;32 unsigned multiply\n   16 # ( X,D) PSHS,                       \\ push temporary, u2\n   S 5 , LDA,  S 1 , LDB,  MUL,  S 2 , STD,   \\ 1lo*2lo\n   S 4 , LDA,  S 1 , LDB,  MUL,               \\ 1hi*2lo\n     S 2 , ADDB,  0 # ADCA,  S 1 , STD,\n   S 5 , LDA,  S 0, LDB,  MUL,                \\ 1lo*2hi\n     S 1 , ADDD,  S 1 , STD,  CLRA,  ROLA,      \\ cy in A\n   S 0, LDB,  S 0, STA,  S 4 , LDA,  MUL,     \\ 2hi*1hi\n     S 0, ADDD,                               \\ hi result in D\n   S 2 , LDX,  S 4 , LEAS,  S 0, STX,  NEXT ;C   \\ lo result\n\n\\   6809 DTC: divide                             (c) 25apr95 bjr\nCODE UM/MOD      \\ ud u1 -- rem quot   32/16-&gt;16 divide\n   HEX 6 # PSHS,   10 # LDX,      \\ save u1 in mem\n   S 5 , ASL,  S 4 , ROL,         \\ initial shift (lo 16)\n   BEGIN,\n      S 3 , ROL,  S 2 , ROL,   S 2 , LDD,   \\ shift left hi 16\n      CS IF,                  \\ 1xxxx: 17 bits, subtract is ok\n         S 0, SUBD,  S 2 , STD,  0FE # ANDCC,   \\ clear cy\n      ELSE,                   \\ 0xxxx: 16 bits, test subtract\n         S 0, SUBD,  CC IF,  S 2 , STD,  THEN,  \\ cs=can't subtr\n      THEN,                   \\ cy=0 if sub ok, 1 if no subtract\n      S 5 , ROL,  S 4 , ROL,  \\ rotate cy into result\n   X -1 , LEAX,  EQ UNTIL,    \\ loop 16 times\n   S 4 , LDD,  COMA,  COMB,   \\ invert to get true quot in D\n   S 2 , LDX,  S 4 , STX,  S 4 , LEAS,   \\ save rem, clean stack\n   NEXT ;C\n\n\\   6809 DTC: block and string operations        (c) 31mar95 bjr\nCODE FILL   \\ c-addr u char --    fill mem with char\n    HEX 20 # ( Y) PSHU,   30 # ( X,Y) PULS,   \\ D=char X=u Y=adr\n    0 # CMPX,  NE IF,\n        BEGIN,   Y ,+ STB,   X -1 , LEAX,   EQ UNTIL,\n    THEN,   6 # ( D) PULS,   20 # ( Y) PULU,  NEXT, ;C\n\nCODE S=    \\ c-addr1 c-addr2 u -- n    string compare 1:2\n    S 2 , ADDD,   S 2 , LDX,   S 2 , STY,     \\ X=src D=end\n    S 0, LDY,   S 0, STD,   CLRB,             \\ Y=dst B=0\n    BEGIN,   S 0, CMPX,   NE WHILE,   X ,+ LDA,   Y ,+ SUBA,\n        NE IF,   0 # SBCB,   B A TFR,   1 # ORB,\n                 HEX 30 # ( X,Y) PULS,   NEXT,   THEN,\n    REPEAT,   B A TFR,   HEX 30 # ( X,Y) PULS,   NEXT, ;C\n\n\\   6809 DTC: block and string operations        (c) 31mar95 bjr\nCODE CMOVE  \\ c-addr1 c-addr2 u --   move from bottom 1-&gt;2\n    S 2 , ADDD,   S 2 , LDX,   S 2 , STY,     \\ X=src D=end\n    S 0, LDY,   S 0, STD,                     \\ Y=dst\n    BEGIN,   S 0, CMPX,   NE WHILE,   X ,+ LDB,   Y ,+ STB,\n    REPEAT,   HEX 30 # ( X,Y) PULS,   6 # ( D) PULS,   NEXT ;C\n\nCODE CMOVE&gt;  \\ c-addr1 c-addr2 u --   move from top 1-&gt;2\n    S 2 , LDX,  X D, LEAX,   S 2 , STY,       \\ X=src D=u\n    S 0, LDY,   Y D, LEAY,                    \\ Y=dst\n    BEGIN,   S 0, CMPY,   NE WHILE,   X -, LDB,   Y -, STB,\n    REPEAT,   HEX 30 # ( X,Y) PULS,   6 # ( D) PULS,   NEXT ;C\n\n\\   6809 DTC: block and string operations        (c) 31mar95 bjr\nASM: HERE EQU SKIPEXIT   Y -1 , LEAY,\nHERE EQU SKIPDONE  HEX 20 # PSHS,  X D TFR,  20 # PULU, NEXT ;C\n\nCODE SKIP   \\ c-addr u c -- c-addr' u'   skip matching chars\n    HEX 20 # ( Y) PSHU,   30 # ( X,Y) PULS,   \\ D=char X=u Y=adr\n    0 # CMPX,   NE IF,\n        BEGIN,   Y ,+ CMPB,   SKIPEXIT BNE,   X -1 , LEAX,\n    EQ UNTIL,   THEN,   SKIPDONE BRA,  ;C\n\nCODE SCAN   \\ c-addr u c -- c-addr' u'   find matching char\n    HEX 20 # ( Y) PSHU,   30 # ( X,Y) PULS,   \\ D=char X=u Y=adr\n    0 # CMPX,   NE IF,\n        BEGIN,   Y ,+ CMPB,   SKIPEXIT BEQ,   X -1 , LEAX,\n    EQ UNTIL,   THEN,   SKIPDONE BRA,  ;C\n\n\\   6809 DTC: system dependencies                (c) 21apr95 bjr\n\n\\ These words are shorter in CODE than as colon definitions!\nCODE ALIGNED  NEXT ;C               \\ a1 -- a2  align address\nCODE ALIGN   NEXT ;C                \\ --        align HERE\nCODE CELL+   2 # ADDD,  NEXT ;C     \\ a1 -- a2  add cell size\nCODE CELLS   ASLB,  ROLA,  NEXT ;C  \\ n1 -- n2  cells-&gt;adr units\nCODE CHAR+   1 # ADDD,  NEXT ;C     \\ a1 -- a2  add char size\nCODE CHARS   NEXT ;C                \\ n1 -- n2  chars-&gt;adr units\nCODE &gt;BODY   3 # ADDD,  NEXT ;C     \\ xt -- a-addr    cfa-&gt;pfa\n\nAKA 1- CHAR-\n\\ Note: CELL, a constant, must be defined after CONSTANT.\n\n\\   6809 DTC: system dependencies                (c) 21apr95 bjr\nHEX\n: COMPILE,   , ;                 \\ xt --   append execution tokn\n: !CF       0BD OVER C! 1+ ! ;   \\ adrs cfa --   set code field\n: ,CF       HERE !CF 3 ALLOT ;   \\ adrs --     append code field\n: !COLON    -3 ALLOT &lt;DOCOLON&gt; ,CF ;   \\ --  changes last c.f.\n: ,EXIT     ['] EXIT COMPILE, ;  \\ --      append EXIT action\n: ,BRANCH   , ;                  \\ xt --   append branch instr.\n: ,DEST     , ;                  \\ dest --  append dest'n adrs\n: !DEST     ! ;                  \\ dest adr --   change dest'n\n\n\\   6809 DTC: dodoes (does&gt;) does&gt;               (c) 18apr95 bjr\n\nASM:  HERE RESOLVES DODOES   HERE EQU &lt;DODOES&gt;\n   HEX 20 # ( Y) PSHU,   20 # ( Y) PULS,   \\ adrs of DODOES code\n   10 # ( X) PULS,   6 # ( D) PSHS,   X D TFR,  \\ adrs of data\n   NEXT, ;C\nDECIMAL   \\ to keep ,CF from compiling as a hex number\n\n: (DOES&gt;)   R&gt;  LATEST @ NFA&gt;CFA  !CF ;\n\n: DOES&gt;    ['] (DOES&gt;) COMPILE,   &lt;DODOES&gt; ,CF ;   IMMEDIATE\n\n\\   6809 DTC: defining words                     (c) 21apr95 bjr\n: :   CREATE HIDE ] !COLON ;\n\n: ;   REVEAL ,EXIT  [COMPILE] [  ;   IMMEDIATE\n\n: CONSTANT   CREATE , ;CODE\n    HEX 10 # ( X) PULS,   6 # ( D) PSHS,   X 0, LDD,   NEXT, ;C\nEMULATE:  TCREATE T, MDOES&gt; T@  ;EMULATE\n\n: VARIABLE   CREATE CELL ALLOT ;\nEMULATE:  TCREATE 0 T, MDOES&gt;   ;EMULATE\n\n: USER   CREATE , ;CODE\n    HEX 10 # ( X) PULS,   6 # ( D) PSHS,       \\ get pfa in X\n    DPR A TFR,  CLRB,   X 0, ADDD,   NEXT, ;C  \\ UP+offset -&gt; D\nEMULATE:  TCREATE T, MDOES&gt; .UNDEF  ;EMULATE\n\n\\   High level: control structures               (c) 21apr95 bjr\n: IF   \\ -- adrs        conditional forward branch\n    ['] ?BRANCH ,BRANCH  HERE DUP ,DEST ;\nEMULATE:  M['] ?BRANCH T,  THERE DUP T, ;EMULATE  IMMEDIATE\n\n: THEN \\ adrs --        resolve forward branch\n    HERE SWAP !DEST ;\nEMULATE:  THERE SWAP T! ;EMULATE          IMMEDIATE\n\n: ELSE \\ adrs1 -- adrs2   branch for IF..ELSE\n    ['] BRANCH ,BRANCH  HERE DUP ,DEST\n    SWAP [COMPILE] THEN ;\nEMULATE:  M['] BRANCH T,  THERE DUP T,\n    SWAP  THERE SWAP T! ;EMULATE         IMMEDIATE\n\n\\   High level: control structures               (c) 21apr95 bjr\n: BEGIN   HERE ;  \\ -- adrs     target for backward branch\nEMULATE: THERE   ;EMULATE        IMMEDIATE\n\n: UNTIL           \\ adrs --     conditional backward branch\n    ['] ?BRANCH ,BRANCH  ,DEST ;\nEMULATE:  M['] ?BRANCH T, T, ;EMULATE  IMMEDIATE\n\n: AGAIN           \\ adrs --     unconditional backward branch\n    ['] BRANCH ,BRANCH  ,DEST ;\nEMULATE:  M['] BRANCH T,  T, ;EMULATE   IMMEDIATE\n\n: WHILE           \\ -- adrs     branch for WHILE loop\n    [COMPILE] IF ;\nEMULATE:  M['] ?BRANCH T,  THERE DUP T, ;EMULATE  IMMEDIATE\n\n\\   High level: control structures               (c) 21apr95 bjr\n: REPEAT          \\ adrs1 adrs2 ---   resolve WHILE loop\n    SWAP [COMPILE] AGAIN [COMPILE] THEN ;\nEMULATE:  SWAP  M['] BRANCH T,  T,\n    THERE SWAP T! ;EMULATE          IMMEDIATE\n\n: &gt;L   CELL LP +!  LP @ ! ;\n: L&gt;   LP @ @  CELL NEGATE LP +! ;\n\n: DO              \\ -- adrs  L: -- 0\n    ['] (DO) ,BRANCH  HERE  0 &gt;L ;\nEMULATE: M['] (DO) T,  THERE  0 T&gt;L  ;EMULATE  IMMEDIATE\n\n: LEAVE  ['] UNLOOP COMPILE,\n    ['] BRANCH ,BRANCH   HERE DUP ,DEST  &gt;L ;\nEMULATE:  M['] UNLOOP T,\n    M['] BRANCH T,  THERE DUP T, T&gt;L  ;EMULATE   IMMEDIATE\n\n\\   High level: control structures               (c) 21apr95 bjr\n: ENDLOOP   ,BRANCH ,DEST    \\ adrs xt --  L: 0 a1 a2 .. aN --\n    BEGIN L&gt; ?DUP WHILE [COMPILE] THEN REPEAT ;\n\nALSO FORTH ALSO META DEFINITIONS\n: TENDLOOP   T, T, BEGIN TL&gt; ?DUP WHILE THERE SWAP T! REPEAT ;\nPREVIOUS PREVIOUS DEFINITIONS\n\n: LOOP   ['] (LOOP) ENDLOOP ;\nEMULATE:  M['] (LOOP) TENDLOOP  ;EMULATE  IMMEDIATE\n\n: +LOOP  ['] (+LOOP) ENDLOOP ;\nEMULATE:  M['] (+LOOP) TENDLOOP  ;EMULATE  IMMEDIATE\n\n\\   High level: system variables and constants   (c) 21apr95 bjr\nHEX  2 CONSTANT CELL     \\ system dependent constant\n    20 CONSTANT BL\n    7E CONSTANT TIBSIZE\n\n\\   High level: system variables and constants   (c) 31mar95 bjr\nHEX -80 USER TIB      \\ -- a-addr   Terminal Input Buffer\n      0 USER U0       \\ -- a-addr   current user area adrs\n      2 USER &gt;IN      \\ -- a-addr   holds offset into TIB\n      4 USER BASE     \\ -- a-addr   holds conversion radix\n      6 USER STATE    \\ -- a-addr   holds compiler state\n      8 USER DP       \\ -- a-addr   holds dictionary pointer\n     0A USER 'SOURCE  \\ -- a-addr   two cells: length, address\n     0E USER LATEST   \\ -- a-addr   last word in dictionary\n     10 USER HP       \\ -- a-addr   HOLD pointer\n     12 USER LP       \\ -- a-addr   leave-stack pointer\n    100 USER S0       \\ -- a-addr   end of parameter stack\n    128 USER PAD      \\ -- a-addr   user PAD buffer/end of hold\n    180 USER L0       \\ -- a-addr   bottom of leave stack\n    200 USER R0       \\ -- a-addr   end of return stack\n\n\\   High level: arithmetic operators             (c) 31mar95 bjr\n: S&gt;D         \\ n -- d   single -&gt; double precision\n    DUP 0&lt; ;\n: ?NEGATE     \\ n1 n2 -- n3   negate n1 if n2 negative\n    0&lt; IF NEGATE THEN ;\n: ABS         \\ n1 -- n2      absolute value\n    DUP ?NEGATE ;\n: DNEGATE     \\ d1 -- d2      negate, double precision\n    SWAP INVERT SWAP INVERT 1 M+ ;\n: ?DNEGATE    \\ d1 n -- d2    negate d1 if n negative\n    0&lt; IF DNEGATE THEN ;\n: DABS        \\ d1 -- d2      absolute value, double precision\n    DUP ?DNEGATE ;\n\n\\   High level: arithmetic operators             (c) 31mar95 bjr\n: M*          \\ n1 n2 -- d       signed 16*16-&gt;32 multiply\n    2DUP XOR &gt;R\n    SWAP ABS SWAP ABS UM*\n    R&gt; ?DNEGATE ;\n\n: SM/REM      \\ d1 n1 -- n2 n3   symmetric signed division\n    2DUP XOR &gt;R\n    OVER &gt;R\n    ABS &gt;R DABS R&gt; UM/MOD\n    SWAP R&gt; ?NEGATE\n    SWAP R&gt; ?NEGATE ;\n\n\\   High level: arithmetic operators             (c) 31mar95 bjr\n: FM/MOD      \\ d1 n1 -- n2 n3   floored signed division\n    DUP &gt;R\n    SM/REM\n    DUP 0&lt; IF\n        SWAP R&gt; +\n        SWAP 1-\n    ELSE  R&gt; DROP  THEN ;\n\n: *          \\ n1 n2 -- n3        signed multiply\n    M* DROP ;\n: /MOD       \\ n1 n2 -- n3 n4     signed divide/remainder\n    &gt;R S&gt;D R&gt; FM/MOD ;\n: /          \\ n1 n2 -- n3        signed divide\n    /MOD NIP ;\n\n\\   High level: arithmetic operators             (c) 31mar95 bjr\n: MOD         \\ n1 n2 -- n3       signed remainder\n    /MOD DROP ;\n: */MOD       \\ n1 n2 n3 -- n4 n5   n1*n2/n3, remainder&amp;quotient\n    &gt;R M* R&gt; FM/MOD ;\n: */          \\ n1 n2 n3 -- n4      n1*n2/n3\n    */MOD NIP ;\n\n: MAX         \\ n1 n2 -- n3         signed maximum\n    2DUP &lt; IF SWAP THEN DROP ;\n: MIN         \\ n1 n2 -- n3         signed minimum\n    2DUP &gt; IF SWAP THEN DROP ;\n\n\\   High level: double operators                 (c) 31mar95 bjr\n: 2@          \\ a-addr -- x1 x2     fetch 2 cells\n    DUP CELL+ @ SWAP @ ;\n: 2!          \\ x1 x2 a-addr --     store 2 cells\n    SWAP OVER ! CELL+ ! ;\n: 2DROP       \\ x1 x2 --            drop 2 cells\n    DROP DROP ;\n: 2DUP        \\ x1 x2 -- x1 x2 x1 x2   dup top 2 cells\n    OVER OVER ;\n: 2SWAP       \\ x1 x2 x3 x4 -- x3 x4 x1 x2    per diagram\n    ROT &gt;R ROT R&gt; ;\n: 2OVER       \\ x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2   per diagram\n    &gt;R &gt;R 2DUP R&gt; R&gt; 2SWAP ;\n\n\\   High level: input/output                     (c) 31mar95 bjr\nHEX\n: COUNT       \\ c-addr1 -- c-addr2 u    counted-&gt;addr/length\n    DUP CHAR+ SWAP C@ ;\n: CR          \\ --                      output newline\n    0D EMIT 0A EMIT ;\n: SPACE       \\ --                      output a space\n    BL EMIT ;\n: SPACES      \\ u --                    output u spaces\n    BEGIN DUP WHILE SPACE 1- REPEAT DROP ;\n: UMIN        \\ u1 u2 -- u              unsigned minimum\n    2DUP U&gt; IF SWAP THEN DROP ;\n: UMAX        \\ u1 u2 -- u              unsigned maximum\n    2DUP U&lt; IF SWAP THEN DROP ;\n\n\\   High level: input/output                     (c) 31mar95 bjr\n: ACCEPT      \\ c-addr +n -- +n'   get line from terminal\n    OVER + 1- OVER\n    BEGIN KEY\n    DUP 0D &lt;&gt; WHILE\n        DUP EMIT\n        DUP 8 = IF  DROP 1-  &gt;R OVER R&gt; UMAX\n              ELSE  OVER C!  1+ OVER UMIN\n        THEN\n    REPEAT\n    DROP NIP SWAP - ;\n\n: TYPE        \\ c-addr +n --        type line to terminal\n    ?DUP IF\n        OVER + SWAP DO I C@ EMIT LOOP\n    ELSE DROP THEN ;\n\n\\   High level: input/output                     (c) 31mar95 bjr\n: (S\")        \\ -- c-addr u        run-time code for S\"\n    R&gt; COUNT 2DUP + ALIGN &gt;R ;\n\nALSO FORTH ALSO META DEFINITIONS\n: TS\"   22 WORD DUP C@ 1+ THERE OVER TALLOT SWAP &gt;TCMOVE ;\nPREVIOUS PREVIOUS DEFINITIONS\n\n: S\"          \\ --             compile in-line string\n    ['] (S\") COMPILE,\n    22 WORD   C@ 1+ ALIGNED  ALLOT ;\nEMULATE:  M['] (S\") T,  TS\"  ;EMULATE   IMMEDIATE\n\n: .\"          \\ --             compile string to print\n    [COMPILE] S\" ['] TYPE COMPILE, ;\nEMULATE:  M['] (S\") T,  TS\"  M['] TYPE T,  ;EMULATE  IMMEDIATE\n\n\\   High level: numeric output                   (c) 31mar95 bjr\n: UD/MOD      \\ ud1 u2 -- u3 ud4     32/16-&gt;32 divide\n    &gt;R 0 R@ UM/MOD  ROT ROT R&gt; UM/MOD ROT ;\n: UD*         \\ ud1 u2 -- ud3        32*16-&gt;32 multiply\n    DUP &gt;R UM* DROP  SWAP R&gt; UM* ROT + ;\n: HOLD        \\ char --             add char to output string\n    -1 HP +!  HP @ C! ;\n: &lt;#          \\ --                  begin numeric conversion\n    PAD HP ! ;\n: &gt;DIGIT      \\ n -- c              convert to 0..9A..Z\n    DUP 9 &gt; 7 AND + 30 + ;\n: #           \\ ud1 -- ud2          convert 1 digit of output\n    BASE @ UD/MOD ROT &gt;DIGIT HOLD ;\n: #S          \\ ud1 -- ud2          convert remaining digits\n    BEGIN # 2DUP OR 0= UNTIL ;\n\n\\   High level: numeric output                   (c) 31mar95 bjr\n: #&gt;          \\ ud1 -- c-addr u      end conversion, get string\n    2DROP HP @ PAD OVER - ;\n: SIGN        \\ n --                 add minus sign if n&lt;0\n    0&lt; IF 2D HOLD THEN ;\n: U.          \\ u --                 display u unsigned\n    &lt;# 0 #S #&gt; TYPE SPACE ;\n: .           \\ n --                 display n signed\n    &lt;# DUP ABS 0 #S ROT SIGN #&gt; TYPE SPACE ;\n: DECIMAL     \\ --                   set number base to decimal\n    0A BASE ! ;\n: HEX         \\ --                   set number base to hex\n    10 BASE ! ;\n\n\\   High level: dictionary management            (c) 31mar95 bjr\n: HERE        \\ -- addr              returns dictionary ptr\n    DP @ ;\n: ALLOT       \\ n --             allocate n adr units in dict\n    DP +! ;\n: ,           \\ x --             append cell to dict\n    HERE !  1 CELLS ALLOT ;\n: C,          \\ char --          append char to dict\n    HERE C!  1 CHARS ALLOT ;\n\n\\   High level: interpreter                      (c) 31mar95 bjr\n: SOURCE      \\ -- adr n         current input buffer\n    'SOURCE 2@ ;\n: /STRING     \\ a u n -- a+n u-n           trim string\n    ROT OVER + ROT ROT - ;\n: &gt;COUNTED    \\ src n dst --        copy to counted string\n    2DUP C! CHAR+ SWAP CMOVE ;\n: WORD        \\ char -- c-addr      word delim'd by char\n    DUP  SOURCE &gt;IN @ /STRING\n    DUP &gt;R   ROT SKIP\n    OVER &gt;R  ROT SCAN\n    DUP IF CHAR- THEN\n    R&gt; R&gt; ROT -   &gt;IN +!\n    TUCK -\n    HERE &gt;COUNTED   HERE\n    BL OVER COUNT + C! ;\n\n\\   High level: interpreter                      (c) 31mar95 bjr\n: NFA&gt;LFA     \\ nfa -- lfa      name adr -&gt; link field\n    3 - ;\n: NFA&gt;CFA     \\ nfa -- cfa      name adr -&gt; code field\n    COUNT 7F AND + ;\n: IMMED?      \\ nfa -- f        fetch immediate flag\n    1- C@ ;\n: FIND        \\ c-addr -- c-addr 0/1/-1   not found/immed/normal\n    LATEST @ BEGIN              \\ -- a nfa\n        2DUP OVER C@ CHAR+      \\ -- a nfa a nfa n+1\n        S= DUP IF   DROP  NFA&gt;LFA @ DUP  THEN   \\ -- a link link\n    0= UNTIL                    \\ -- a nfa  OR  a 0\n    DUP IF                      \\ if found, check immed status\n        NIP DUP NFA&gt;CFA         \\ -- nfa xt\n        SWAP IMMED?  0= 1 OR    \\ -- xt 1/-1\n    THEN ;\n\n\\   High level: interpreter                      (c) 31mar95 bjr\n: LITERAL     \\ x --       append numeric literal\n    STATE @ IF  ['] LIT COMPILE,  I, THEN ;\nEMULATES TLITERAL                       IMMEDIATE\n\nHEX\n: DIGIT?      \\ c -- n -1 | x 0    true if c is a valid digit\n   DUP 39 &gt; 100 AND +              \\ silly looking,\n   DUP 140 &gt; 107 AND -  30 -       \\ but it works!\n   DUP BASE @ U&lt; ;\n: ?SIGN       \\ adr n -- adr' n' f   get optional sign\n   OVER C@                 \\ -- adr n c\n   2C - DUP ABS 1 = AND    \\ -- +=-1, -=+1, else 0\n   DUP IF 1+               \\ +=0, -=+2        NZ=negative\n       &gt;R 1 /STRING R&gt;     \\ adr' n' f\n   THEN ;\n\n\\   High level: interpreter                      (c) 31mar95 bjr\n: &gt;NUMBER     \\ ud adr u -- ud' adr' u'  conv. string to number\n    BEGIN DUP WHILE\n        OVER C@ DIGIT?\n        0= IF DROP EXIT THEN\n        &gt;R 2SWAP BASE @ UD*\n        R&gt; M+ 2SWAP   1 /STRING\n    REPEAT ;\n\n: ?NUMBER     \\ c-addr -- n -1 | c-addr 0     string-&gt;number\n    DUP  0 0 ROT COUNT     \\ -- ca ud adr n\n    ?SIGN &gt;R  &gt;NUMBER      \\ -- ca ud adr' n'\n    IF  R&gt; 2DROP 2DROP 0   \\ -- ca 0   (error)\n    ELSE  2DROP NIP R&gt;\n        IF NEGATE THEN -1  \\ -- n -1   (ok)\n    THEN ;\n\n\\   High level: interpreter                      (c) 31mar95 bjr\n: INTERPRET   \\ i*x c-addr u -- j*x   interpret given buffer\n    'SOURCE 2!  0 &gt;IN !\n    BEGIN  BL WORD  DUP C@ WHILE        \\ -- textadr\n        FIND  ?DUP IF                   \\ -- xt 1/-1\n            1+ STATE @ 0= OR            \\ immed or interp?\n            IF EXECUTE ELSE COMPILE, THEN\n        ELSE                            \\ -- textadr\n            ?NUMBER IF  [COMPILE] LITERAL  \\ converted ok\n            ELSE  COUNT TYPE 3F EMIT CR ABORT  THEN  \\ error\n        THEN\n    REPEAT DROP ;\n\n: EVALUATE   \\ i*x c-addr u -- j*x   interpret string\n    'SOURCE 2@ &gt;R &gt;R  &gt;IN @ &gt;R   INTERPRET\n    R&gt; &gt;IN !  R&gt; R&gt; 'SOURCE 2!  ;\n\n\\   High level: interpreter                      (c) 28apr95 bjr\n: QUIT        \\ --   R: i*x --    interpret from keyboard\n    L0 LP !  R0 RP!  0 STATE !    \\ reset stacks, state\n    BEGIN\n        TIB DUP TIBSIZE ACCEPT SPACE\n        INTERPRET\n        STATE @ 0= IF CR .\" OK \" THEN\n    AGAIN ;\n\n: ABORT       \\ i*x --  R: j*x --   clear stack and QUIT\n    S0 SP!  QUIT ;\n: ?ABORT      \\ f c-addr u --       abort and print message\n    ROT IF TYPE ABORT THEN 2DROP ;\n: ABORT\"      \\ i*x 0 -- i*x        abort, print inline msg\n    [COMPILE] S\" ['] ?ABORT COMPILE, ;\nEMULATE:  M['] (S\") T,  TS\"  M['] ?ABORT T,  ;EMULATE IMMEDIATE\n\n\\   High level: interpreter                      (c) 31mar95 bjr\n: '           \\ -- xt        find word in dictionary\n    BL WORD FIND   0= ABORT\" ?\" ;\n: CHAR        \\ -- char      parse ASCII character\n    BL WORD 1+ C@ ;\n: [CHAR]      \\ --           compile character literal\n    CHAR  ['] LIT COMPILE,  I, ;  IMMEDIATE\n\n: (           \\ --           skip input until )\n    29 WORD DROP ;           IMMEDIATE\n\n\\   High level: compiler                         (c) 31mar95 bjr\n: CREATE      \\ --        create an empty definition\n    LATEST @ I, 0 IC,       \\ link &amp; immediate field\n    IHERE LATEST !          \\ new \"latest\" link\n    BL IWORD IC@ 1+ IALLOT  \\ name field\n    &lt;DOCREATE&gt; ,CF ;          \\ code field\n\n: RECURSE     \\ --        recurse current definition\n    LATEST @ NFA&gt;CFA COMPILE, ;  IMMEDIATE\n\n: [           \\ --        enter interpretive state\n    0 STATE ! ;  IMMEDIATE\n: ]           \\ --        enter compiling state\n    -1 STATE ! ;\n\n\\   High level: compiler                         (c) 31mar95 bjr\nHEX\n: HIDE        \\ --        \"hide\" latest definition\n    LATEST @ DUP  IC@ 80 OR SWAP IC! ;\n: REVEAL      \\ --        \"reveal\" latest definition\n    LATEST @ DUP  IC@ 7F AND SWAP IC! ;\n: IMMEDIATE   \\ --        make last definition immediate\n    1 LATEST @ 1- IC! ;\n: [']         \\ --        find word and compile as literal\n    '  ['] LIT COMPILE,  I, ;  IMMEDIATE\n\n\\   High level: compiler                         (c) 31mar95 bjr\n: POSTPONE    \\ --    postpone compile action of word\n    BL WORD FIND  DUP 0= ABORT\" ?\"  \\ find word\n    0&lt; IF  ['] LIT COMPILE,  I,    \\ non-immed: compiles later\n           ['] COMPILE, COMPILE,   \\ add \"LIT xt COMPILE,\" to df\n    ELSE  COMPILE,  THEN ;  IMMEDIATE   \\ immed: compile into df\n\n\\   High level: other operations                 (c) 25apr95 bjr\n: WITHIN   \\ n1|u1 n2|u2 n3|u3 -- f   n2&lt;=n1&lt;n3?\n    OVER - &gt;R - R&gt; U&lt; ;\n\n: MOVE     \\ addr1 addr2 u --    smart move\n    &gt;R 2DUP SWAP DUP R@ +\n    WITHIN IF  R&gt; CMOVE&gt;  ELSE  R&gt; CMOVE  THEN ;\n\n: DEPTH    \\ -- n\n    SP@ S0 SWAP - 2/ ;      \\ 16 BIT VERSION!\n\n: ENVIRONMENT?   \\ c-addr u -- i*x true    system query\n    2DROP 0 ;    \\          -- false\n\n\\   High level: utility words                    (c) 25apr95 bjr\n: WORDS         \\ --     list all words in dictionary\n    LATEST @ BEGIN\n        DUP COUNT TYPE SPACE\n        NFA&gt;LFA @\n    DUP 0= UNTIL\n    DROP ;\nEMULATES WORDS\n\n: .S            \\ --     print contents of stack\n    SP@ S0 - IF\n        SP@ S0 2 - DO  I @ h.  -2 +LOOP\n    THEN ;\nEMULATES .S\n\n\\   High level: startup                          (c) 25apr95 bjr\n: COLD        \\ --        cold start Forth system\n    UINIT U0 #INIT CMOVE\n    .\" 6809 CamelForth v1.0  25 Apr 95\"  CR\n    ABORT ;\n\n\\   Testing words\nHEX\n: .H  ( n - )   0F AND 30 + DUP 39 &gt; IF 7 + THEN EMIT ;\n: .HH ( n - )   DUP 2/ 2/ 2/ 2/ .H .H ;\n: .HHHH ( n - )   DUP 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ .HH .HH ;\n: H.  ( n - )   .HHHH SPACE ;\n: .B  ( a - a+1 )   DUP C@ .HH SPACE 1+ ;\n: DUMP ( a n - )  0 DO  DUP CR H. SPACE\n    .B .B .B .B .B .B .B .B SPACE .B .B .B .B .B .B .B .B\n    10 +LOOP DROP ;\n\n\\   6809 DTC: reset initialization               (c) 25apr95 bjr\nASM: HERE EQU ENTRY   HEX\n   CLRA,  F000 STA,  INCA,  E000 STA,  INCA,  D000 STA,\n   INCA,  C000 STA,  INCA,  B000 STA,  INCA,  A000 STA,\n   INCA,  9000 STA,  INCA,  8000 STA,  \\ init mem mapping\n   UP-INIT-HI # LDA,   A DPR TFR,   \\ initial UP\n   UP-INIT 100 + # LDS,             \\ initial SP\n   UP-INIT 200 + # LDU,             \\ initial RP\n   SCCATBL # LDX,  SCCINIT JSR,     \\ init serial ports\n   SCCBTBL # LDX,  SCCINIT JSR,\n   ' COLD JMP,   ;C           \\ enter top-level Forth word\n\nASM: HERE EQU IRET   RTI,  ;C\nHERE  0FFF0 ORG    \\ 6809 hardware vectors\n  IRET ,  IRET ,  IRET ,  IRET ,    \\ tbd, SWI3, SWI2, FIRQ\n  IRET ,  IRET ,  IRET ,  ENTRY ,   \\ IRQ, SWI, NMI, RESET\nORG\n\n\\   6809 DTC: user area initialization           (c) 25apr95 bjr\nDECIMAL 18 CONSTANT #INIT   \\ # bytes of user area init data\n\nCREATE UINIT  HEX\n   0 , 0 , 0A , 0 ,         \\ reserved,&gt;IN,BASE,STATE\n   DP-INIT ,                \\ DP\n   0 , 0 ,                  \\ SOURCE init'd elsewhere\nMETA ALSO FORTH TLATEST @ T, PREVIOUS TARGET    \\ LATEST\n   0 ,                      \\ HP init'd elsewhere\n\\ Note that UINIT must be the *last* word in the kernel, in\n\\ order to set the initial LATEST as shown above.  If this is\n\\ not the last word, be sure to patch the LATEST value above.\n</code></pre>"},{"location":"Moving_Forth/camel80/","title":"Camel80","text":"<pre><code>; Listing 2.\n; ===============================================\n; CamelForth for the Zilog Z80\n; (c) 1994 Bradford J. Rodriguez\n; Permission is granted to freely copy, modify,\n; and distribute this program for personal or\n; educational use.  Commercial inquiries should\n; be directed to the author at 221 King St. E.,\n; #32, Hamilton, Ontario L8N 1B5 Canada\n;\n; CAMEL80.AZM: Code Primitives\n;   Source code is for the Z80MR macro assembler.\n;   Forth words are documented as follows:\n;x   NAME     stack -- stack    description\n;   where x=C for ANS Forth Core words, X for ANS\n;   Extensions, Z for internal or private words.\n;\n; Direct-Threaded Forth model for Zilog Z80\n; 16 bit cell, 8 bit char, 8 bit (byte) adrs unit\n;    Z80 BC = Forth TOS (top Param Stack item)\n;        HL =       W    working register\n;        DE =       IP   Interpreter Pointer\n;        SP =       PSP  Param Stack Pointer\n;        IX =       RSP  Return Stack Pointer\n;        IY =       UP   User area Pointer\n;    A, alternate register set = temporaries\n;\n; Revision history:\n;   19 Aug 94 v1.0\n;   25 Jan 95 v1.01  now using BDOS function 0Ah\n;       for interpreter input; TIB at 82h.\n;   02 Mar 95 v1.02  changed ALIGN to ALIGNED in\n;       S\" (S\"); changed ,BRANCH to ,XT in DO.\n; ===============================================\n; Macros to define Forth headers\n; HEAD  label,length,name,action\n; IMMED label,length,name,action\n;    label  = assembler name for this word\n;             (special characters not allowed)\n;    length = length of name field\n;    name   = Forth's name for this word\n;    action = code routine for this word, e.g.\n;             DOCOLON, or DOCODE for code words\n; IMMED defines a header for an IMMEDIATE word.\n;\nDOCODE  EQU 0      ; flag to indicate CODE words\nlink    DEFL 0     ; link to previous Forth word\n\nhead    MACRO   #label,#length,#name,#action\n        DW link\n        DB 0\nlink    DEFL $\n        DB #length,'#name'\n#label:\n        IF  .NOT.(#action=DOCODE)\n        call #action\n        ENDIF\n        ENDM\n\nimmed   MACRO   #label,#length,#name,#action\n        DW link\n        DB 1\nlink    DEFL $\n        DB #length,'#name'\n#label:\n        IF  .NOT.(#action=DOCODE)\n        call #action\n        ENDIF\n        ENDM\n\n; The NEXT macro (7 bytes) assembles the 'next'\n; code in-line in every Z80 CamelForth CODE word.\nnext    MACRO\n        ex de,hl\n        ld e,(hl)\n        inc hl\n        ld d,(hl)\n        inc hl\n        ex de,hl\n        jp (hl)\n        ENDM\n\n; NEXTHL is used when the IP is already in HL.\nnexthl  MACRO\n        ld e,(hl)\n        inc hl\n        ld d,(hl)\n        inc hl\n        ex de,hl\n        jp (hl)\n        ENDM\n\n; RESET AND INTERRUPT VECTORS ===================\n; ...are not used in the CP/M implementation\n; Instead, we have the...\n\n; CP/M ENTRY POINT\n        org 100h\nreset:  ld hl,(6h)   ; BDOS address, rounded down\n        ld l,0       ;    = end of avail.mem (EM)\n        dec h        ; EM-100h\n        ld sp,hl     ;      = top of param stack\n        inc h        ; EM\n        push hl\n        pop ix       ;      = top of return stack\n        dec h        ; EM-200h\n        dec h\n        push hl\n        pop iy       ;      = bottom of user area\n        ld de,1      ; do reset if COLD returns\n        jp COLD      ; enter top-level Forth word\n\n; Memory map:\n;   0080h       Terminal Input Buffer, 128 bytes\n;   0100h       Forth kernel = start of CP/M TPA\n;     ? h       Forth dictionary (user RAM)\n;   EM-200h     User area, 128 bytes\n;   EM-180h     Parameter stack, 128B, grows down\n;   EM-100h     HOLD area, 40 bytes, grows down\n;   EM-0D8h     PAD buffer, 88 bytes\n;   EM-80h      Return stack, 128 B, grows down\n;   EM          End of RAM = start of CP/M BDOS\n; See also the definitions of U0, S0, and R0\n; in the \"system variables &amp; constants\" area.\n; A task w/o terminal input requires 200h bytes.\n; Double all except TIB and PAD for 32-bit CPUs.\n\n; INTERPRETER LOGIC =============================\n; See also \"defining words\" at end of this file\n\n;C EXIT     --      exit a colon definition\n    head EXIT,4,EXIT,docode\n        ld e,(ix+0)    ; pop old IP from ret stk\n        inc ix\n        ld d,(ix+0)\n        inc ix\n        next\n\n;Z lit      -- x    fetch inline literal to stack\n; This is the primtive compiled by LITERAL.\n    head lit,3,lit,docode\n        push bc        ; push old TOS\n        ld a,(de)      ; fetch cell at IP to TOS,\n        ld c,a         ;        advancing IP\n        inc de\n        ld a,(de)\n        ld b,a\n        inc de\n        next\n\n;C EXECUTE   i*x xt -- j*x   execute Forth word\n;C                           at 'xt'\n    head EXECUTE,7,EXECUTE,docode\n        ld h,b          ; address of word -&gt; HL\n        ld l,c\n        pop bc          ; get new TOS\n        jp (hl)         ; go do Forth word\n\n; DEFINING WORDS ================================\n\n; ENTER, a.k.a. DOCOLON, entered by CALL ENTER\n; to enter a new high-level thread (colon def'n.)\n; (internal code fragment, not a Forth word)\n; N.B.: DOCOLON must be defined before any\n; appearance of 'docolon' in a 'word' macro!\ndocolon:               ; (alternate name)\nenter:  dec ix         ; push old IP on ret stack\n        ld (ix+0),d\n        dec ix\n        ld (ix+0),e\n        pop hl         ; param field adrs -&gt; IP\n        nexthl         ; use the faster 'nexthl'\n\n;C VARIABLE   --      define a Forth variable\n;   CREATE 1 CELLS ALLOT ;\n; Action of RAM variable is identical to CREATE,\n; so we don't need a DOES&gt; clause to change it.\n    head VARIABLE,8,VARIABLE,docolon\n        DW CREATE,LIT,1,CELLS,ALLOT,EXIT\n; DOVAR, code action of VARIABLE, entered by CALL\n; DOCREATE, code action of newly created words\ndocreate:\ndovar:  ; -- a-addr\n        pop hl     ; parameter field address\n        push bc    ; push old TOS\n        ld b,h     ; pfa = variable's adrs -&gt; TOS\n        ld c,l\n        next\n\n;C CONSTANT   n --      define a Forth constant\n;   CREATE , DOES&gt; (machine code fragment)\n    head CONSTANT,8,CONSTANT,docolon\n        DW CREATE,COMMA,XDOES\n; DOCON, code action of CONSTANT,\n; entered by CALL DOCON\ndocon:  ; -- x\n        pop hl     ; parameter field address\n        push bc    ; push old TOS\n        ld c,(hl)  ; fetch contents of parameter\n        inc hl     ;    field -&gt; TOS\n        ld b,(hl)\n        next\n\n;Z USER     n --        define user variable 'n'\n;   CREATE , DOES&gt; (machine code fragment)\n    head USER,4,USER,docolon\n        DW CREATE,COMMA,XDOES\n; DOUSER, code action of USER,\n; entered by CALL DOUSER\ndouser:  ; -- a-addr\n        pop hl     ; parameter field address\n        push bc    ; push old TOS\n        ld c,(hl)  ; fetch contents of parameter\n        inc hl     ;    field\n        ld b,(hl)\n        push iy    ; copy user base address to HL\n        pop hl\n        add hl,bc  ;    and add offset\n        ld b,h     ; put result in TOS\n        ld c,l\n        next\n\n; DODOES, code action of DOES&gt; clause\n; entered by       CALL fragment\n;                  parameter field\n;                       ...\n;        fragment: CALL DODOES\n;                  high-level thread\n; Enters high-level thread with address of\n; parameter field on top of stack.\n; (internal code fragment, not a Forth word)\ndodoes: ; -- a-addr\n        dec ix         ; push old IP on ret stk\n        ld (ix+0),d\n        dec ix\n        ld (ix+0),e\n        pop de         ; adrs of new thread -&gt; IP\n        pop hl         ; adrs of parameter field\n        push bc        ; push old TOS onto stack\n        ld b,h         ; pfa -&gt; new TOS\n        ld c,l\n        next\n\n; CP/M TERMINAL I/O =============================\ncpmbdos EQU 5h          ; CP/M BDOS entry point\n\n;Z BDOS   de c -- a   call CP/M BDOS\n    head BDOS,4,BDOS,docode\n        ex de,hl    ; save important Forth regs\n        pop de      ;  (DE,IX,IY) &amp; pop DE value\n        push hl\n        push ix\n        push iy\n        call cpmbdos\n        ld c,a      ; result in TOS\n        ld b,0\n        pop iy      ; restore Forth regs\n        pop ix\n        pop de\n        next\n\n;C EMIT     c --    output character to console\n;   6 BDOS DROP ;\n; warning: if c=0ffh, will read one keypress\n    head EMIT,4,EMIT,docolon\n        DW LIT,06H,BDOS,DROP,EXIT\n\n;Z SAVEKEY  -- addr  temporary storage for KEY?\n    head savekey,7,SAVEKEY,dovar\n        DW 0\n\n;X KEY?     -- f    return true if char waiting\n;   0FF 6 BDOS DUP SAVEKEY C! ;   rtns 0 or key\n; must use BDOS function 6 to work with KEY\n    head querykey,4,KEY?,docolon\n        DW LIT,0FFH,LIT,06H,BDOS\n        DW DUP,SAVEKEY,CSTORE,EXIT\n\n;C KEY      -- c    get character from keyboard\n;   BEGIN SAVEKEY C@ 0= WHILE KEY? DROP REPEAT\n;   SAVEKEY C@  0 SAVEKEY C! ;\n; must use CP/M direct console I/O to avoid echo\n; (BDOS function 6, contained within KEY?)\n    head KEY,3,KEY,docolon\nKEY1:   DW SAVEKEY,CFETCH,ZEROEQUAL,qbranch,KEY2\n        DW QUERYKEY,DROP,branch,KEY1\nKEY2:   DW SAVEKEY,CFETCH,LIT,0,SAVEKEY,CSTORE\n        DW EXIT\n\n;Z CPMACCEPT  c-addr +n -- +n'  get line of input\n;   SWAP 2 - TUCK C!      max # of characters\n;   DUP 0A BDOS DROP      CP/M Get Console Buffer\n;   1+ C@  0A EMIT ;      get returned count\n; Note: requires the two locations before c-addr\n; to be available for use.\n    head CPMACCEPT,9,CPMACCEPT,docolon\n        DW SWOP,LIT,2,MINUS,TUCK,CSTORE\n        DW DUP,LIT,0Ah,BDOS,DROP\n        DW ONEPLUS,CFETCH,LIT,0Ah,EMIT,EXIT\n\n;X BYE     i*x --    return to CP/M\n    head bye,3,bye,docode\n        jp 0\n\n; STACK OPERATIONS ==============================\n\n;C DUP      x -- x x      duplicate top of stack\n    head DUP,3,DUP,docode\npushtos: push bc\n        next\n\n;C ?DUP     x -- 0 | x x    DUP if nonzero\n    head QDUP,4,?DUP,docode\n        ld a,b\n        or c\n        jr nz,pushtos\n        next\n\n;C DROP     x --          drop top of stack\n    head DROP,4,DROP,docode\npoptos: pop bc\n        next\n\n;C SWAP     x1 x2 -- x2 x1    swap top two items\n    head SWOP,4,SWAP,docode\n        pop hl\n        push bc\n        ld b,h\n        ld c,l\n        next\n\n;C OVER    x1 x2 -- x1 x2 x1   per stack diagram\n    head OVER,4,OVER,docode\n        pop hl\n        push hl\n        push bc\n        ld b,h\n        ld c,l\n        next\n\n;C ROT    x1 x2 x3 -- x2 x3 x1  per stack diagram\n    head ROT,3,ROT,docode\n        ; x3 is in TOS\n        pop hl          ; x2\n        ex (sp),hl      ; x2 on stack, x1 in hl\n        push bc\n        ld b,h\n        ld c,l\n        next\n\n;X NIP    x1 x2 -- x2           per stack diagram\n    head NIP,3,NIP,docolon\n        DW SWOP,DROP,EXIT\n\n;X TUCK   x1 x2 -- x2 x1 x2     per stack diagram\n    head TUCK,4,TUCK,docolon\n        DW SWOP,OVER,EXIT\n\n;C &gt;R    x --   R: -- x   push to return stack\n    head TOR,2,&gt;R,docode\n        dec ix          ; push TOS onto rtn stk\n        ld (ix+0),b\n        dec ix\n        ld (ix+0),c\n        pop bc          ; pop new TOS\n        next\n\n;C R&gt;    -- x    R: x --   pop from return stack\n    head RFROM,2,R&gt;,docode\n        push bc         ; push old TOS\n        ld c,(ix+0)     ; pop top rtn stk item\n        inc ix          ;       to TOS\n        ld b,(ix+0)\n        inc ix\n        next\n\n;C R@    -- x     R: x -- x   fetch from rtn stk\n    head RFETCH,2,R@,docode\n        push bc         ; push old TOS\n        ld c,(ix+0)     ; fetch top rtn stk item\n        ld b,(ix+1)     ;       to TOS\n        next\n\n;Z SP@  -- a-addr       get data stack pointer\n    head SPFETCH,3,SP@,docode\n        push bc\n        ld hl,0\n        add hl,sp\n        ld b,h\n        ld c,l\n        next\n\n;Z SP!  a-addr --       set data stack pointer\n    head SPSTORE,3,SP!,docode\n        ld h,b\n        ld l,c\n        ld sp,hl\n        pop bc          ; get new TOS\n        next\n\n;Z RP@  -- a-addr       get return stack pointer\n    head RPFETCH,3,RP@,docode\n        push bc\n        push ix\n        pop bc\n        next\n\n;Z RP!  a-addr --       set return stack pointer\n    head RPSTORE,3,RP!,docode\n        push bc\n        pop ix\n        pop bc\n        next\n\n; MEMORY AND I/O OPERATIONS =====================\n\n;C !        x a-addr --   store cell in memory\n    head STORE,1,!,docode\n        ld h,b          ; address in hl\n        ld l,c\n        pop bc          ; data in bc\n        ld (hl),c\n        inc hl\n        ld (hl),b\n        pop bc          ; pop new TOS\n        next\n\n;C C!      char c-addr --    store char in memory\n    head CSTORE,2,C!,docode\n        ld h,b          ; address in hl\n        ld l,c\n        pop bc          ; data in bc\n        ld (hl),c\n        pop bc          ; pop new TOS\n        next\n\n;C @       a-addr -- x   fetch cell from memory\n    head FETCH,1,@,docode\n        ld h,b          ; address in hl\n        ld l,c\n        ld c,(hl)\n        inc hl\n        ld b,(hl)\n        next\n\n;C C@     c-addr -- char   fetch char from memory\n    head CFETCH,2,C@,docode\n        ld a,(bc)\n        ld c,a\n        ld b,0\n        next\n\n;Z PC!     char c-addr --    output char to port\n    head PCSTORE,3,PC!,docode\n        pop hl          ; char in L\n        out (c),l       ; to port (BC)\n        pop bc          ; pop new TOS\n        next\n\n;Z PC@     c-addr -- char   input char from port\n    head PCFETCH,3,PC@,docode\n        in c,(c)        ; read port (BC) to C\n        ld b,0\n        next\n\n; ARITHMETIC AND LOGICAL OPERATIONS =============\n\n;C +       n1/u1 n2/u2 -- n3/u3     add n1+n2\n    head PLUS,1,+,docode\n        pop hl\n        add hl,bc\n        ld b,h\n        ld c,l\n        next\n\n;X M+       d n -- d         add single to double\n    head MPLUS,2,M+,docode\n        ex de,hl\n        pop de          ; hi cell\n        ex (sp),hl      ; lo cell, save IP\n        add hl,bc\n        ld b,d          ; hi result in BC (TOS)\n        ld c,e\n        jr nc,mplus1\n        inc bc\nmplus1: pop de          ; restore saved IP\n        push hl         ; push lo result\n        next\n\n;C -      n1/u1 n2/u2 -- n3/u3    subtract n1-n2\n    head MINUS,1,-,docode\n        pop hl\n        or a\n        sbc hl,bc\n        ld b,h\n        ld c,l\n        next\n\n;C AND    x1 x2 -- x3            logical AND\n    head AND,3,AND,docode\n        pop hl\n        ld a,b\n        and h\n        ld b,a\n        ld a,c\n        and l\n        ld c,a\n        next\n\n;C OR     x1 x2 -- x3           logical OR\n    head OR,2,OR,docode\n        pop hl\n        ld a,b\n        or h\n        ld b,a\n        ld a,c\n        or l\n        ld c,a\n        next\n\n;C XOR    x1 x2 -- x3            logical XOR\n    head XOR,3,XOR,docode\n        pop hl\n        ld a,b\n        xor h\n        ld b,a\n        ld a,c\n        xor l\n        ld c,a\n        next\n\n;C INVERT   x1 -- x2            bitwise inversion\n    head INVERT,6,INVERT,docode\n        ld a,b\n        cpl\n        ld b,a\n        ld a,c\n        cpl\n        ld c,a\n        next\n\n;C NEGATE   x1 -- x2            two's complement\n    head NEGATE,6,NEGATE,docode\n        ld a,b\n        cpl\n        ld b,a\n        ld a,c\n        cpl\n        ld c,a\n        inc bc\n        next\n\n;C 1+      n1/u1 -- n2/u2       add 1 to TOS\n    head ONEPLUS,2,1+,docode\n        inc bc\n        next\n\n;C 1-      n1/u1 -- n2/u2     subtract 1 from TOS\n    head ONEMINUS,2,1-,docode\n        dec bc\n        next\n\n;Z &gt;&lt;      x1 -- x2         swap bytes (not ANSI)\n    head swapbytes,2,&gt;&lt;,docode\n        ld a,b\n        ld b,c\n        ld c,a\n        next\n\n;C 2*      x1 -- x2         arithmetic left shift\n    head TWOSTAR,2,2*,docode\n        sla c\n        rl b\n        next\n\n;C 2/      x1 -- x2        arithmetic right shift\n    head TWOSLASH,2,2/,docode\n        sra b\n        rr c\n        next\n\n;C LSHIFT  x1 u -- x2    logical L shift u places\n    head LSHIFT,6,LSHIFT,docode\n        ld b,c        ; b = loop counter\n        pop hl        ;   NB: hi 8 bits ignored!\n        inc b         ; test for counter=0 case\n        jr lsh2\nlsh1:   add hl,hl     ; left shift HL, n times\nlsh2:   djnz lsh1\n        ld b,h        ; result is new TOS\n        ld c,l\n        next\n\n;C RSHIFT  x1 u -- x2    logical R shift u places\n    head RSHIFT,6,RSHIFT,docode\n        ld b,c        ; b = loop counter\n        pop hl        ;   NB: hi 8 bits ignored!\n        inc b         ; test for counter=0 case\n        jr rsh2\nrsh1:   srl h         ; right shift HL, n times\n        rr l\nrsh2:   djnz rsh1\n        ld b,h        ; result is new TOS\n        ld c,l\n        next\n\n;C +!     n/u a-addr --       add cell to memory\n    head PLUSSTORE,2,+!,docode\n        pop hl\n        ld a,(bc)       ; low byte\n        add a,l\n        ld (bc),a\n        inc bc\n        ld a,(bc)       ; high byte\n        adc a,h\n        ld (bc),a\n        pop bc          ; pop new TOS\n        next\n\n; COMPARISON OPERATIONS =========================\n\n;C 0=     n/u -- flag    return true if TOS=0\n    head ZEROEQUAL,2,0=,docode\n        ld a,b\n        or c            ; result=0 if bc was 0\n        sub 1           ; cy set   if bc was 0\n        sbc a,a         ; propagate cy through A\n        ld b,a          ; put 0000 or FFFF in TOS\n        ld c,a\n        next\n\n;C 0&lt;     n -- flag      true if TOS negative\n    head ZEROLESS,2,0&lt;,docode\n        sla b           ; sign bit -&gt; cy flag\n        sbc a,a         ; propagate cy through A\n        ld b,a          ; put 0000 or FFFF in TOS\n        ld c,a\n        next\n\n;C =      x1 x2 -- flag         test x1=x2\n    head EQUAL,1,=,docode\n        pop hl\n        or a\n        sbc hl,bc       ; x1-x2 in HL, SZVC valid\n        jr z,tostrue\ntosfalse: ld bc,0\n        next\n\n;X &lt;&gt;     x1 x2 -- flag    test not eq (not ANSI)\n    head NOTEQUAL,2,&lt;&gt;,docolon\n        DW EQUAL,ZEROEQUAL,EXIT\n\n;C &lt;      n1 n2 -- flag        test n1&lt;n2, signed\n    head LESS,1,&lt;,docode\n        pop hl\n        or a\n        sbc hl,bc       ; n1-n2 in HL, SZVC valid\n; if result negative &amp; not OV, n1&lt;n2\n; neg. &amp; OV =&gt; n1 +ve, n2 -ve, rslt -ve, so n1&gt;n2\n; if result positive &amp; not OV, n1&gt;=n2\n; pos. &amp; OV =&gt; n1 -ve, n2 +ve, rslt +ve, so n1&lt;n2\n; thus OV reverses the sense of the sign bit\n        jp pe,revsense  ; if OV, use rev. sense\n        jp p,tosfalse   ;   if +ve, result false\ntostrue: ld bc,0ffffh   ;   if -ve, result true\n        next\nrevsense: jp m,tosfalse ; OV: if -ve, reslt false\n        jr tostrue      ;     if +ve, result true\n\n;C &gt;     n1 n2 -- flag         test n1&gt;n2, signed\n    head GREATER,1,&gt;,docolon\n        DW SWOP,LESS,EXIT\n\n;C U&lt;    u1 u2 -- flag       test u1&lt;n2, unsigned\n    head ULESS,2,U&lt;,docode\n        pop hl\n        or a\n        sbc hl,bc       ; u1-u2 in HL, SZVC valid\n        sbc a,a         ; propagate cy through A\n        ld b,a          ; put 0000 or FFFF in TOS\n        ld c,a\n        next\n\n;X U&gt;    u1 u2 -- flag     u1&gt;u2 unsgd (not ANSI)\n    head UGREATER,2,U&gt;,docolon\n        DW SWOP,ULESS,EXIT\n\n; LOOP AND BRANCH OPERATIONS ====================\n\n;Z branch   --                  branch always\n    head branch,6,branch,docode\ndobranch: ld a,(de)     ; get inline value =&gt; IP\n        ld l,a\n        inc de\n        ld a,(de)\n        ld h,a\n        nexthl\n\n;Z ?branch   x --              branch if TOS zero\n    head qbranch,7,?branch,docode\n        ld a,b\n        or c            ; test old TOS\n        pop bc          ; pop new TOS\n        jr z,dobranch   ; if old TOS=0, branch\n        inc de          ; else skip inline value\n        inc de\n        next\n\n;Z (do)    n1|u1 n2|u2 --  R: -- sys1 sys2\n;Z                          run-time code for DO\n; '83 and ANSI standard loops terminate when the\n; boundary of limit-1 and limit is crossed, in\n; either direction.  This can be conveniently\n; implemented by making the limit 8000h, so that\n; arithmetic overflow logic can detect crossing.\n; I learned this trick from Laxen &amp; Perry F83.\n; fudge factor = 8000h-limit, to be added to\n; the start value.\n    head xdo,4,(do),docode\n        ex de,hl\n        ex (sp),hl   ; IP on stack, limit in HL\n        ex de,hl\n        ld hl,8000h\n        or a\n        sbc hl,de    ; 8000-limit in HL\n        dec ix       ; push this fudge factor\n        ld (ix+0),h  ;    onto return stack\n        dec ix       ;    for later use by 'I'\n        ld (ix+0),l\n        add hl,bc    ; add fudge to start value\n        dec ix       ; push adjusted start value\n        ld (ix+0),h  ;    onto return stack\n        dec ix       ;    as the loop index.\n        ld (ix+0),l\n        pop de       ; restore the saved IP\n        pop bc       ; pop new TOS\n        next\n\n;Z (loop)   R: sys1 sys2 --  | sys1 sys2\n;Z                        run-time code for LOOP\n; Add 1 to the loop index.  If loop terminates,\n; clean up the return stack and skip the branch.\n; Else take the inline branch.  Note that LOOP\n; terminates when index=8000h.\n    head xloop,6,(loop),docode\n        exx\n        ld bc,1\nlooptst: ld l,(ix+0)  ; get the loop index\n        ld h,(ix+1)\n        or a\n        adc hl,bc    ; increment w/overflow test\n        jp pe,loopterm  ; overflow=loop done\n        ; continue the loop\n        ld (ix+0),l  ; save the updated index\n        ld (ix+1),h\n        exx\n        jr dobranch  ; take the inline branch\nloopterm: ; terminate the loop\n        ld bc,4      ; discard the loop info\n        add ix,bc\n        exx\n        inc de       ; skip the inline branch\n        inc de\n        next\n\n;Z (+loop)   n --   R: sys1 sys2 --  | sys1 sys2\n;Z                        run-time code for +LOOP\n; Add n to the loop index.  If loop terminates,\n; clean up the return stack and skip the branch.\n; Else take the inline branch.\n    head xplusloop,7,(+loop),docode\n        pop hl      ; this will be the new TOS\n        push bc\n        ld b,h\n        ld c,l\n        exx\n        pop bc      ; old TOS = loop increment\n        jr looptst\n\n;C I        -- n   R: sys1 sys2 -- sys1 sys2\n;C                  get the innermost loop index\n    head II,1,I,docode\n        push bc     ; push old TOS\n        ld l,(ix+0) ; get current loop index\n        ld h,(ix+1)\n        ld c,(ix+2) ; get fudge factor\n        ld b,(ix+3)\n        or a\n        sbc hl,bc   ; subtract fudge factor,\n        ld b,h      ;   returning true index\n        ld c,l\n        next\n\n;C J        -- n   R: 4*sys -- 4*sys\n;C                  get the second loop index\n    head JJ,1,J,docode\n        push bc     ; push old TOS\n        ld l,(ix+4) ; get current loop index\n        ld h,(ix+5)\n        ld c,(ix+6) ; get fudge factor\n        ld b,(ix+7)\n        or a\n        sbc hl,bc   ; subtract fudge factor,\n        ld b,h      ;   returning true index\n        ld c,l\n        next\n\n;C UNLOOP   --   R: sys1 sys2 --  drop loop parms\n    head UNLOOP,6,UNLOOP,docode\n        inc ix\n        inc ix\n        inc ix\n        inc ix\n        next\n\n; MULTIPLY AND DIVIDE ===========================\n\n;C UM*     u1 u2 -- ud   unsigned 16x16-&gt;32 mult.\n    head UMSTAR,3,UM*,docode\n        push bc\n        exx\n        pop bc      ; u2 in BC\n        pop de      ; u1 in DE\n        ld hl,0     ; result will be in HLDE\n        ld a,17     ; loop counter\n        or a        ; clear cy\numloop: rr h\n        rr l\n        rr d\n        rr e\n        jr nc,noadd\n        add hl,bc\nnoadd:  dec a\n        jr nz,umloop\n        push de     ; lo result\n        push hl     ; hi result\n        exx\n        pop bc      ; put TOS back in BC\n        next\n\n;C UM/MOD   ud u1 -- u2 u3   unsigned 32/16-&gt;16\n    head UMSLASHMOD,6,UM/MOD,docode\n        push bc\n        exx\n        pop bc      ; BC = divisor\n        pop hl      ; HLDE = dividend\n        pop de\n        ld a,16     ; loop counter\n        sla e\n        rl d        ; hi bit DE -&gt; carry\nudloop: adc hl,hl   ; rot left w/ carry\n        jr nc,udiv3\n        ; case 1: 17 bit, cy:HL = 1xxxx\n        or a        ; we know we can subtract\n        sbc hl,bc\n        or a        ; clear cy to indicate sub ok\n        jr udiv4\n        ; case 2: 16 bit, cy:HL = 0xxxx\nudiv3:  sbc hl,bc   ; try the subtract\n        jr nc,udiv4 ; if no cy, subtract ok\n        add hl,bc   ; else cancel the subtract\n        scf         ;   and set cy to indicate\nudiv4:  rl e        ; rotate result bit into DE,\n        rl d        ; and next bit of DE into cy\n        dec a\n        jr nz,udloop\n        ; now have complemented quotient in DE,\n        ; and remainder in HL\n        ld a,d\n        cpl\n        ld b,a\n        ld a,e\n        cpl\n        ld c,a\n        push hl     ; push remainder\n        push bc\n        exx\n        pop bc      ; quotient remains in TOS\n        next\n\n; BLOCK AND STRING OPERATIONS ===================\n\n;C FILL   c-addr u char --  fill memory with char\n    head FILL,4,FILL,docode\n        ld a,c          ; character in a\n        exx             ; use alt. register set\n        pop bc          ; count in bc\n        pop de          ; address in de\n        or a            ; clear carry flag\n        ld hl,0ffffh\n        adc hl,bc       ; test for count=0 or 1\n        jr nc,filldone  ;   no cy: count=0, skip\n        ld (de),a       ; fill first byte\n        jr z,filldone   ;   zero, count=1, done\n        dec bc          ; else adjust count,\n        ld h,d          ;   let hl = start adrs,\n        ld l,e\n        inc de          ;   let de = start adrs+1\n        ldir            ;   copy (hl)-&gt;(de)\nfilldone: exx           ; back to main reg set\n        pop bc          ; pop new TOS\n        next\n\n;X CMOVE   c-addr1 c-addr2 u --  move from bottom\n; as defined in the ANSI optional String word set\n; On byte machines, CMOVE and CMOVE&gt; are logical\n; factors of MOVE.  They are easy to implement on\n; CPUs which have a block-move instruction.\n    head CMOVE,5,CMOVE,docode\n        push bc\n        exx\n        pop bc      ; count\n        pop de      ; destination adrs\n        pop hl      ; source adrs\n        ld a,b      ; test for count=0\n        or c\n        jr z,cmovedone\n        ldir        ; move from bottom to top\ncmovedone: exx\n        pop bc      ; pop new TOS\n        next\n\n;X CMOVE&gt;  c-addr1 c-addr2 u --  move from top\n; as defined in the ANSI optional String word set\n    head CMOVEUP,6,CMOVE&gt;,docode\n        push bc\n        exx\n        pop bc      ; count\n        pop hl      ; destination adrs\n        pop de      ; source adrs\n        ld a,b      ; test for count=0\n        or c\n        jr z,umovedone\n        add hl,bc   ; last byte in destination\n        dec hl\n        ex de,hl\n        add hl,bc   ; last byte in source\n        dec hl\n        lddr        ; move from top to bottom\numovedone: exx\n        pop bc      ; pop new TOS\n        next\n\n;Z SKIP   c-addr u c -- c-addr' u'\n;Z                          skip matching chars\n; Although SKIP, SCAN, and S= are perhaps not the\n; ideal factors of WORD and FIND, they closely\n; follow the string operations available on many\n; CPUs, and so are easy to implement and fast.\n    head skip,4,SKIP,docode\n        ld a,c      ; skip character\n        exx\n        pop bc      ; count\n        pop hl      ; address\n        ld e,a      ; test for count=0\n        ld a,b\n        or c\n        jr z,skipdone\n        ld a,e\nskiploop: cpi\n        jr nz,skipmis   ; char mismatch: exit\n        jp pe,skiploop  ; count not exhausted\n        jr skipdone     ; count 0, no mismatch\nskipmis: inc bc         ; mismatch!  undo last to\n        dec hl          ;  point at mismatch char\nskipdone: push hl   ; updated address\n        push bc     ; updated count\n        exx\n        pop bc      ; TOS in bc\n        next\n\n;Z SCAN    c-addr u c -- c-addr' u'\n;Z                      find matching char\n    head scan,4,SCAN,docode\n        ld a,c      ; scan character\n        exx\n        pop bc      ; count\n        pop hl      ; address\n        ld e,a      ; test for count=0\n        ld a,b\n        or c\n        jr z,scandone\n        ld a,e\n        cpir        ; scan 'til match or count=0\n        jr nz,scandone  ; no match, BC &amp; HL ok\n        inc bc          ; match!  undo last to\n        dec hl          ;   point at match char\nscandone: push hl   ; updated address\n        push bc     ; updated count\n        exx\n        pop bc      ; TOS in bc\n        next\n\n;Z S=    c-addr1 c-addr2 u -- n   string compare\n;Z             n&lt;0: s1&lt;s2, n=0: s1=s2, n&gt;0: s1&gt;s2\n    head sequal,2,S=,docode\n        push bc\n        exx\n        pop bc      ; count\n        pop hl      ; addr2\n        pop de      ; addr1\n        ld a,b      ; test for count=0\n        or c\n        jr z,smatch     ; by definition, match!\nsloop:  ld a,(de)\n        inc de\n        cpi\n        jr nz,sdiff     ; char mismatch: exit\n        jp pe,sloop     ; count not exhausted\nsmatch: ; count exhausted &amp; no mismatch found\n        exx\n        ld bc,0         ; bc=0000  (s1=s2)\n        jr snext\nsdiff:  ; mismatch!  undo last 'cpi' increment\n        dec hl          ; point at mismatch char\n        cp (hl)         ; set cy if char1 &lt; char2\n        sbc a,a         ; propagate cy thru A\n        exx\n        ld b,a          ; bc=FFFF if cy (s1&lt;s2)\n        or 1            ; bc=0001 if ncy (s1&gt;s2)\n        ld c,a\nsnext:  next\n\n*INCLUDE camel80d.azm   ; CPU Dependencies\n*INCLUDE camel80h.azm   ; High Level words\nlastword EQU link   ; nfa of last word in dict.\nenddict EQU $       ; user's code starts here\n        END\n</code></pre>"},{"location":"Moving_Forth/camel80d/","title":"Camel80d","text":"<pre><code>; LISTING 3.\n;\n; ===============================================\n; CamelForth for the Zilog Z80\n; (c) 1994 Bradford J. Rodriguez\n; Permission is granted to freely copy, modify,\n; and distribute this program for personal or\n; educational use.  Commercial inquiries should\n; be directed to the author at 221 King St. E.,\n; #32, Hamilton, Ontario L8N 1B5 Canada\n;\n; CAMEL80D.AZM: CPU and Model Dependencies\n;   Source code is for the Z80MR macro assembler.\n;   Forth words are documented as follows:\n;*   NAME     stack -- stack    description\n;   Word names in upper case are from the ANS\n;   Forth Core word set.  Names in lower case are\n;   \"internal\" implementation words &amp; extensions.\n;\n; Direct-Threaded Forth model for Zilog Z80\n;   cell size is   16 bits (2 bytes)\n;   char size is    8 bits (1 byte)\n;   address unit is 8 bits (1 byte), i.e.,\n;       addresses are byte-aligned.\n; ===============================================\n\n; ALIGNMENT AND PORTABILITY OPERATORS ===========\n; Many of these are synonyms for other words,\n; and so are defined as CODE words.\n\n;C ALIGN    --                         align HERE\n    head ALIGN,5,ALIGN,docode\nnoop:   next\n\n;C ALIGNED  addr -- a-addr       align given addr\n    head ALIGNED,7,ALIGNED,docode\n        jr noop\n\n;Z CELL     -- n                 size of one cell\n    head CELL,4,CELL,docon\n        dw 2\n\n;C CELL+    a-addr1 -- a-addr2      add cell size\n;   2 + ;\n    head CELLPLUS,5,CELL+,docode\n        inc bc\n        inc bc\n        next\n\n;C CELLS    n1 -- n2            cells-&gt;adrs units\n    head CELLS,5,CELLS,docode\n        jp twostar\n\n;C CHAR+    c-addr1 -- c-addr2   add char size\n    head CHARPLUS,5,CHAR+,docode\n        jp oneplus\n\n;C CHARS    n1 -- n2            chars-&gt;adrs units\n    head CHARS,5,CHARS,docode\n        jr noop\n\n;C &gt;BODY    xt -- a-addr      adrs of param field\n;   3 + ;                     Z80 (3 byte CALL)\n    head TOBODY,5,&gt;BODY,docolon\n        DW LIT,3,PLUS,EXIT\n\n;X COMPILE,  xt --         append execution token\n; I called this word ,XT before I discovered that\n; it is defined in the ANSI standard as COMPILE,.\n; On a DTC Forth this simply appends xt (like , )\n; but on an STC Forth this must append 'CALL xt'.\n    head COMMAXT,8,'COMPILE,',docode\n        jp COMMA\n\n;Z !CF    adrs cfa --   set code action of a word\n;   0CD OVER C!         store 'CALL adrs' instr\n;   1+ ! ;              Z80 VERSION\n; Depending on the implementation this could\n; append CALL adrs or JUMP adrs.\n    head STORECF,3,!CF,docolon\n        DW LIT,0CDH,OVER,CSTORE\n        DW ONEPLUS,STORE,EXIT\n\n;Z ,CF    adrs --       append a code field\n;   HERE !CF 3 ALLOT ;  Z80 VERSION (3 bytes)\n    head COMMACF,3,',CF',docolon\n        DW HERE,STORECF,LIT,3,ALLOT,EXIT\n\n;Z !COLON   --      change code field to docolon\n;   -3 ALLOT docolon-adrs ,CF ;\n; This should be used immediately after CREATE.\n; This is made a distinct word, because on an STC\n; Forth, colon definitions have no code field.\n    head STORCOLON,6,'!COLON',docolon\n        DW LIT,-3,ALLOT\n        DW LIT,docolon,COMMACF,EXIT\n\n;Z ,EXIT    --      append hi-level EXIT action\n;   ['] EXIT ,XT ;\n; This is made a distinct word, because on an STC\n; Forth, it appends a RET instruction, not an xt.\n    head CEXIT,5,',EXIT',docolon\n        DW LIT,EXIT,COMMAXT,EXIT\n\n; CONTROL STRUCTURES ============================\n; These words allow Forth control structure words\n; to be defined portably.\n\n;Z ,BRANCH   xt --    append a branch instruction\n; xt is the branch operator to use, e.g. qbranch\n; or (loop).  It does NOT append the destination\n; address.  On the Z80 this is equivalent to ,XT.\n    head COMMABRANCH,7,',BRANCH',docode\n        jp COMMA\n\n;Z ,DEST   dest --        append a branch address\n; This appends the given destination address to\n; the branch instruction.  On the Z80 this is ','\n; ...other CPUs may use relative addressing.\n    head COMMADEST,5,',DEST',docode\n        jp COMMA\n\n;Z !DEST   dest adrs --    change a branch dest'n\n; Changes the destination address found at 'adrs'\n; to the given 'dest'.  On the Z80 this is '!'\n; ...other CPUs may need relative addressing.\n    head STOREDEST,5,'!DEST',docode\n        jp STORE\n\n; HEADER STRUCTURE ==============================\n; The structure of the Forth dictionary headers\n; (name, link, immediate flag, and \"smudge\" bit)\n; does not necessarily differ across CPUs.  This\n; structure is not easily factored into distinct\n; \"portable\" words; instead, it is implicit in\n; the definitions of FIND and CREATE, and also in\n; NFA&gt;LFA, NFA&gt;CFA, IMMED?, IMMEDIATE, HIDE, and\n; REVEAL.  These words must be (substantially)\n; rewritten if either the header structure or its\n; inherent assumptions are changed.\n</code></pre>"},{"location":"Moving_Forth/camel80h/","title":"Camel80h","text":"<pre><code>; LISTING 2.\n;\n; ===============================================\n; CamelForth for the Zilog Z80\n; (c) 1994 Bradford J. Rodriguez\n; Permission is granted to freely copy, modify,\n; and distribute this program for personal or\n; educational use.  Commercial inquiries should\n; be directed to the author at 221 King St. E.,\n; #32, Hamilton, Ontario L8N 1B5 Canada\n;\n; CAMEL80H.AZM: High Level Words\n;   Source code is for the Z80MR macro assembler.\n;   Forth words are documented as follows:\n;*   NAME     stack -- stack    description\n;   Word names in upper case are from the ANS\n;   Forth Core word set.  Names in lower case are\n;   \"internal\" implementation words &amp; extensions.\n; ===============================================\n\n; SYSTEM VARIABLES &amp; CONSTANTS ==================\n\n;C BL      -- char            an ASCII space\n    head BL,2,BL,docon\n        dw 20h\n\n;Z tibsize  -- n         size of TIB\n    head TIBSIZE,7,TIBSIZE,docon\n        dw 124          ; 2 chars safety zone\n\n;X tib     -- a-addr     Terminal Input Buffer\n;  HEX 82 CONSTANT TIB   CP/M systems: 126 bytes\n;  HEX -80 USER TIB      others: below user area\n    head TIB,3,TIB,docon\n        dw 82h\n\n;Z u0      -- a-addr       current user area adrs\n;  0 USER U0\n    head U0,2,U0,douser\n        dw 0\n\n;C &gt;IN     -- a-addr        holds offset into TIB\n;  2 USER &gt;IN\n    head TOIN,3,&gt;IN,douser\n        dw 2\n\n;C BASE    -- a-addr       holds conversion radix\n;  4 USER BASE\n    head BASE,4,BASE,douser\n        dw 4\n\n;C STATE   -- a-addr       holds compiler state\n;  6 USER STATE\n    head STATE,5,STATE,douser\n        dw 6\n\n;Z dp      -- a-addr       holds dictionary ptr\n;  8 USER DP\n    head DP,2,DP,douser\n        dw 8\n\n;Z 'source  -- a-addr      two cells: len, adrs\n; 10 USER 'SOURCE\n;    head TICKSOURCE,7,'SOURCE,douser\n        DW link                 ; must expand\n        DB 0                    ; manually\nlink    DEFL $                  ; because of\n        DB 7,27h,'SOURCE'       ; tick character\nTICKSOURCE: call douser         ; in name!\n        dw 10\n\n;Z latest    -- a-addr     last word in dict.\n;   14 USER LATEST\n    head LATEST,6,LATEST,douser\n        dw 14\n\n;Z hp       -- a-addr     HOLD pointer\n;   16 USER HP\n    head HP,2,HP,douser\n        dw 16\n\n;Z LP       -- a-addr     Leave-stack pointer\n;   18 USER LP\n    head LP,2,LP,douser\n        dw 18\n\n;Z s0       -- a-addr     end of parameter stack\n    head S0,2,S0,douser\n        dw 100h\n\n;X PAD       -- a-addr    user PAD buffer\n;                         = end of hold area!\n    head PAD,3,PAD,douser\n        dw 128h\n\n;Z l0       -- a-addr     bottom of Leave stack\n    head L0,2,L0,douser\n        dw 180h\n\n;Z r0       -- a-addr     end of return stack\n    head R0,2,R0,douser\n        dw 200h\n\n;Z uinit    -- addr  initial values for user area\n    head UINIT,5,UINIT,docreate\n        DW 0,0,10,0     ; reserved,&gt;IN,BASE,STATE\n        DW enddict      ; DP\n        DW 0,0          ; SOURCE init'd elsewhere\n        DW lastword     ; LATEST\n        DW 0            ; HP init'd elsewhere\n\n;Z #init    -- n    #bytes of user area init data\n    head NINIT,5,#INIT,docon\n        DW 18\n\n; ARITHMETIC OPERATORS ==========================\n\n;C S&gt;D    n -- d          single -&gt; double prec.\n;   DUP 0&lt; ;\n    head STOD,3,S&gt;D,docolon\n        dw DUP,ZEROLESS,EXIT\n\n;Z ?NEGATE  n1 n2 -- n3  negate n1 if n2 negative\n;   0&lt; IF NEGATE THEN ;        ...a common factor\n    head QNEGATE,7,?NEGATE,docolon\n        DW ZEROLESS,qbranch,QNEG1,NEGATE\nQNEG1:  DW EXIT\n\n;C ABS     n1 -- +n2     absolute value\n;   DUP ?NEGATE ;\n    head ABS,3,ABS,docolon\n        DW DUP,QNEGATE,EXIT\n\n;X DNEGATE   d1 -- d2     negate double precision\n;   SWAP INVERT SWAP INVERT 1 M+ ;\n    head DNEGATE,7,DNEGATE,docolon\n        DW SWOP,INVERT,SWOP,INVERT,LIT,1,MPLUS\n        DW EXIT\n\n;Z ?DNEGATE  d1 n -- d2   negate d1 if n negative\n;   0&lt; IF DNEGATE THEN ;       ...a common factor\n    head QDNEGATE,8,?DNEGATE,docolon\n        DW ZEROLESS,qbranch,DNEG1,DNEGATE\nDNEG1:  DW EXIT\n\n;X DABS     d1 -- +d2    absolute value dbl.prec.\n;   DUP ?DNEGATE ;\n    head DABS,4,DABS,docolon\n        DW DUP,QDNEGATE,EXIT\n\n;C M*     n1 n2 -- d    signed 16*16-&gt;32 multiply\n;   2DUP XOR &gt;R        carries sign of the result\n;   SWAP ABS SWAP ABS UM*\n;   R&gt; ?DNEGATE ;\n    head MSTAR,2,M*,docolon\n        DW TWODUP,XOR,TOR\n        DW SWOP,ABS,SWOP,ABS,UMSTAR\n        DW RFROM,QDNEGATE,EXIT\n\n;C SM/REM   d1 n1 -- n2 n3   symmetric signed div\n;   2DUP XOR &gt;R              sign of quotient\n;   OVER &gt;R                  sign of remainder\n;   ABS &gt;R DABS R&gt; UM/MOD\n;   SWAP R&gt; ?NEGATE\n;   SWAP R&gt; ?NEGATE ;\n; Ref. dpANS-6 section 3.2.2.1.\n    head SMSLASHREM,6,SM/REM,docolon\n        DW TWODUP,XOR,TOR,OVER,TOR\n        DW ABS,TOR,DABS,RFROM,UMSLASHMOD\n        DW SWOP,RFROM,QNEGATE,SWOP,RFROM,QNEGATE\n        DW EXIT\n\n;C FM/MOD   d1 n1 -- n2 n3   floored signed div'n\n;   DUP &gt;R              save divisor\n;   SM/REM\n;   DUP 0&lt; IF           if quotient negative,\n;       SWAP R&gt; +         add divisor to rem'dr\n;       SWAP 1-           decrement quotient\n;   ELSE R&gt; DROP THEN ;\n; Ref. dpANS-6 section 3.2.2.1.\n    head FMSLASHMOD,6,FM/MOD,docolon\n        DW DUP,TOR,SMSLASHREM\n        DW DUP,ZEROLESS,qbranch,FMMOD1\n        DW SWOP,RFROM,PLUS,SWOP,ONEMINUS\n        DW branch,FMMOD2\nFMMOD1: DW RFROM,DROP\nFMMOD2: DW EXIT\n\n;C *      n1 n2 -- n3       signed multiply\n;   M* DROP ;\n    head STAR,1,*,docolon\n        dw MSTAR,DROP,EXIT\n\n;C /MOD   n1 n2 -- n3 n4    signed divide/rem'dr\n;   &gt;R S&gt;D R&gt; FM/MOD ;\n    head SLASHMOD,4,/MOD,docolon\n        dw TOR,STOD,RFROM,FMSLASHMOD,EXIT\n\n;C /      n1 n2 -- n3       signed divide\n;   /MOD nip ;\n    head SLASH,1,/,docolon\n        dw SLASHMOD,NIP,EXIT\n\n;C MOD    n1 n2 -- n3       signed remainder\n;   /MOD DROP ;\n    head MOD,3,MOD,docolon\n        dw SLASHMOD,DROP,EXIT\n\n;C */MOD  n1 n2 n3 -- n4 n5    n1*n2/n3, rem&amp;quot\n;   &gt;R M* R&gt; FM/MOD ;\n    head SSMOD,5,*/MOD,docolon\n        dw TOR,MSTAR,RFROM,FMSLASHMOD,EXIT\n\n;C */     n1 n2 n3 -- n4        n1*n2/n3\n;   */MOD nip ;\n    head STARSLASH,2,*/,docolon\n        dw SSMOD,NIP,EXIT\n\n;C MAX    n1 n2 -- n3       signed maximum\n;   2DUP &lt; IF SWAP THEN DROP ;\n    head MAX,3,MAX,docolon\n        dw TWODUP,LESS,qbranch,MAX1,SWOP\nMAX1:   dw DROP,EXIT\n\n;C MIN    n1 n2 -- n3       signed minimum\n;   2DUP &gt; IF SWAP THEN DROP ;\n    head MIN,3,MIN,docolon\n        dw TWODUP,GREATER,qbranch,MIN1,SWOP\nMIN1:   dw DROP,EXIT\n\n; DOUBLE OPERATORS ==============================\n\n;C 2@    a-addr -- x1 x2    fetch 2 cells\n;   DUP CELL+ @ SWAP @ ;\n;   the lower address will appear on top of stack\n    head TWOFETCH,2,2@,docolon\n        dw DUP,CELLPLUS,FETCH,SWOP,FETCH,EXIT\n\n;C 2!    x1 x2 a-addr --    store 2 cells\n;   SWAP OVER ! CELL+ ! ;\n;   the top of stack is stored at the lower adrs\n    head TWOSTORE,2,2!,docolon\n        dw SWOP,OVER,STORE,CELLPLUS,STORE,EXIT\n\n;C 2DROP  x1 x2 --          drop 2 cells\n;   DROP DROP ;\n    head TWODROP,5,2DROP,docolon\n        dw DROP,DROP,EXIT\n\n;C 2DUP   x1 x2 -- x1 x2 x1 x2   dup top 2 cells\n;   OVER OVER ;\n    head TWODUP,4,2DUP,docolon\n        dw OVER,OVER,EXIT\n\n;C 2SWAP  x1 x2 x3 x4 -- x3 x4 x1 x2  per diagram\n;   ROT &gt;R ROT R&gt; ;\n    head TWOSWAP,5,2SWAP,docolon\n        dw ROT,TOR,ROT,RFROM,EXIT\n\n;C 2OVER  x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2\n;   &gt;R &gt;R 2DUP R&gt; R&gt; 2SWAP ;\n    head TWOOVER,5,2OVER,docolon\n        dw TOR,TOR,TWODUP,RFROM,RFROM\n        dw TWOSWAP,EXIT\n\n; INPUT/OUTPUT ==================================\n\n;C COUNT   c-addr1 -- c-addr2 u  counted-&gt;adr/len\n;   DUP CHAR+ SWAP C@ ;\n    head COUNT,5,COUNT,docolon\n        dw DUP,CHARPLUS,SWOP,CFETCH,EXIT\n\n;C CR      --               output newline\n;   0D EMIT 0A EMIT ;\n    head CR,2,CR,docolon\n        dw lit,0dh,EMIT,lit,0ah,EMIT,EXIT\n\n;C SPACE   --               output a space\n;   BL EMIT ;\n    head SPACE,5,SPACE,docolon\n        dw BL,EMIT,EXIT\n\n;C SPACES   n --            output n spaces\n;   BEGIN DUP WHILE SPACE 1- REPEAT DROP ;\n    head SPACES,6,SPACES,docolon\nSPCS1:  DW DUP,qbranch,SPCS2\n        DW SPACE,ONEMINUS,branch,SPCS1\nSPCS2:  DW DROP,EXIT\n\n;Z umin     u1 u2 -- u      unsigned minimum\n;   2DUP U&gt; IF SWAP THEN DROP ;\n    head UMIN,4,UMIN,docolon\n        DW TWODUP,UGREATER,QBRANCH,UMIN1,SWOP\nUMIN1:  DW DROP,EXIT\n\n;Z umax    u1 u2 -- u       unsigned maximum\n;   2DUP U&lt; IF SWAP THEN DROP ;\n    head UMAX,4,UMAX,docolon\n        DW TWODUP,ULESS,QBRANCH,UMAX1,SWOP\nUMAX1:  DW DROP,EXIT\n\n;C ACCEPT  c-addr +n -- +n'  get line from term'l\n;   OVER + 1- OVER      -- sa ea a\n;   BEGIN KEY           -- sa ea a c\n;   DUP 0D &lt;&gt; WHILE\n;       DUP EMIT        -- sa ea a c\n;       DUP 8 = IF  DROP 1-    &gt;R OVER R&gt; UMAX\n;             ELSE  OVER C! 1+ OVER UMIN\n;       THEN            -- sa ea a\n;   REPEAT              -- sa ea a c\n;   DROP NIP SWAP - ;\n    head ACCEPT,6,ACCEPT,docolon\n        DW OVER,PLUS,ONEMINUS,OVER\nACC1:   DW KEY,DUP,LIT,0DH,NOTEQUAL,QBRANCH,ACC5\n        DW DUP,EMIT,DUP,LIT,8,EQUAL,QBRANCH,ACC3\n        DW DROP,ONEMINUS,TOR,OVER,RFROM,UMAX\n        DW BRANCH,ACC4\nACC3:   DW OVER,CSTORE,ONEPLUS,OVER,UMIN\nACC4:   DW BRANCH,ACC1\nACC5:   DW DROP,NIP,SWOP,MINUS,EXIT\n\n;C TYPE    c-addr +n --     type line to term'l\n;   ?DUP IF\n;     OVER + SWAP DO I C@ EMIT LOOP\n;   ELSE DROP THEN ;\n    head TYPE,4,TYPE,docolon\n        DW QDUP,QBRANCH,TYP4\n        DW OVER,PLUS,SWOP,XDO\nTYP3:   DW II,CFETCH,EMIT,XLOOP,TYP3\n        DW BRANCH,TYP5\nTYP4:   DW DROP\nTYP5:   DW EXIT\n\n;Z (S\")     -- c-addr u   run-time code for S\"\n;   R&gt; COUNT 2DUP + ALIGNED &gt;R  ;\n    head XSQUOTE,4,(S\"),docolon\n        DW RFROM,COUNT,TWODUP,PLUS,ALIGNED,TOR\n        DW EXIT\n\n;C S\"       --         compile in-line string\n;   COMPILE (S\")  [ HEX ]\n;   22 WORD C@ 1+ ALIGNED ALLOT ; IMMEDIATE\n    immed SQUOTE,2,S\",docolon\n        DW LIT,XSQUOTE,COMMAXT\n        DW LIT,22H,WORD,CFETCH,ONEPLUS\n        DW ALIGNED,ALLOT,EXIT\n\n;C .\"       --         compile string to print\n;   POSTPONE S\"  POSTPONE TYPE ; IMMEDIATE\n    immed DOTQUOTE,2,.\",docolon\n        DW SQUOTE\n        DW LIT,TYPE,COMMAXT\n        DW EXIT\n\n; NUMERIC OUTPUT ================================\n; Numeric conversion is done l.s.digit first, so\n; the output buffer is built backwards in memory.\n\n; Some double-precision arithmetic operators are\n; needed to implement ANSI numeric conversion.\n\n;Z UD/MOD   ud1 u2 -- u3 ud4   32/16-&gt;32 divide\n;   &gt;R 0 R@ UM/MOD  ROT ROT R&gt; UM/MOD ROT ;\n    head UDSLASHMOD,6,UD/MOD,docolon\n        DW TOR,LIT,0,RFETCH,UMSLASHMOD,ROT,ROT\n        DW RFROM,UMSLASHMOD,ROT,EXIT\n\n;Z UD*      ud1 d2 -- ud3      32*16-&gt;32 multiply\n;   DUP &gt;R UM* DROP  SWAP R&gt; UM* ROT + ;\n    head UDSTAR,3,UD*,docolon\n        DW DUP,TOR,UMSTAR,DROP\n        DW SWOP,RFROM,UMSTAR,ROT,PLUS,EXIT\n\n;C HOLD  char --        add char to output string\n;   -1 HP +!  HP @ C! ;\n    head HOLD,4,HOLD,docolon\n        DW LIT,-1,HP,PLUSSTORE\n        DW HP,FETCH,CSTORE,EXIT\n\n;C &lt;#    --             begin numeric conversion\n;   PAD HP ! ;          (initialize Hold Pointer)\n    head LESSNUM,2,&lt;#,docolon\n        DW PAD,HP,STORE,EXIT\n\n;Z &gt;digit   n -- c      convert to 0..9A..Z\n;   [ HEX ] DUP 9 &gt; 7 AND + 30 + ;\n    head TODIGIT,6,&gt;DIGIT,docolon\n        DW DUP,LIT,9,GREATER,LIT,7,AND,PLUS\n        DW LIT,30H,PLUS,EXIT\n\n;C #     ud1 -- ud2     convert 1 digit of output\n;   BASE @ UD/MOD ROT &gt;digit HOLD ;\n    head NUM,1,#,docolon\n        DW BASE,FETCH,UDSLASHMOD,ROT,TODIGIT\n        DW HOLD,EXIT\n\n;C #S    ud1 -- ud2     convert remaining digits\n;   BEGIN # 2DUP OR 0= UNTIL ;\n    head NUMS,2,#S,docolon\nNUMS1:  DW NUM,TWODUP,OR,ZEROEQUAL,qbranch,NUMS1\n        DW EXIT\n\n;C #&gt;    ud1 -- c-addr u    end conv., get string\n;   2DROP HP @ PAD OVER - ;\n    head NUMGREATER,2,#&gt;,docolon\n        DW TWODROP,HP,FETCH,PAD,OVER,MINUS,EXIT\n\n;C SIGN  n --           add minus sign if n&lt;0\n;   0&lt; IF 2D HOLD THEN ;\n    head SIGN,4,SIGN,docolon\n        DW ZEROLESS,qbranch,SIGN1,LIT,2DH,HOLD\nSIGN1:  DW EXIT\n\n;C U.    u --           display u unsigned\n;   &lt;# 0 #S #&gt; TYPE SPACE ;\n    head UDOT,2,U.,docolon\n        DW LESSNUM,LIT,0,NUMS,NUMGREATER,TYPE\n        DW SPACE,EXIT\n\n;C .     n --           display n signed\n;   &lt;# DUP ABS 0 #S ROT SIGN #&gt; TYPE SPACE ;\n    head DOT,1,'.',docolon\n        DW LESSNUM,DUP,ABS,LIT,0,NUMS\n        DW ROT,SIGN,NUMGREATER,TYPE,SPACE,EXIT\n\n;C DECIMAL  --      set number base to decimal\n;   10 BASE ! ;\n    head DECIMAL,7,DECIMAL,docolon\n        DW LIT,10,BASE,STORE,EXIT\n\n;X HEX     --       set number base to hex\n;   16 BASE ! ;\n    head HEX,3,HEX,docolon\n        DW LIT,16,BASE,STORE,EXIT\n\n; DICTIONARY MANAGEMENT =========================\n\n;C HERE    -- addr      returns dictionary ptr\n;   DP @ ;\n    head HERE,4,HERE,docolon\n        dw DP,FETCH,EXIT\n\n;C ALLOT   n --         allocate n bytes in dict\n;   DP +! ;\n    head ALLOT,5,ALLOT,docolon\n        dw DP,PLUSSTORE,EXIT\n\n; Note: , and C, are only valid for combined\n; Code and Data spaces.\n\n;C ,    x --           append cell to dict\n;   HERE ! 1 CELLS ALLOT ;\n    head COMMA,1,',',docolon\n        dw HERE,STORE,lit,1,CELLS,ALLOT,EXIT\n\n;C C,   char --        append char to dict\n;   HERE C! 1 CHARS ALLOT ;\n    head CCOMMA,2,'C,',docolon\n        dw HERE,CSTORE,lit,1,CHARS,ALLOT,EXIT\n\n; INTERPRETER ===================================\n; Note that NFA&gt;LFA, NFA&gt;CFA, IMMED?, and FIND\n; are dependent on the structure of the Forth\n; header.  This may be common across many CPUs,\n; or it may be different.\n\n;C SOURCE   -- adr n    current input buffer\n;   'SOURCE 2@ ;        length is at lower adrs\n    head SOURCE,6,SOURCE,docolon\n        DW TICKSOURCE,TWOFETCH,EXIT\n\n;X /STRING  a u n -- a+n u-n   trim string\n;   ROT OVER + ROT ROT - ;\n    head SLASHSTRING,7,/STRING,docolon\n        DW ROT,OVER,PLUS,ROT,ROT,MINUS,EXIT\n\n;Z &gt;counted  src n dst --     copy to counted str\n;   2DUP C! CHAR+ SWAP CMOVE ;\n    head TOCOUNTED,8,&gt;COUNTED,docolon\n        DW TWODUP,CSTORE,CHARPLUS,SWOP,CMOVE,EXIT\n\n;C WORD   char -- c-addr n   word delim'd by char\n;   DUP  SOURCE &gt;IN @ /STRING   -- c c adr n\n;   DUP &gt;R   ROT SKIP           -- c adr' n'\n;   OVER &gt;R  ROT SCAN           -- adr\" n\"\n;   DUP IF CHAR- THEN        skip trailing delim.\n;   R&gt; R&gt; ROT -   &gt;IN +!        update &gt;IN offset\n;   TUCK -                      -- adr' N\n;   HERE &gt;counted               --\n;   HERE                        -- a\n;   BL OVER COUNT + C! ;    append trailing blank\n    head WORD,4,WORD,docolon\n        DW DUP,SOURCE,TOIN,FETCH,SLASHSTRING\n        DW DUP,TOR,ROT,SKIP\n        DW OVER,TOR,ROT,SCAN\n        DW DUP,qbranch,WORD1,ONEMINUS  ; char-\nWORD1:  DW RFROM,RFROM,ROT,MINUS,TOIN,PLUSSTORE\n        DW TUCK,MINUS\n        DW HERE,TOCOUNTED,HERE\n        DW BL,OVER,COUNT,PLUS,CSTORE,EXIT\n\n;Z NFA&gt;LFA   nfa -- lfa    name adr -&gt; link field\n;   3 - ;\n    head NFATOLFA,7,NFA&gt;LFA,docolon\n        DW LIT,3,MINUS,EXIT\n\n;Z NFA&gt;CFA   nfa -- cfa    name adr -&gt; code field\n;   COUNT 7F AND + ;       mask off 'smudge' bit\n    head NFATOCFA,7,NFA&gt;CFA,docolon\n        DW COUNT,LIT,07FH,AND,PLUS,EXIT\n\n;Z IMMED?    nfa -- f      fetch immediate flag\n;   1- C@ ;                     nonzero if immed\n    head IMMEDQ,6,IMMED?,docolon\n        DW ONEMINUS,CFETCH,EXIT\n\n;C FIND   c-addr -- c-addr 0   if not found\n;C                  xt  1      if immediate\n;C                  xt -1      if \"normal\"\n;   LATEST @ BEGIN             -- a nfa\n;       2DUP OVER C@ CHAR+     -- a nfa a nfa n+1\n;       S=                     -- a nfa f\n;       DUP IF\n;           DROP\n;           NFA&gt;LFA @ DUP      -- a link link\n;       THEN\n;   0= UNTIL                   -- a nfa  OR  a 0\n;   DUP IF\n;       NIP DUP NFA&gt;CFA        -- nfa xt\n;       SWAP IMMED?            -- xt iflag\n;       0= 1 OR                -- xt 1/-1\n;   THEN ;\n    head FIND,4,FIND,docolon\n        DW LATEST,FETCH\nFIND1:  DW TWODUP,OVER,CFETCH,CHARPLUS\n        DW SEQUAL,DUP,qbranch,FIND2\n        DW DROP,NFATOLFA,FETCH,DUP\nFIND2:  DW ZEROEQUAL,qbranch,FIND1\n        DW DUP,qbranch,FIND3\n        DW NIP,DUP,NFATOCFA\n        DW SWOP,IMMEDQ,ZEROEQUAL,LIT,1,OR\nFIND3:  DW EXIT\n\n;C LITERAL  x --        append numeric literal\n;   STATE @ IF ['] LIT ,XT , THEN ; IMMEDIATE\n; This tests STATE so that it can also be used\n; interpretively.  (ANSI doesn't require this.)\n    immed LITERAL,7,LITERAL,docolon\n        DW STATE,FETCH,qbranch,LITER1\n        DW LIT,LIT,COMMAXT,COMMA\nLITER1: DW EXIT\n\n;Z DIGIT?   c -- n -1   if c is a valid digit\n;Z            -- x  0   otherwise\n;   [ HEX ] DUP 39 &gt; 100 AND +     silly looking\n;   DUP 140 &gt; 107 AND -   30 -     but it works!\n;   DUP BASE @ U&lt; ;\n    head DIGITQ,6,DIGIT?,docolon\n        DW DUP,LIT,39H,GREATER,LIT,100H,AND,PLUS\n        DW DUP,LIT,140H,GREATER,LIT,107H,AND\n        DW MINUS,LIT,30H,MINUS\n        DW DUP,BASE,FETCH,ULESS,EXIT\n\n;Z ?SIGN   adr n -- adr' n' f  get optional sign\n;Z  advance adr/n if sign; return NZ if negative\n;   OVER C@                 -- adr n c\n;   2C - DUP ABS 1 = AND    -- +=-1, -=+1, else 0\n;   DUP IF 1+               -- +=0, -=+2\n;       &gt;R 1 /STRING R&gt;     -- adr' n' f\n;   THEN ;\n    head QSIGN,5,?SIGN,docolon\n        DW OVER,CFETCH,LIT,2CH,MINUS,DUP,ABS\n        DW LIT,1,EQUAL,AND,DUP,qbranch,QSIGN1\n        DW ONEPLUS,TOR,LIT,1,SLASHSTRING,RFROM\nQSIGN1: DW EXIT\n\n;C &gt;NUMBER  ud adr u -- ud' adr' u'\n;C                      convert string to number\n;   BEGIN\n;   DUP WHILE\n;       OVER C@ DIGIT?\n;       0= IF DROP EXIT THEN\n;       &gt;R 2SWAP BASE @ UD*\n;       R&gt; M+ 2SWAP\n;       1 /STRING\n;   REPEAT ;\n    head TONUMBER,7,&gt;NUMBER,docolon\nTONUM1: DW DUP,qbranch,TONUM3\n        DW OVER,CFETCH,DIGITQ\n        DW ZEROEQUAL,qbranch,TONUM2,DROP,EXIT\nTONUM2: DW TOR,TWOSWAP,BASE,FETCH,UDSTAR\n        DW RFROM,MPLUS,TWOSWAP\n        DW LIT,1,SLASHSTRING,branch,TONUM1\nTONUM3: DW EXIT\n\n;Z ?NUMBER  c-addr -- n -1      string-&gt;number\n;Z                 -- c-addr 0  if convert error\n;   DUP  0 0 ROT COUNT      -- ca ud adr n\n;   ?SIGN &gt;R  &gt;NUMBER       -- ca ud adr' n'\n;   IF   R&gt; 2DROP 2DROP 0   -- ca 0   (error)\n;   ELSE 2DROP NIP R&gt;\n;       IF NEGATE THEN  -1  -- n -1   (ok)\n;   THEN ;\n    head QNUMBER,7,?NUMBER,docolon\n        DW DUP,LIT,0,DUP,ROT,COUNT\n        DW QSIGN,TOR,TONUMBER,qbranch,QNUM1\n        DW RFROM,TWODROP,TWODROP,LIT,0\n        DW branch,QNUM3\nQNUM1:  DW TWODROP,NIP,RFROM,qbranch,QNUM2,NEGATE\nQNUM2:  DW LIT,-1\nQNUM3:  DW EXIT\n\n;Z INTERPRET    i*x c-addr u -- j*x\n;Z                      interpret given buffer\n; This is a common factor of EVALUATE and QUIT.\n; ref. dpANS-6, 3.4 The Forth Text Interpreter\n;   'SOURCE 2!  0 &gt;IN !\n;   BEGIN\n;   BL WORD DUP C@ WHILE        -- textadr\n;       FIND                    -- a 0/1/-1\n;       ?DUP IF                 -- xt 1/-1\n;           1+ STATE @ 0= OR    immed or interp?\n;           IF EXECUTE ELSE ,XT THEN\n;       ELSE                    -- textadr\n;           ?NUMBER\n;           IF POSTPONE LITERAL     converted ok\n;           ELSE COUNT TYPE 3F EMIT CR ABORT  err\n;           THEN\n;       THEN\n;   REPEAT DROP ;\n    head INTERPRET,9,INTERPRET,docolon\n        DW TICKSOURCE,TWOSTORE,LIT,0,TOIN,STORE\nINTER1: DW BL,WORD,DUP,CFETCH,qbranch,INTER9\n        DW FIND,QDUP,qbranch,INTER4\n        DW ONEPLUS,STATE,FETCH,ZEROEQUAL,OR\n        DW qbranch,INTER2\n        DW EXECUTE,branch,INTER3\nINTER2: DW COMMAXT\nINTER3: DW branch,INTER8\nINTER4: DW QNUMBER,qbranch,INTER5\n        DW LITERAL,branch,INTER6\nINTER5: DW COUNT,TYPE,LIT,3FH,EMIT,CR,ABORT\nINTER6:\nINTER8: DW branch,INTER1\nINTER9: DW DROP,EXIT\n\n;C EVALUATE  i*x c-addr u -- j*x  interprt string\n;   'SOURCE 2@ &gt;R &gt;R  &gt;IN @ &gt;R\n;   INTERPRET\n;   R&gt; &gt;IN !  R&gt; R&gt; 'SOURCE 2! ;\n    head EVALUATE,8,EVALUATE,docolon\n        DW TICKSOURCE,TWOFETCH,TOR,TOR\n        DW TOIN,FETCH,TOR,INTERPRET\n        DW RFROM,TOIN,STORE,RFROM,RFROM\n        DW TICKSOURCE,TWOSTORE,EXIT\n\n;C QUIT     --    R: i*x --    interpret from kbd\n;   L0 LP !  R0 RP!   0 STATE !\n;   BEGIN\n;       TIB DUP TIBSIZE ACCEPT  SPACE\n;       INTERPRET\n;       STATE @ 0= IF CR .\" OK\" THEN\n;   AGAIN ;\n    head QUIT,4,QUIT,docolon\n        DW L0,LP,STORE\n        DW R0,RPSTORE,LIT,0,STATE,STORE\nQUIT1:  DW TIB,DUP,TIBSIZE,CPMACCEPT,SPACE\n        DW INTERPRET\n        DW STATE,FETCH,ZEROEQUAL,qbranch,QUIT2\n        DW CR,XSQUOTE\n        DB 3,'ok '\n        DW TYPE\nQUIT2:  DW branch,QUIT1\n\n;C ABORT    i*x --   R: j*x --   clear stk &amp; QUIT\n;   S0 SP!  QUIT ;\n    head ABORT,5,ABORT,docolon\n        DW S0,SPSTORE,QUIT   ; QUIT never returns\n\n;Z ?ABORT   f c-addr u --      abort &amp; print msg\n;   ROT IF TYPE ABORT THEN 2DROP ;\n    head QABORT,6,?ABORT,docolon\n        DW ROT,qbranch,QABO1,TYPE,ABORT\nQABO1:  DW TWODROP,EXIT\n\n;C ABORT\"  i*x 0  -- i*x   R: j*x -- j*x  x1=0\n;C         i*x x1 --       R: j*x --      x1&lt;&gt;0\n;   POSTPONE S\" POSTPONE ?ABORT ; IMMEDIATE\n    immed ABORTQUOTE,6,ABORT\",docolon\n        DW SQUOTE\n        DW LIT,QABORT,COMMAXT\n        DW EXIT\n\n;C '    -- xt           find word in dictionary\n;   BL WORD FIND\n;   0= ABORT\" ?\" ;\n;    head TICK,1,',docolon\n        DW link                 ; must expand\n        DB 0                    ; manually\nlink    DEFL $                  ; because of\n        DB 1,27h                ; tick character\nTICK:   call docolon\n        DW BL,WORD,FIND,ZEROEQUAL,XSQUOTE\n        DB 1,'?'\n        DW QABORT,EXIT\n\n;C CHAR   -- char           parse ASCII character\n;   BL WORD 1+ C@ ;\n    head CHAR,4,CHAR,docolon\n        DW BL,WORD,ONEPLUS,CFETCH,EXIT\n\n;C [CHAR]   --          compile character literal\n;   CHAR  ['] LIT ,XT  , ; IMMEDIATE\n    immed BRACCHAR,6,[CHAR],docolon\n        DW CHAR\n        DW LIT,LIT,COMMAXT\n        DW COMMA,EXIT\n\n;C (    --                     skip input until )\n;   [ HEX ] 29 WORD DROP ; IMMEDIATE\n    immed PAREN,1,(,docolon\n        DW LIT,29H,WORD,DROP,EXIT\n\n; COMPILER ======================================\n\n;C CREATE   --      create an empty definition\n;   LATEST @ , 0 C,         link &amp; immed field\n;   HERE LATEST !           new \"latest\" link\n;   BL WORD C@ 1+ ALLOT         name field\n;   docreate ,CF                code field\n    head CREATE,6,CREATE,docolon\n        DW LATEST,FETCH,COMMA,LIT,0,CCOMMA\n        DW HERE,LATEST,STORE\n        DW BL,WORD,CFETCH,ONEPLUS,ALLOT\n        DW LIT,docreate,COMMACF,EXIT\n\n;Z (DOES&gt;)  --      run-time action of DOES&gt;\n;   R&gt;              adrs of headless DOES&gt; def'n\n;   LATEST @ NFA&gt;CFA    code field to fix up\n;   !CF ;\n    head XDOES,7,(DOES&gt;),docolon\n        DW RFROM,LATEST,FETCH,NFATOCFA,STORECF\n        DW EXIT\n\n;C DOES&gt;    --      change action of latest def'n\n;   COMPILE (DOES&gt;)\n;   dodoes ,CF ; IMMEDIATE\n    immed DOES,5,DOES&gt;,docolon\n        DW LIT,XDOES,COMMAXT\n        DW LIT,dodoes,COMMACF,EXIT\n\n;C RECURSE  --      recurse current definition\n;   LATEST @ NFA&gt;CFA ,XT ; IMMEDIATE\n    immed RECURSE,7,RECURSE,docolon\n        DW LATEST,FETCH,NFATOCFA,COMMAXT,EXIT\n\n;C [        --      enter interpretive state\n;   0 STATE ! ; IMMEDIATE\n    immed LEFTBRACKET,1,[,docolon\n        DW LIT,0,STATE,STORE,EXIT\n\n;C ]        --      enter compiling state\n;   -1 STATE ! ;\n    head RIGHTBRACKET,1,],docolon\n        DW LIT,-1,STATE,STORE,EXIT\n\n;Z HIDE     --      \"hide\" latest definition\n;   LATEST @ DUP C@ 80 OR SWAP C! ;\n    head HIDE,4,HIDE,docolon\n        DW LATEST,FETCH,DUP,CFETCH,LIT,80H,OR\n        DW SWOP,CSTORE,EXIT\n\n;Z REVEAL   --      \"reveal\" latest definition\n;   LATEST @ DUP C@ 7F AND SWAP C! ;\n    head REVEAL,6,REVEAL,docolon\n        DW LATEST,FETCH,DUP,CFETCH,LIT,7FH,AND\n        DW SWOP,CSTORE,EXIT\n\n;C IMMEDIATE   --   make last def'n immediate\n;   1 LATEST @ 1- C! ;   set immediate flag\n    head IMMEDIATE,9,IMMEDIATE,docolon\n        DW LIT,1,LATEST,FETCH,ONEMINUS,CSTORE\n        DW EXIT\n\n;C :        --      begin a colon definition\n;   CREATE HIDE ] !COLON ;\n    head COLON,1,:,docode\n        CALL docolon    ; code fwd ref explicitly\n        DW CREATE,HIDE,RIGHTBRACKET,STORCOLON\n        DW EXIT\n\n;C ;\n;   REVEAL  ,EXIT\n;   POSTPONE [  ; IMMEDIATE\n    immed SEMICOLON,1,';',docolon\n        DW REVEAL,CEXIT\n        DW LEFTBRACKET,EXIT\n\n;C [']  --         find word &amp; compile as literal\n;   '  ['] LIT ,XT  , ; IMMEDIATE\n; When encountered in a colon definition, the\n; phrase  ['] xxx  will cause   LIT,xxt  to be\n; compiled into the colon definition (where\n; (where xxt is the execution token of word xxx).\n; When the colon definition executes, xxt will\n; be put on the stack.  (All xt's are one cell.)\n;    immed BRACTICK,3,['],docolon\n        DW link                 ; must expand\n        DB 1                    ; manually\nlink    DEFL $                  ; because of\n        DB 3,5Bh,27h,5Dh        ; tick character\nBRACTICK: call docolon\n        DW TICK               ; get xt of 'xxx'\n        DW LIT,LIT,COMMAXT    ; append LIT action\n        DW COMMA,EXIT         ; append xt literal\n\n;C POSTPONE  --   postpone compile action of word\n;   BL WORD FIND\n;   DUP 0= ABORT\" ?\"\n;   0&lt; IF   -- xt  non immed: add code to current\n;                  def'n to compile xt later.\n;       ['] LIT ,XT  ,      add \"LIT,xt,COMMAXT\"\n;       ['] ,XT ,XT         to current definition\n;   ELSE  ,XT      immed: compile into cur. def'n\n;   THEN ; IMMEDIATE\n    immed POSTPONE,8,POSTPONE,docolon\n        DW BL,WORD,FIND,DUP,ZEROEQUAL,XSQUOTE\n        DB 1,'?'\n        DW QABORT,ZEROLESS,qbranch,POST1\n        DW LIT,LIT,COMMAXT,COMMA\n        DW LIT,COMMAXT,COMMAXT,branch,POST2\nPOST1:  DW COMMAXT\nPOST2:  DW EXIT\n\n;Z COMPILE   --   append inline execution token\n;   R&gt; DUP CELL+ &gt;R @ ,XT ;\n; The phrase ['] xxx ,XT appears so often that\n; this word was created to combine the actions\n; of LIT and ,XT.  It takes an inline literal\n; execution token and appends it to the dict.\n;    head COMPILE,7,COMPILE,docolon\n;        DW RFROM,DUP,CELLPLUS,TOR\n;        DW FETCH,COMMAXT,EXIT\n; N.B.: not used in the current implementation\n\n; CONTROL STRUCTURES ============================\n\n;C IF       -- adrs    conditional forward branch\n;   ['] qbranch ,BRANCH  HERE DUP ,DEST ;\n;   IMMEDIATE\n    immed IF,2,IF,docolon\n        DW LIT,qbranch,COMMABRANCH\n        DW HERE,DUP,COMMADEST,EXIT\n\n;C THEN     adrs --        resolve forward branch\n;   HERE SWAP !DEST ; IMMEDIATE\n    immed THEN,4,THEN,docolon\n        DW HERE,SWOP,STOREDEST,EXIT\n\n;C ELSE     adrs1 -- adrs2    branch for IF..ELSE\n;   ['] branch ,BRANCH  HERE DUP ,DEST\n;   SWAP  POSTPONE THEN ; IMMEDIATE\n    immed ELSE,4,ELSE,docolon\n        DW LIT,branch,COMMABRANCH\n        DW HERE,DUP,COMMADEST\n        DW SWOP,THEN,EXIT\n\n;C BEGIN    -- adrs        target for bwd. branch\n;   HERE ; IMMEDIATE\n    immed BEGIN,5,BEGIN,docode\n        jp HERE\n\n;C UNTIL    adrs --   conditional backward branch\n;   ['] qbranch ,BRANCH  ,DEST ; IMMEDIATE\n;   conditional backward branch\n    immed UNTIL,5,UNTIL,docolon\n        DW LIT,qbranch,COMMABRANCH\n        DW COMMADEST,EXIT\n\n;X AGAIN    adrs --      uncond'l backward branch\n;   ['] branch ,BRANCH  ,DEST ; IMMEDIATE\n;   unconditional backward branch\n    immed AGAIN,5,AGAIN,docolon\n        DW LIT,branch,COMMABRANCH\n        DW COMMADEST,EXIT\n\n;C WHILE    -- adrs         branch for WHILE loop\n;   POSTPONE IF ; IMMEDIATE\n    immed WHILE,5,WHILE,docode\n        jp IF\n\n;C REPEAT   adrs1 adrs2 --     resolve WHILE loop\n;   SWAP POSTPONE AGAIN POSTPONE THEN ; IMMEDIATE\n    immed REPEAT,6,REPEAT,docolon\n        DW SWOP,AGAIN,THEN,EXIT\n\n;Z &gt;L   x --   L: -- x        move to leave stack\n;   CELL LP +!  LP @ ! ;      (L stack grows up)\n    head TOL,2,&gt;L,docolon\n        DW CELL,LP,PLUSSTORE,LP,FETCH,STORE,EXIT\n\n;Z L&gt;   -- x   L: x --      move from leave stack\n;   LP @ @  CELL NEGATE LP +! ;\n    head LFROM,2,L&gt;,docolon\n        DW LP,FETCH,FETCH\n        DW CELL,NEGATE,LP,PLUSSTORE,EXIT\n\n;C DO       -- adrs   L: -- 0\n;   ['] xdo ,XT   HERE     target for bwd branch\n;   0 &gt;L ; IMMEDIATE           marker for LEAVEs\n    immed DO,2,DO,docolon\n        DW LIT,xdo,COMMAXT,HERE\n        DW LIT,0,TOL,EXIT\n\n;Z ENDLOOP   adrs xt --   L: 0 a1 a2 .. aN --\n;   ,BRANCH  ,DEST                backward loop\n;   BEGIN L&gt; ?DUP WHILE POSTPONE THEN REPEAT ;\n;                                 resolve LEAVEs\n; This is a common factor of LOOP and +LOOP.\n    head ENDLOOP,7,ENDLOOP,docolon\n        DW COMMABRANCH,COMMADEST\nLOOP1:  DW LFROM,QDUP,qbranch,LOOP2\n        DW THEN,branch,LOOP1\nLOOP2:  DW EXIT\n\n;C LOOP    adrs --   L: 0 a1 a2 .. aN --\n;   ['] xloop ENDLOOP ;  IMMEDIATE\n    immed LOOP,4,LOOP,docolon\n        DW LIT,xloop,ENDLOOP,EXIT\n\n;C +LOOP   adrs --   L: 0 a1 a2 .. aN --\n;   ['] xplusloop ENDLOOP ;  IMMEDIATE\n    immed PLUSLOOP,5,+LOOP,docolon\n        DW LIT,xplusloop,ENDLOOP,EXIT\n\n;C LEAVE    --    L: -- adrs\n;   ['] UNLOOP ,XT\n;   ['] branch ,BRANCH   HERE DUP ,DEST  &gt;L\n;   ; IMMEDIATE      unconditional forward branch\n    immed LEAVE,5,LEAVE,docolon\n        DW LIT,unloop,COMMAXT\n        DW LIT,branch,COMMABRANCH\n        DW HERE,DUP,COMMADEST,TOL,EXIT\n\n; OTHER OPERATIONS ==============================\n\n;X WITHIN   n1|u1 n2|u2 n3|u3 -- f   n2&lt;=n1&lt;n3?\n;  OVER - &gt;R - R&gt; U&lt; ;          per ANS document\n    head WITHIN,6,WITHIN,docolon\n        DW OVER,MINUS,TOR,MINUS,RFROM,ULESS,EXIT\n\n;C MOVE    addr1 addr2 u --     smart move\n;             VERSION FOR 1 ADDRESS UNIT = 1 CHAR\n;  &gt;R 2DUP SWAP DUP R@ +     -- ... dst src src+n\n;  WITHIN IF  R&gt; CMOVE&gt;        src &lt;= dst &lt; src+n\n;       ELSE  R&gt; CMOVE  THEN ;          otherwise\n    head MOVE,4,MOVE,docolon\n        DW TOR,TWODUP,SWOP,DUP,RFETCH,PLUS\n        DW WITHIN,qbranch,MOVE1\n        DW RFROM,CMOVEUP,branch,MOVE2\nMOVE1:  DW RFROM,CMOVE\nMOVE2:  DW EXIT\n\n;C DEPTH    -- +n        number of items on stack\n;   SP@ S0 SWAP - 2/ ;   16-BIT VERSION!\n    head DEPTH,5,DEPTH,docolon\n        DW SPFETCH,S0,SWOP,MINUS,TWOSLASH,EXIT\n\n;C ENVIRONMENT?  c-addr u -- false   system query\n;                         -- i*x true\n;   2DROP 0 ;       the minimal definition!\n    head ENVIRONMENTQ,12,ENVIRONMENT?,docolon\n        DW TWODROP,LIT,0,EXIT\n\n; UTILITY WORDS AND STARTUP =====================\n\n;X WORDS    --          list all words in dict.\n;   LATEST @ BEGIN\n;       DUP COUNT TYPE SPACE\n;       NFA&gt;LFA @\n;   DUP 0= UNTIL\n;   DROP ;\n    head WORDS,5,WORDS,docolon\n        DW LATEST,FETCH\nWDS1:   DW DUP,COUNT,TYPE,SPACE,NFATOLFA,FETCH\n        DW DUP,ZEROEQUAL,qbranch,WDS1\n        DW DROP,EXIT\n\n;X .S      --           print stack contents\n;   SP@ S0 - IF\n;       SP@ S0 2 - DO I @ U. -2 +LOOP\n;   THEN ;\n    head DOTS,2,.S,docolon\n        DW SPFETCH,S0,MINUS,qbranch,DOTS2\n        DW SPFETCH,S0,LIT,2,MINUS,XDO\nDOTS1:  DW II,FETCH,UDOT,LIT,-2,XPLUSLOOP,DOTS1\nDOTS2:  DW EXIT\n\n;Z COLD     --      cold start Forth system\n;   UINIT U0 #INIT CMOVE      init user area\n;   80 COUNT INTERPRET       interpret CP/M cmd\n;   .\" Z80 CamelForth etc.\"\n;   ABORT ;\n    head COLD,4,COLD,docolon\n        DW UINIT,U0,NINIT,CMOVE\n        DW LIT,80h,COUNT,INTERPRET\n        DW XSQUOTE\n        DB 35,'Z80 CamelForth v1.01  25 Jan 1995'\n        DB 0dh,0ah\n        DW TYPE,ABORT       ; ABORT never returns\n</code></pre>"},{"location":"Moving_Forth/cameltst/","title":"Cameltst","text":"<pre><code>; Listing 1.\n; ===============================================\n; CamelForth for the Zilog Z80\n; Primitive testing code\n;\n; This is the \"minimal\" test of the CamelForth\n; kernel.  It verifies the threading and nesting\n; mechanisms, the stacks, and the primitives\n;   DUP EMIT EXIT lit branch ONEPLUS.\n; It is particularly useful because it does not\n; use the DO..LOOP, multiply, or divide words,\n; and because it can be used on embedded CPUs.\n; The numeric display word .A is also useful\n; for testing the rest of the Core wordset.\n;\n; The required macros and CPU initialization\n; are in file CAMEL80.AZM.\n; ===============================================\n\n;Z &gt;&lt;   u1 -- u2    swap the bytes of TOS\n    head SWAB,2,&gt;&lt;,docode\n        ld a,b\n        ld b,c\n        ld c,a\n        next\n\n;Z LO   c1 -- c2    return low nybble of TOS\n    head LO,2,LO,docode\n        ld a,c\n        and 0fh\n        ld c,a\n        ld b,0\n        next\n\n;Z HI   c1 -- c2    return high nybble of TOS\n    head HI,2,HI,docode\n        ld a,c\n        and 0f0h\n        rrca\n        rrca\n        rrca\n        rrca\n        ld c,a\n        ld b,0\n        next\n\n;Z &gt;HEX  c1 -- c2    convert nybble to hex char\n    head TOHEX,4,&gt;HEX,docode\n        ld a,c\n        sub 0ah\n        jr c,numeric\n        add a,7\nnumeric: add a,3ah\n        ld c,a\n        next\n\n;Z .HH   c --       print byte as 2 hex digits\n;   DUP HI &gt;HEX EMIT LO &gt;HEX EMIT ;\n    head DOTHH,3,.HH,docolon\n        DW DUP,HI,TOHEX,EMIT,LO,TOHEX,EMIT,EXIT\n\n;Z .B    a -- a+1   fetch &amp; print byte, advancing\n;   DUP C@ .HH 20 EMIT 1+ ;\n    head DOTB,2,.B,docolon\n    DW DUP,CFETCH,DOTHH,lit,20h,EMIT,ONEPLUS,EXIT\n\n;Z .A   u --       print unsigned as 4 hex digits\n;   DUP &gt;&lt; .HH .HH 20 EMIT ;\n    head DOTA,2,.A,docolon\n        DW DUP,SWAB,DOTHH,DOTHH,lit,20h,EMIT,EXIT\n\n;X DUMP   addr u --      dump u locations at addr\n;   0 DO\n;      I 15 AND 0= IF CR DUP .A THEN\n;      .B\n;   LOOP DROP ;\n    head DUMP,4,DUMP,docolon\n        DW LIT,0,XDO\nDUMP2:  DW II,LIT,15,AND,ZEROEQUAL,qbranch,DUMP1\n        DW CR,DUP,DOTA\nDUMP1:  DW DOTB,XLOOP,DUMP2,DROP,EXIT\n\n;Z ZQUIT   --    endless dump for testing\n;   0 BEGIN  0D EMIT 0A EMIT  DUP .A\n;       .B .B .B .B .B .B .B .B\n;       .B .B .B .B .B .B .B .B\n;   AGAIN ;\n    head ZQUIT,5,ZQUIT,docolon\n       DW lit,0\nzquit1:  DW lit,0dh,EMIT,lit,0ah,EMIT,DUP,DOTA\n       DW DOTB,DOTB,DOTB,DOTB,DOTB,DOTB,DOTB,DOTB\n       DW DOTB,DOTB,DOTB,DOTB,DOTB,DOTB,DOTB,DOTB\n       DW branch,zquit1\n</code></pre>"},{"location":"Moving_Forth/glosslo/","title":"Glosslo","text":"<pre><code>    TABLE 1.  GLOSSARY OF WORDS IN CAMEL80.AZM\n    Words which are (usually) written in CODE.\n\nNAME   stack in -- stack out          description\n\n  Guide to stack diagrams:  R: = return stack,\n  c = 8-bit character, flag = boolean (0 or -1), \n  n = signed 16-bit, u = unsigned 16-bit,\n  d = signed 32-bit, ud = unsigned 32-bit,\n  +n = unsigned 15-bit, x = any cell value, \n  i*x j*x = any number of cell values,\n  a-addr = aligned adrs, c-addr = character adrs\n  p-addr = I/O port adrs, sys = system-specific.\n  Refer to ANS Forth document for more details.\n\n               ANS Forth Core words\n\nThese are required words whose definitions are \nspecified by the ANS Forth document.\n\n!      x a-addr --           store cell in memory\n\n+ n1/u1 n2/u2 -- n3/u3             add n1+n2\n  +!     n/u a-addr --           add cell to memory\n- n1/u1 n2/u2 -- n3/u3        subtract n1-n2\n  &lt;      n1 n2 -- flag           test n1&lt;n2, signed\n  =      x1 x2 -- flag                   test x1=x2\n\n  &gt;      n1 n2 -- flag           test n1&gt;n2, signed\n  &gt; \n  &gt; R     x --   R: -- x        push to return stack\n  &gt; ?DUP   x -- 0 | x x                DUP if nonzero\n  &gt; @      a-addr -- x         fetch cell from memory\n  &gt; 0&lt;     n -- flag             true if TOS negative\n  &gt; 0=     n/u -- flag           return true if TOS=0\n  &gt; 1+     n1/u1 -- n2/u2                add 1 to TOS\n  &gt; 1-     n1/u1 -- n2/u2         subtract 1 from TOS\n  &gt; 2*     x1 -- x2             arithmetic left shift\n  &gt; 2/     x1 -- x2            arithmetic right shift\n  &gt; AND    x1 x2 -- x3                    logical AND\n  &gt; CONSTANT   n --           define a Forth constant\n  &gt; C!     c c-addr --           store char in memory\n  &gt; C@     c-addr -- c         fetch char from memory\n  &gt; DROP   x --                     drop top of stack\n  &gt; DUP    x -- x x            duplicate top of stack\n  &gt; EMIT   c --           output character to console\n  &gt; EXECUTE   i*x xt -- j*x   execute Forth word 'xt'\n  &gt; EXIT   --                 exit a colon definition\n  &gt; FILL   c-addr u c --        fill memory with char\n  &gt; I      -- n   R: sys1 sys2 -- sys1 sys2\n  &gt; \n  &gt;                 get the innermost loop index\n  &gt; \n  &gt; INVERT x1 -- x2                 bitwise inversion\n  &gt; J      -- n   R: 4*sys -- 4*sys\n  &gt; \n  &gt;                    get the second loop index\n  &gt; \n  &gt; KEY    -- c           get character from keyboard\n  &gt; LSHIFT x1 u -- x2        logical L shift u places\n  &gt; NEGATE x1 -- x2                  two's complement\n  &gt; OR     x1 x2 -- x3                     logical OR\n  &gt; OVER   x1 x2 -- x1 x2 x1        per stack diagram\n  &gt; ROT    x1 x2 x3 -- x2 x3 x1     per stack diagram\n  &gt; RSHIFT x1 u -- x2        logical R shift u places\n  &gt; R&gt;     -- x    R: x --      pop from return stack\n  &gt; R@     -- x    R: x -- x       fetch from rtn stk\n  &gt; SWAP   x1 x2 -- x2 x1          swap top two items\n  &gt; UM*    u1 u2 -- ud       unsigned 16x16-&gt;32 mult.\n  &gt; UM/MOD ud u1 -- u2 u3     unsigned 32/16-&gt;16 div.\n  &gt; UNLOOP --   R: sys1 sys2 --       drop loop parms\n  &gt; U&lt;     u1 u2 -- flag         test u1&lt;n2, unsigned\n  &gt; VARIABLE   --             define a Forth variable\n  &gt; XOR    x1 x2 -- x3                    logical XOR\n\n            ANS Forth Extensions\n\n  These are optional words whose definitions are\n  specified by the ANS Forth document.\n\n&lt;&gt;     x1 x2 -- flag               test not equal \nBYE    i*x --                      return to CP/M\nCMOVE  c-addr1 c-addr2 u --      move from bottom\nCMOVE&gt; c-addr1 c-addr2 u --         move from top\nKEY?   -- flag        return true if char waiting\nM+     d1 n -- d2            add single to double\nNIP    x1 x2 -- x2              per stack diagram\nTUCK   x1 x2 -- x2 x1 x2        per stack diagram\nU&gt;     u1 u2 -- flag         test u1&gt;u2, unsigned \n\n               Private Extensions\n\nThese are words which are unique to CamelForth.\nMany of these are necessary to implement ANS\nForth words, but are not specified by the ANS\ndocument.  Others are functions I find useful.\n\n(do)   n1|u1 n2|u2 --  R: -- sys1 sys2\n                             run-time code for DO\n(loop) R: sys1 sys2 --  | sys1 sys2\n                           run-time code for LOOP\n(+loop)  n --   R: sys1 sys2 --  | sys1 sys2\n                          run-time code for +LOOP\n\n&gt; &lt;     x1 -- x2                        swap bytes \n&gt; ?branch  x --                  branch if TOS zero\n&gt; BDOS   DE C -- A                   call CP/M BDOS\n&gt; branch --                           branch always\n&gt; lit    -- x         fetch inline literal to stack\n&gt; PC!    c p-addr --            output char to port\n&gt; PC@    p-addr -- c           input char from port\n&gt; RP!    a-addr --         set return stack pointer\n&gt; RP@    -- a-addr         get return stack pointer\n&gt; SCAN   c-addr1 u1 c -- c-addr2 u2\n&gt;                                find matching char\n&gt; SKIP   c-addr1 u1 c -- c-addr2 u2\n&gt;                               skip matching chars\n&gt; SP!    a-addr --           set data stack pointer\n&gt; SP@    -- a-addr           get data stack pointer\n&gt; S=     c-addr1 c-addr2 u -- n      string compare\n&gt;                n&lt;0: s1&lt;s2, n=0: s1=s2, n&gt;0: s1&gt;s2\n&gt; USER   n --              define user variable 'n'\n</code></pre>"},{"location":"Moving_Forth/moving1/","title":"MOVING FORTH 1","text":"<p>Part 1: Design Decisions in the Forth Kernel by Brad Rodriguez</p> <p>This article first appeared in The Computer Journal (TCJ) #59 (January/February 1993).</p>"},{"location":"Moving_Forth/moving1/#introduction","title":"INTRODUCTION","text":"<p>Everyone in the Forth community talks about how easy it is to port Forth to a new CPU. But like many \"easy\" and \"obvious\" tasks, not much is written on how to do it! So, when Bill Kibler suggested this topic for an article, I decided to break with the great oral tradition of Forthwrights, and document the process in black and white. Over the course of these articles I will develop Forths for the 6809, 8051, and Z80. I'm doing the 6809 to illustrate an easy and conventional Forth model; plus, I've already published a 6809 assembler [ROD91] [ROD92], and I'll be needing a 6809 Forth for future TCJ projects. I'm doing the 8051 Forth for a University project, but it also illustrates some rather different design decisions. The Z80 Forth is for all the CP/M readers of TCJ, and for some friends with TRS-80s gathering dust.</p>"},{"location":"Moving_Forth/moving1/#the-essential-hardware","title":"THE ESSENTIAL HARDWARE","text":"<p>You must choose a CPU. I will not delve into the merits of one CPU over another for Forth, since a CPU choice is usually forced upon you by other considerations. Besides, the object of this article is to show how to move Forth to any CPU.</p> <p>You can expect the usual 16-bit Forth kernel (see below) to occupy about 8 kBytes of program space. For a full kernel that can compile Forth definitions, you should allow a minimum of 1 kByte of RAM. To use Forth's block-management system for disk storage, you should add 3 kBytes or more for buffers. For a 32-bit Forth model, double these numbers.</p> <p>These are the minimums to get a Forth kernel up and running. To run an application on your hardware, you should increase PROM and RAM sizes to suit.</p>"},{"location":"Moving_Forth/moving1/#16-or-32-bit","title":"16 OR 32 BIT?","text":"<p>The word size used by Forth is not necessarily the same as that of the CPU. The smallest practical Forth is a 16-bit model; i.e., one which uses 16-bit integers and 16-bit addresses. The Forth community calls this the \"cell\" size, since \"word\" refers to a Forth definition.</p> <p>8-bit CPUs almost invariably support 16-bit Forths. This usually requires explicit coding of double-byte arithmetic, although some 8-bit CPUs do have a few 16-bit operations.</p> <p>16-bit CPUs commonly run 16-bit Forths, although the same double-precision techniques can be used to write a 32-bit Forth on a 16-bit CPU. At least one 32-bit Forth has been written for the 8086/8088.</p> <p>32-bit CPUs normally run 32-bit Forths. A smaller Forth model rarely saves code length or processor time. However, I know of at least one 16-bit Forth written for the 68000. This does shrink application code size by a factor of two, since high-level Forth definitions become a string of 16-bit addresses rather than a string of 32-bit addresses. (This will become evident shortly.) Most 68000s, though, have plenty of RAM.</p> <p>All of the examples described in this article are 16-bit Forths running on 8-bit CPUs.</p>"},{"location":"Moving_Forth/moving1/#the-threading-technique","title":"THE THREADING TECHNIQUE","text":"<p>\"Threaded code\" is the hallmark of Forth. A Forth \"thread\" is just a list of addresses of routines to be executed. You can think of this as a list of subroutine calls, with the CALL instructions removed. Over the years many threading variations have been devised, and which one is best depends upon the CPU and the application. To make a decision, you need to understand how they work, and their trade-offs.</p>"},{"location":"Moving_Forth/moving1/#indirect-threaded-code-itc","title":"Indirect Threaded Code (ITC)","text":"<p>This is the classical Forth threading technique, used in fig-Forth and F83, and described in most books on Forth. All the other threading schemes are \"improvements\" on this, so you need to understand ITC to appreciate the others.</p> <p>Let's look at the definition of a Forth word SQUARE:</p> <pre><code>: SQUARE  DUP * ;\n</code></pre> <p>In a typical ITC Forth this would appear in memory as shown in Figure 1. (The Header Field will be discussed in a future article; it holds housekeeping information used for compilation, and isn't involved in threading.)</p> <p> Figure 1. Indirect Threaded Code</p> <p></p> <p>Assume SQUARE is encountered while executing some other Forth word. Forth's Interpreter Pointer (IP) will be pointing to a cell in memory -- contained within that \"other\" word -- which contains the address of the word SQUARE. (To be precise, that cell contains the address of SQUARE's Code Field .) The interpreter fetches that address, and then uses it to fetch the contents of SQUARE's Code Field. These contents are yet another address -- the address of a machine language subroutine which performs the word SQUARE. In pseudo-code, this is:</p> <p>NEXT (interpreter)</p>     (IP) -&gt; W        fetch memory pointed by IP into \"W\" register  ... W now holds address of the Code Field     IP+2 -&gt; IP        advance IP, just like a program counter  (assuming 2-byte addresses in the thread)         (W) -&gt; X        fetch memory pointed by W into \"X\" register  ... X now holds address of the machine code         JP (X)        jump to the address in the X register     <p>This illustrates an important but rarely-elucidated principle: the address of the Forth word just entered is kept in W. CODE words don't need this information, but all other kinds of Forth words do.</p> <p>If SQUARE were written in machine code, this would be the end of the story: that bit of machine code would be executed, and then jump back to the Forth interpreter -- which, since IP was incremented, is pointing to the next word to be executed. This is why the Forth interpreter is usually called NEXT.</p> <p>But, SQUARE is a high-level \"colon\" definition -- it holds a \"thread\", a list of addresses. In order to perform this definition, the Forth interpreter must be re-started at a new location: the Parameter Field of SQUARE. Of course, the interpreter's old location must be saved, to resume the \"other\" Forth word once SQUARE is finished. This is just like a subroutine call! The machine language action of SQUARE is simply to push the old IP, set IP to a new location, run the interpreter, and when SQUARE is done pop the IP. (As you can see, the IP is the \"program counter\" of high-level Forth.) This is called DOCOLON or ENTER in various Forths:</p> <p>ENTER</p>     PUSH IP        onto the \"return address stack\"         W+2 -&gt; IP        W still points to the Code Field, so W+2 is the address of the Body! (Assuming a 2-byte address -- other Forths may be different.)         JUMP        to interpreter (\"NEXT\")     <p>This identical code fragment is used by all high-level (i.e., threaded) Forth definitions! That's why a pointer to this code fragment, not the fragment itself, is included in the Forth definition. Over hundreds of definitions, the savings add up! And this is why it's called Indirect threading.</p> <p>The \"return from subroutine\" is the word EXIT, which gets compiled when Forth sees ';'. (Some Forths call it ;S instead of EXIT.) EXIT just executes a machine language routine which does the following:</p> <p>EXIT</p>     POP IP        from the \"return address stack\"         JUMP        to interpreter     <p>Walk through a couple of nested Forth definitions, just to assure yourself that this works.</p> <p>Note the characteristics of ITC: every Forth word has a one-cell Code Field. Colon definitions compile one cell for each word used in the definition. And the Forth interpreter must actually perform a double indirection to get the address of the next machine code to run (first through IP, then through W).</p> <p>ITC is neither the smallest nor the fastest threading technique. It may be the simplest; although DTC (described next) is really no more complex. So why are so many Forths indirect-threaded? Mainly because previous Forths, used as models, were indirect-threaded. These days, DTC is becoming more popular.</p> <p>So when should ITC be used? Of the various techniques, ITC produces the cleanest and most elegant definitions -- nothing but addresses. If you're attuned to such considerations, ITC may appeal to you. If your code fiddles around with the insides of definitions, the simplicity and uniformity of the ITC representation may enhance portability. ITC is the classical Forth model, so it may be preferred for education. Finally, on CPUs lacking a subroutine call instruction -- such as the 1802 -- ITC is often more efficient than DTC.</p>"},{"location":"Moving_Forth/moving1/#direct-threaded-code-dtc","title":"Direct Threaded Code (DTC)","text":"<p>Direct Threaded Code differs from ITC in only one respect: instead of the Code Field containing the address of some machine code, the Code Field contains actual machine code itself.</p> <p>I'm not saying that the complete code for ENTER is contained in each and every colon definition! In \"high-level\" Forth words, the Code Field will contain a subroutine call, as shown in Figure 2. Colon definitions, for instance, will contain a call to the ENTER routine.</p> <p> Figure 2. Direct Threaded Code</p> <p></p> <p>The NEXT pseudo-code for direct threading is simply:</p>     (IP) -&gt; W        fetch memory pointed by IP into \"W\" register         IP+2 -&gt; IP        advance IP (assuming 2-byte addresses)         JP (W)        jump to the address in the W register     <p>This gains speed: the interpreter now performs only a single indirection. On the Z80 this reduces the NEXT routine -- the most-used code fragment in the Forth kernel -- from eleven instructions to seven!</p> <p>This costs space: every high-level definition in a Z80 Forth (for example) is now one byte longer, since a 2-byte address has been replaced by a 3-byte call. But this is not universally true. A 32-bit 68000 Forth may replace a 4-byte address with a 4-byte BSR instruction, for no net loss. And on the Zilog Super8, which has machine instructions for DTC Forth, the 2-byte address is replaced by a 1-byte ENTER instruction, making a DTC Forth smaller on the Super8! </p> <p>Of course, DTC CODE definitions are two bytes shorter, since they no longer need a pointer at all! </p> <p>I used to think that high-level definitions in DTC Forths required the use of a subroutine call in the Code Field. Frank Sergeant's Pygmy Forth [SER90] demonstrates that a simple jump can be used just as easily, and will usually be faster.</p> <p>Guy Kelly has compiled a superb review of Forth implementations for the IBM PC [KEL92], which I strongly recommend to all Forth kernel writers. Of the 19 Forths he studied, 10 used DTC, 7 used ITC, and 2 used subroutine threading (discussed next). I recommend the use of Direct-Threaded Code over Indirect-Threaded Code for all new Forth kernels.</p>"},{"location":"Moving_Forth/moving1/#jump-to-next-or-code-it-in-line","title":"Jump to NEXT, or code it in-line?","text":"<p>The Forth inner interpreter, NEXT, is a common routine to all CODE definitions. You might keep just one copy of this common routine, and have all CODE words jump to it. (Note that you Jump to NEXT; a subroutine Call is not necessary.)</p> <p>However, the speed of NEXT is crucial to the speed of the entire Forth system. Also, on many CPUs, the NEXT routine is quite short; often only two or three instructions. So it may be preferable to code NEXT in-line, wherever it is used. This is frequently done by making NEXT an assembler macro.</p> <p>This is a simple speed vs. space decision: in-line NEXT is always faster, but almost always larger. The total size increase is the number of extra bytes required for in-line expansion, times the number of CODE words in the system. Sometimes there's no tradeoff at all: in a 6809 DTC Forth, an in-line NEXT is shorter than a Jump instruction!</p>"},{"location":"Moving_Forth/moving1/#subroutine-threaded-code-stc","title":"Subroutine Threaded Code (STC)","text":"<p>A high-level Forth definition is nothing but a list of subroutines to be executed. You don't need interpreters to accomplish this; you can get the same effect by simply stringing a list of subroutine calls together:</p> <pre><code>SQUARE: CALL DUP\n        CALL *     ; or a suitable alphanumeric name\n        RET\n</code></pre> <p>See Figure 3. This representation of Forth words has been used as a starting point to explain Forth threading techniques to assembly language programmers [KOG82].</p> <p> Figure 3. Subroutine Threaded Code</p> <p></p> <p>STC is an elegant representation; colon definitions and CODE words are now identical. \"Defined words\" (VARIABLEs, CONSTANTs, and the like) are handled the same as in DTC -- the Code Field begins with a jump or call to some machine code elsewhere.</p> <p>The major disadvantage is that subroutine calls are usually larger than simple addresses. On the Z80, for example, the size of colon definitions increases by 50% -- and most of your application is colon definitions! Contrariwise, on a 32-bit 68000 there may be no size increase at all, when 4-byte addresses are replaced with 4-byte BSRs. (But if your code size exceeds 64K, some of those addresses must be replaced with 6-byte JSRs.)</p> <p>Subroutine threading may be faster than direct threading. You save time by not having an interpreter, but you lose time because every reference to a Forth word involves a push and pop of a return address. In a DTC Forth, only high-level words cause activity on the return stack. On the 6809 or Zilog Super8, DTC is faster than STC.</p> <p>There is another advantage to STC: it dispenses with the IP register. Some processors -- like the 8051 -- are desperately short of addressing registers. Eliminating the IP can really simplify and speed up the kernel!</p> <p>The only way to know for sure is to write sample code. This is intimately involved with register selection, discussed in the next section.</p>"},{"location":"Moving_Forth/moving1/#stc-with-in-line-expansion-optimization-direct-compilation","title":"STC with in-line expansion; optimization; direct compilation","text":"<p>On older and 8-bit CPUs, almost every Forth primitive involves several machine instructions. But on more powerful CPUs, many Forth primitives are written in a single instruction. For example, on the 32-bit 68000, DROP is simply</p> <pre><code>    ADDQ    #4,An     where An is Forth's PSP register\n</code></pre> <p>In a subroutine-threaded Forth, using DROP in a colon definition would result in the sequence</p> <pre><code>BSR ...\nBSR DROP  -------&gt;   DROP: ADDQ #4,An\nBSR ...   &lt;-------         RTS\n</code></pre> <p>ADDQ is a two-byte instruction. Why write a four-byte subroutine call to a two-byte instruction? No matter how many times DROP is used, there's no savings! The code is smaller and faster if the ADDQ is coded directly into the stream of BSRs. Some Forth compilers do this \"in-line expansion\" of CODE words [CUR93a].</p> <p>The disadvantage of in-line expansion is that decompiling back to the original source code becomes very difficult. As long as subroutine calls are used, you still have pointers (the subroutine addresses) to the Forth words comprising the thread. With pointers to the words, you can obtain their names. But once a word is expanded into in-line code, all knowledge of where that code came from is lost.</p> <p>The advantage of in-line expansion -- aside from speed and size -- is the potential for code optimization. For example, the Forth sequence</p> <pre><code>3 +  \n</code></pre> <p>would be compiled in 68000 STC as</p> <pre><code>    BSR     LIT\n    .DW     3 \n    BSR     PLUS\n</code></pre> <p>but could be expanded in-line as a single machine instruction!</p> <p>Optimizing Forth compilers is too broad a topic for this article. This is an active area of Forth language research; see, for instance, [SCO89] and [CUR93b]. The final culmination of optimized STC is a Forth which compiles to \"pure\" machine code, just like a C or Fortran compiler.</p>"},{"location":"Moving_Forth/moving1/#token-threaded-code-ttc","title":"Token Threaded Code (TTC)","text":"<p>DTC and STC aim to improve the speed of Forth programs, at some cost in memory. Now let's move the other direction from ITC, toward something slower but smaller.</p> <p>The purpose of a Forth thread is to specify a list of Forth words (subroutines) to be performed. Suppose a 16-bit Forth system only had a maximum of 256 different words. Then each word could be uniquely identified by an 8-bit number. Instead of a list of 16-bit addresses, you would have a list of 8-bit identifiers or \"tokens,\" and the size of the colon definitions would be halved!</p> <p>A token-threaded Forth keeps a table of addresses of all Forth words, as shown in Figure 4. The token value is then used to index into this table, to find the Forth word corresponding to a given token. This adds one level of indirection to the Forth interpreter, so it is slower than an \"address-threaded\" Forth.</p> <p> Figure 4. Token Threaded Code</p> <p></p> <p>The principal advantage of token-threaded Forths is small size. TTC is most commonly seen in handheld computers and other severely size-constrained applications. Also, the table of \"entry points\" into all the Forth words can simplify linkage of separately-compiled modules.</p> <p>The disadvantage of TTC is speed: TTC makes the slowest Forths. Also, the TTC compiler is slightly more complex. If you need more than 256 Forth words, it's necessary to have some open-ended encoding scheme to mix 8-bit and larger tokens.</p> <p>I can envision a 32-bit Forth using 16-bit tokens, but how many 32-bit systems are size-constrained?</p>"},{"location":"Moving_Forth/moving1/#segment-threaded-code","title":"Segment Threaded Code","text":"<p>Since there are so many 8086 derivatives in the world, segment threading deserves a brief mention. Instead of using \"normal\" byte addresses within a 64K segment, paragraph addresses are used. (A \"paragraph\" is 16 bytes in the 8086.) Then, the interpreter can load these addresses into segment registers, instead of into the usual address registers. This allows a 16- bit Forth model to efficiently access the full megabyte of 8086 memory.</p> <p>The principal disadvantage of segment threading is the 16-byte \"granularity\" of the memory space. Every Forth word must be aligned to a 16-byte boundary. If Forth words have random lengths, an average of 8 bytes will be wasted per Forth word.</p>"},{"location":"Moving_Forth/moving1/#register-allocation","title":"REGISTER ALLOCATION","text":"<p>Next to the threading technique, the usage of the CPU's registers is the most crucial design decision. It's probably the most difficult. The availability of CPU registers can determine what threading technique can be used, and even what the memory map will be!</p>"},{"location":"Moving_Forth/moving1/#the-classical-forth-registers","title":"The Classical Forth Registers","text":"<p>The classical Forth model has five \"virtual registers.\" These are abstract entities which are used in the primitive operations of Forth. NEXT, ENTER, and EXIT were defined earlier in terms of these abstract registers.</p> <p>Each of these is one cell wide -- i.e., in a 16-bit Forth, these are 16-bit registers. (There are exceptions to this rule, as you will see later.) These may not all be CPU registers. If your CPU doesn't have enough registers, some of these can be kept in memory. I'll describe them in the order of their importance; i.e., the bottom of this list are the best candidates to be stored in memory.</p> <p>W is the Working register. It is used for many things, including memory reference, so it should be an address register; i.e., you must be able to fetch and store memory using the contents of W as the address. You also need to be able to do arithmetic on W. (In DTC Forths, you must also be able to jump indirect using W.) W is used by the interpreter in every Forth word. In a CPU having only one register, you would use it for W and keep everything else in memory (and the system would be incredibly slow).</p> <p>IP is the Interpreter Pointer. This is used by every Forth word (through NEXT, ENTER, or EXIT). IP must be an address register. You also need to be able to increment IP. Subroutine threaded Forths don't need this register.</p> <p>PSP is the Parameter Stack (or \"data stack\") Pointer, sometimes called simply SP. I prefer PSP because SP is frequently the name of a CPU register, and they shouldn't be confused. Most CODE words use this. PSP must be a stack pointer, or an address register which can be incremented and decremented. It's also a plus if you can do indexed addressing from PSP.</p> <p>RSP is the Return Stack Pointer, sometimes called simply RP. This is used by colon definitions in ITC and DTC Forths, and by all words in STC Forths. RSP must be a stack pointer, or an address register which can be incremented and decremented.</p> <p>If at all possible, put W, IP, PSP, and RSP in registers. The virtual registers that follow can be kept in memory, but there is usually a speed advantage to keeping them in CPU registers.</p> <p>X is a working register, not considered one of the \"classical\" Forth registers, even though the classical ITC Forths need it for the second indirection. In ITC you must be able to jump indirect using X. X may also be used by a few CODE words to do arithmetic and such. This is particularly important on processors that cannot use memory as an operand. For example, ADD on a Z80 might be (in pseudo-code)</p> <pre><code>POP W   POP X   X+W -&gt; W   PUSH W \n</code></pre> <p>Sometimes another working register, Y, is also defined.</p> <p>UP is the User Pointer, holding the base address of the task's user area. UP is usually added to an offset, and used by high-level Forth code, so it can be just stored somewhere. But if the CPU can do indexed addressing from the UP register, CODE words can more easily and quickly access user variables. If you have a surplus of address registers, use one for UP. Single-task Forths don't need UP.</p> <p>X -- if needed -- is more important to keep in register than UP. UP is the easiest of the Forth virtual registers to move into memory.</p>"},{"location":"Moving_Forth/moving1/#use-of-the-hardware-stack","title":"Use of the Hardware Stack","text":"<p>Most CPUs have a stack pointer as part of their hardware, used by interrupts and subroutine calls. How does this map into the Forth registers? Should it be the PSP or the RSP?</p> <p>The short answer is, it depends. It is said that the PSP is used more than the RSP in ITC and DTC Forths. If your CPU has few address registers, and PUSH and POP are faster than explicit reference, use the hardware stack as the Parameter Stack.</p> <p>On the other hand, if your CPU is rich in addressing modes -- and allows indexed addressing -- there's a plus in having the PSP as a general-purpose address register. In this case, use the hardware stack as the Return Stack.</p> <p>Sometimes you do neither! The TMS320C25's hardware stack is only eight cells deep -- all but useless for Forth. So its hardware stack is used only for interrupts, and both PSP and RSP are general-purpose address registers. (ANS Forth specifies a minimum of 32 cells of Parameter Stack and 24 cells of Return Stack; I prefer 64 cells of each.)</p> <p>You will occasionally encounter the dogma that the hardware stack \"must be\" the Parameter Stack, or \"must be\" the Return Stack. Instead, code some sample Forth primitives, such as</p> <pre><code>SWAP  OVER  @  !  +  0=  \n</code></pre> <p>and see which approach is smaller or faster. (DUP and DROP, by the way, are no test -- they're usually trivial.)</p> <p>Occasionally you reach strange conclusions! Gary Bergstrom has pointed out that a 6809 DTC Forth can be made a few cycles faster by using the 6809 user stack pointer as the IP; NEXT becomes a POP. He uses an index register for one of Forth's stacks.</p>"},{"location":"Moving_Forth/moving1/#top-of-stack-in-register","title":"Top-Of-Stack in Register","text":"<p>Forth's performance can be improved considerably by keeping the top element of the Parameter Stack in a register! Many Forth words (such as 0=) then don't need to use the stack. Other words still do the same number of pushes and pops, only in a different place in the code. Only a few Forth words (DROP and 2DROP) become more complicated, since you can no longer simply adjust the stack pointer -- you have to update the TOS register as well.</p> <p>There are a few rules when writing CODE words:</p> <p>A word which removes items from the stack must pop the \"new\" TOS into its register.</p> <p>A word which adds items to the stack must push the \"old\" TOS onto the stack (unless, of course, it's consumed by the word).</p> <p>If you have at least six cell-size CPU registers, I recommend keeping the TOS in a register. I consider TOS more important than UP to have in register, but less important than W, IP, PSP, and RSP. (TOS in register performs many of the functions of the X register.) It's useful if this register can perform memory addressing. PDP-11s, Z8s, and 68000s are good candidates.</p> <p>Nine of the 19 IBM PC Forths studied by Guy Kelly [KEL92] keep TOS in register.</p> <p>I think this innovation has been resisted because of the false beliefs that a) it adds instructions, and b) the top stack element must be accessible as memory. It turns out that even such words as PICK, ROLL, and DEPTH are trivially modified for TOS-in-register.</p> <p>What about buffering two stack elements in registers? When you keep the top of stack in a register, the total number of operations performed remains essentially the same. A push remains a push, regardless of whether it is before or after the operation you're performing. On the other hand, buffering two stack elements in registers adds a large number of instructions -- a push becomes a push followed by a move. Only dedicated Forth processors like the RTX2000 and fantastically clever optimizing compilers can benefit from buffering two stack elements in registers.</p>"},{"location":"Moving_Forth/moving1/#some-examples","title":"Some examples","text":"<p>Here are the register assignments made by Forths for a number of different CPUs. Try to deduce the design decisions of the authors from this list.</p> <p>Register Assignments</p>  W  IP  PSP  RSP  UP  TOS   8086<sup>[1]</sup>  BX  SI  SP  BP  memory  memory  [LAX84]  8086<sup>[2]</sup>  AX  SI  SP  BP  none  BX  [SER90]  68000  A5  A4  A3  A7=SP  A6  memory  [CUR86]  PDP-11  R2  R4  R5  R6=SP  R3  memory  [JAM80]  6809  X  Y  U  S  memory  memory  [TAL80]  6502  Zpage  Zpage  X  SP  Zpage  memory  [KUN81]  Z80  DE  BC  SP  IX  none  memory  [LOE81]  Z8  RR6  RR12  RR14  SP  RR10  RR8  [MPE92]  8051  R0,1  R2,3  R4,5  R6,7  fixed  memory  [PAY90] <sup>[1]</sup>F83.   <sup>[2]</sup>Pygmy Forth.                <p>\"SP\" refers to the hardware stack pointer. \"Zpage\" refers to values kept in the 6502's memory page zero, which are almost as useful as -- sometimes more useful than -- values kept in registers; e.g., they can be used for memory addressing. \"Fixed\" means that Payne's 8051 Forth has a single, immovable user area, and UP is a hard-coded constant.</p>"},{"location":"Moving_Forth/moving1/#narrow-registers","title":"Narrow Registers","text":"<p>Notice anything odd in the previous list? The 6502 Forth -- a 16-bit model -- uses 8-bit stack pointers!</p> <p>It is possible to make PSP, RSP, and UP smaller than the cell size of the Forth. This is because the stacks and user area are both relatively small areas of memory. Each stack may be as small as 64 cells in length, and the user area rarely exceeds 128 cells. You simply need to ensure that either a) these data areas are confined to a small area of memory, so a short address can be used, or b) the high address bits are provided in some other way, e.g., a memory page select.</p> <p>In the 6502, the hardware stack is confined to page one of RAM (addresses 01xxh) by the design of the CPU. The 8-bit stack pointer can be used for the Return Stack. The Parameter Stack is kept in page zero of RAM, which can be indirectly accessed by the 8-bit index register X. (Question for the advanced student: why use the 6502's X, and not Y? Hint: look at the addressing modes available.)</p> <p>In the 8051, you can use the 8-bit registers R0 and R1 to address external RAM, provided that you explicitly output the high 8 bits of address to port 2. This allows a \"page select\" for two stacks.</p> <p>UP is different from PSP and RSP: it simply provides a base address; it is never incremented or decremented. So it's practical to supply only the high bits of this virtual register. The low bits must then be provided by whatever indexed addressing technique is used. For example, on the 6809, you can use the DP register to hold the high 8 bits of UP, and then use Direct Page addressing to access any of the 256 locations in this page. This forces all user areas to begin on an address xx00h, which is no great hardship, and limits the user area to 128 cells in length.</p> <p>On the 8086 you could conceivably use a segment register to specify the base address of the user area.</p>"},{"location":"Moving_Forth/moving1/#references","title":"REFERENCES","text":"<p>[CUR93a] Curley, Charles, \"Life in the FastForth Lane\", awaiting publication in Forth Dimensions. Description of a 68000 subroutine-threaded Forth. [1] [2] [3] [4]</p> <p>[CUR93b] Curley, Charles, \"Optimizing in a BSR/JSR Threaded Forth\", awaiting publication in Forth Dimensions. Single-pass code optimization for FastForth, in only five screens of code! Includes listing. [1] [2] [3]</p> <p>[KEL92] Kelly, Guy M., \"Forth Systems Comparisons\", Forth Dimensions XIII:6 (Mar/Apr 1992). Also published in the 1991 FORML Conference Proceedings. Both available from the Forth Interest Group, P.O. Box 2154, Oakland, CA 94621. Illustrates design trade offs of many 8086 Forths with code fragments and benchmarks -- highly recommended! [1] [2]</p> <p>[KOG82] Kogge, Peter M., \"An Architectural Trail to Threaded-Code Systems\", IEEE Computer, vol. 15 no. 3 (Mar 1982). Remains the definitive description of various threading techniques. [1] [[2]]</p> <p>[ROD91] Rodriguez, B.J., \"B.Y.O. Assembler\", Part 1, The Computer Journal #52 (Sep/Oct 1991). General principles of writing Forth assemblers. [1]</p> <p>[ROD92] Rodriguez, B.J., \"B.Y.O. Assembler\", Part 2, The Computer Journal #54 (Jan/Feb 1992). A 6809 assembler in Forth. [1]</p> <p>[SCO89] Scott, Andrew:</p> <ul> <li> <p>\"An Extensible Optimizer for Compiling Forth\", 1989 FORML Conference Proceedings, Forth Interest Group, P.O. Box 2154, Oakland, CA 94621. Good description of a 68000 optimizer; no code provided.</p> </li> <li> <p>\"Extensible Optimizing Compiler\", Forth Dimensions XII:2 (Jul/Aug 1990). [1] [2]</p> </li> </ul>"},{"location":"Moving_Forth/moving1/#forth-implementations","title":"Forth Implementations","text":"<p>[CUR86] Curley, Charles, real-Forth for the 68000, privately distributed (1986). [1]</p> <p>[JAM80] James, John S., fig-Forth for the PDP-11, Forth Interest Group (1980). [1] [2]</p> <p>[KUN81] Kuntze, Robert E., MVP-Forth for the Apple II, Mountain View Press (1981). [1]</p> <p>[LAX84] Laxen, H. and Perry, M., F83 for the IBM PC, version 2.1.0 (1984). Distributed by the authors, available from the Forth Interest Group or GEnie. [1] [2]</p> <p>[LOE81] Loeliger, R. G., Threaded Interpretive Languages, BYTE Publications (1981), ISBN 0-07-038360-X. May be the only book ever written on the subject of creating a Forth-like kernel (the example used is the Z80). Worth it if you can find a copy. [1]</p> <p>[MPE92] MicroProcessor Engineering Ltd., MPE Z8/Super8 PowerForth Target, MPE Ltd., 133 Hill Lane, Shirley, Southampton, S01 5AF, U.K. (June 1992). A commercial product. [1]</p> <p>[PAY90] Payne, William H., Embedded Controller FORTH for the 8051 Family, Academic Press (1990), ISBN 0-12-547570-5. This is a complete \"kit\" for a 8051 Forth, including a metacompiler for the IBM PC. Hardcopy only; files can be downloaded from GEnie. Not for the novice! [1]</p> <p>[SER90] Sergeant, Frank, Pygmy Forth for the IBM PC, version 1.3 (1990). Distributed by the author, available from the Forth Interest Group. Version 1.4 is now available on GEnie, and worth the extra effort to obtain. [1]</p> <p>[TAL80] Talbot, R. J., fig-Forth for the 6809, Forth Interest Group (1980). [1]</p> <p>Author's note for web publication: the files formerly available on the GEnie online service are now available from the Forth Interest Group FTP server, ftp://ftp.forth.org/pub/Forth http://www.forth.org/</p>"},{"location":"Moving_Forth/moving2/","title":"MOVING FORTH 2","text":"<p>Part 2: Benchmarks and Case Studies of Forth Kernels by Brad Rodriguez</p> <p>This article first appeared in The Computer Journal #60 (March/April 1993).</p>"},{"location":"Moving_Forth/moving2/#benchmarks","title":"BENCHMARKS","text":"<p>By now it must seem that the answer to every design question is \"code it and see.\" Obviously you don't want to write the entire Forth kernel several different ways just to evaluate different schemes. Fortunately, you can get quite a good \"feel\" with just a small subset of the Forth kernel.</p> <p>Guy Kelly [KEL92] examines the following code samples for 19 different IBM PC Forths:</p> <p>NEXT ...the \"inner interpreter\" that chains from one Forth word to another in the \"thread\". This is used at the end of every CODE definition, and is one of the most important factors in speed of Forth execution. You've already seen the pseudo-code for this in ITC and DTC; in STC it's just CALL/RETURN.</p> <p>ENTER ...also called DOCOL or DOCOLON; the Code Field action that causes a high level \"colon\" definition to be executed. This, too, is crucial for speed; it is used at the start of every colon definition. Not needed in STC.</p> <p>EXIT ...called ;S in fig-Forth; the code that ends the execution of a colon definition. This is essentially the high-level subroutine return, and appears at the end of every colon definition. This is just a machine code RETURN in STC.</p> <p>NEXT, ENTER, and EXIT indicate the performance of the threading mechanism. These should be coded to evaluate ITC vs. DTC vs. STC. They also reflect the quality of your register assignments for IP, W, and RSP.</p> <p>DOVAR ...a.k.a. \"variable\"; the machine code fragment that is the Code Field action for all Forth VARIABLEs.</p> <p>DOCON ...a.k.a. \"constant\"; the machine code fragment that is the Code Field action for all Forth CONSTANTs.</p> <p>DOCON and DOVAR, along with ENTER, show how efficiently you can obtain the Parameter Field address of a word being executed. This reflects your choice for the W register. In a DTC Forth, this also indicates whether to put a JUMP or CALL in the Code Field.</p> <p>LIT ...a.k.a. \"literal\"; is a Forth word that fetches a cell value from the high-level thread. Several words use such in-line parameters, and this is a good indicator of their performance. It reflects your choice for the IP register.</p> <p>@ ...the Forth memory-fetch operator, shows how quickly memory can be accessed from high-level Forth. This word usually benefits from TOS in stack.</p> <p>! ...the Forth memory-store operator, is another indicator of memory access. This consumes two items from the stack, and illustrates efficiency of Parameter Stack access. It's a good indicator of the TOS-in-memory vs. TOS-in-register tradeoff.</p> <p>+ ...the addition operator, is a representative example of all the Forth arithmetic and logical operators. Like the ! word, this benchmarks stack access, and it's a clear demonstration of any TOS-in-register benefit.</p> <p>This is an excellent set of code samples. I have a few additional favorites:</p> <p>DODOES ...is the Code Field action for words built with DOES&gt;. This doesn't yield any new benchmark comparisons, although it does reflect the usefulness of W, IP, and RSP. I include it because it's the most convoluted code in the Forth kernel. If you can code the logic of DODOES, everything else is a snap. The intricacies of DODOES will be described in a subsequent article.</p> <p>SWAP ...a simple stack operator, but still educational.</p> <p>OVER ...a more complex stack operator. This gives a good idea of how easily you can access the Parameter Stack.</p> <p>ROT ...a still more complex stack operator, and the one most likely to need an extra temporary register. If you can code ROT without needing an \"X\" register, you probably don't need an \"X\" register for anything.</p> <p>0= ...one of the few unary arithmetic operators, and one of the most likely to benefit from TOS-in-register.</p> <p>+! ...a most illustrative operator, combining stack access, arithmetic, memory fetch and store. This is one of my favorite benchmarks, although it is less frequently used than the other words in this list.</p> <p>These are among the most-used words in the Forth kernel. It pays to optimize them. I'll show examples of all of these, including pseudo-code, for the 6809. For the other CPUs, I'll use selected examples to illustrate specific decisions.</p>"},{"location":"Moving_Forth/moving2/#case-study-1-the-6809","title":"CASE STUDY 1: THE 6809","text":"<p>In the world of 8-bit CPUs, the 6809 is the Forth programmer's dream machine. It supports two stacks! It also has two other address registers, and a wealth of orthogonal addressing modes second only to the PDP-11. (\"Orthogonal\" means they work the same way and have the same options for all address registers.) The two 8-bit accumulators can be treated as a single 16-bit accumulator, and there are many 16-bit operations.</p> <p>The programmer's model of the 6809 is [MOT83]:</p> <p>A - 8 bit accumulator B - 8 bit accumulator</p> <p>Most arithmetic operations use an accumulator as the destination. These can be concatenated and treated as a single 16-bit accumulator D (A high byte, B low).</p> <p>X - 16 bit index register Y - 16 bit index register S - 16 bit stack pointer U - 16 bit stack pointer</p> <p>All addressing modes for X and Y can also be used with the S and U registers.</p> <p>PC - 16 bit program counter CC - 8 bit Condition Code register DP - 8 bit Direct Page register</p> <p>The 6800 family's Direct addressing mode uses an 8-bit address to reach any location in memory page zero. The 6809 allows any page to be Direct-addressed; this register provides the high 8 bits of address.</p> <p>Those two stack pointers are crying out for Forth use. They are equivalent, except that S is used for subroutine calls and interrupts. Let's be consistent and use S for return addresses, leaving U for the Parameter Stack.</p> <p>W and IP both need to be address registers, so these are the logical use for X and Y. X and Y are equivalent, so let's arbitrarily assign X=W, and Y=IP.</p> <p>Now a threading model can be chosen. I'll scratch STC and TTC, to make this a \"conventional\" Forth. The limiting factor in performance is then the NEXT routine. Let's look at this in both ITC and DTC:</p> <pre><code>ITC-NEXT: LDX ,Y++   (8) (IP)-&gt;W, increment IP\n          JMP [,X]   (6) (W)-&gt;temp, jump to adrs in temp\n\nDTC-NEXT: JMP [,Y++] (9) (IP)-&gt;temp, increment IP,\n                         jump to adrs in temp\n                         (\"temp\" is internal to the 6809)\n</code></pre> <p>NEXT is one instruction in a DTC 6809! This means you can code it in-line in two bytes, making it both smaller and faster than JMP NEXT. For comparison, look at the \"NEXT\" logic for subroutine threading:</p> <pre><code>        RTS           (5) ...at the end of one CODE word \n        JSR nextword  (8) ...in the \"thread\"\n        ...               ...start of the next CODE word\n</code></pre> <p>STC takes 13 clocks to thread to the next word, compared with 9 clocks for DTC. This is because subroutine threading has to pop and push a return address, while simple DTC or ITC threading between CODE words does not.</p> <p>Given the choice of DTC, you have to decide: does a high-level word have a Jump or Call in its Code Field? The driving consideration is how quickly can you obtain the address of the parameter field which follows? Let's look at the code to ENTER a colon definition, using symbolic Forth register names, to see this illustrated:</p> <p>using a JSR (Call):</p> <pre><code>        JSR ENTER   (8)\n        ...\nENTER:  PULS W      (7) get address following JSR into W reg\n        PSHS IP     (7) save the old IP on the Return Stack\n        TFR  W,IP   (6) Parameter Field address -&gt; IP\n        NEXT        (9) assembler macro for JMP [,Y++] \n                    37 cycles total\n</code></pre> <p>using a JMP:</p> <pre><code>        JMP ENTER   (4)\n         ...\nENTER:  PSHS IP     (7) save the old IP on the Return Stack\n        LDX -2,IP   (6) re-fetch the Code Field address\n        LEAY 3,X    (5) add 3 and put into IP (Y) register\n        NEXT        (9)\n                    31 cycles total\n\n                    (CPU cycle counts are in parentheses.)\n</code></pre> <p>The DTC 6809 NEXT doesn't use the W register, because the 6809 addressing modes allow an extra level of indirection automatically. The JMP version of ENTER has to re-fetch the Code Field address -- NEXT didn't leave it in any register -- and then add 3 to get the Parameter Field address. The JSR version can get the Parameter Field address directly by popping the return stack. Even so, the JMP version is faster. (Exercise for the student: try coding the JSR ENTER with S=PSP and U=RSP.)</p> <p>Either way, the code for EXIT is the same:</p> <pre><code>EXIT:   PULS IP     pop \"saved\" IP from return stack\n        NEXT        continue Forth interpretation\n</code></pre> <p>Some registers remain to allocate. You could keep the User Pointer in memory, and this Forth would still be pretty fast. But the DP register would go to waste, and there's not much else it can do. Let's use the \"trick\" described above, and hold the high byte of UP in the DP register. (The low byte of UP is implied to be zero.)</p> <p>One 16-bit register is left: D. Most arithmetic operations need this register. Should it be left free as a scratch register, or used as the Top-Of-Stack? 6809 instructions use memory as one operand, so a second working register may be unnecessary. And if a scratch register is needed, it's easy to push and pop D. Let's write the benchmark primitives both ways, and see which is faster.</p> <p>NEXT, ENTER, and EXIT don't use the stack, and thus have identical code either way.</p> <p>DOVAR, DOCON, LIT, and OVER require the same number of CPU cycles either way. These illustrate the earlier comment that putting TOS in register often just changes where the push or pop takes place:</p> <pre><code>        TOS in D        TOS in memory   pseudo-code\n        -------------   -------------   ---------------------\n\nDOVAR:  PSHU TOS        LDD  -2,IP      address of CF -&gt; D\n        LDD  -2,IP      ADDD #3         address of PF -&gt; D\n        ADDD #3         PSHU D          push D onto stack\n        NEXT            NEXT\n\nDOCON:  PSHU TOS        LDX  -2,IP      address of CF -&gt; W\n        LDX  -2,IP      LDD  3,X        contents of PF -&gt; D\n        LDD  3,X        PSHU D          push D onto stack\n        NEXT            NEXT\n\nLIT:    PSHU TOS        LDD  ,IP++      (IP) -&gt; D, increment IP\n        LDD  ,IP++      PSHU D          push D onto stack\n        NEXT            NEXT\n\nOVER:   PSHU D          LDD  2,PSP      2nd on stack -&gt; D\n        LDD  2,PSP      PSHU D          push D onto stack\n        NEXT            NEXT\n</code></pre> <p>SWAP, ROT, 0=, @, and especially + are all faster with TOS in register:</p> <pre><code>        TOS in D        TOS in memory   pseudo-code\n        ------------    -------------   ----------------\n\nSWAP:   LDX  ,PSP (5)   LDD  ,PSP (5)   TOS -&gt; D\n        STD  ,PSP (5)   LDX 2,PSP (6)   2nd on stack -&gt; X\n        TFR  X,D  (6)   STD 2,PSP (6)   D -&gt; 2nd on stack\n        NEXT            STX  ,PSP (5)   X -&gt; TOS\n                        NEXT\n\nROT:    LDX  ,PSP (5)   LDX  ,PSP (5)   TOS -&gt; X\n        STD  ,PSP (5)   LDD 2,PSP (6)   2nd on stack -&gt; D\n        LDD 2,PSP (6)   STX 2,PSP (6)   X -&gt; 2nd on stack\n        STX 2,PSP (6)   LDX 4,PSP (6)   3rd on stack -&gt; X\n        NEXT            STD 4,PSP (6)   D -&gt; 3rd on stack\n                        STX  ,PSP (5)   X -&gt; TOS\n                        NEXT \n\n0=:     CMPD #0         LDD  ,PSP       TOS -&gt; D\n        BEQ  TRUE       CMPD #0         does D equal zero?\n                        BEQ  TRUE\n  FALSE:LDD  #0         LDD  #0         no...put 0 in TOS\n        NEXT            STD  ,PSP\n                        NEXT\n  TRUE: LDD  #-1        LDD  #-1        yes...put -1 in TOS\n        NEXT            STD  ,PSP\n                        NEXT  \n\n@:      TFR TOS,W (6)   LDD [,PSP] (8)  fetch D using TOS adrs\n        LDD  ,W   (5)   STD  ,PSP  (5)  D -&gt; TOS\n        NEXT            NEXT\n\n+:      ADDD ,U++       PULU D          pop TOS into D\n        NEXT            ADDD ,PSP       add new TOS into D\n                        STD  ,PSP       store D into TOS\n                        NEXT\n</code></pre> <p>! and +! are slower with TOS in register:</p> <pre><code>        TOS in D        TOS in memory   pseudo-code\n        ------------    ------------    -----------------\n\n!:      TFR TOS,W (6)   PULU W   (7)    pop adrs into W\n        PULU D    (7)   PULU D   (7)    pop data into D\n        STD  ,W   (5)   STD  ,W  (5)    store data to adrs\n        PULU TOS  (7)   NEXT\n        NEXT\n\n+!:     TFR TOS,W (6)   PULU W   (7)    pop adrs into W\n        PULU TOS  (7)   PULU D   (7)    pop data into D\n        ADDD ,W   (6)   ADDD ,W  (6)    add memory into D\n        STD  ,W   (5)   STD  ,W  (5)    store D to memory\n        PULU TOS  (7)   NEXT\n        NEXT\n</code></pre> <p>The reason these words are slower is that most Forth memory-reference words expect the address on the top of stack, so an extra TFR instruction is needed. This is why it's a help for the TOS register to be an address register. Unfortunately, all the 6809 address registers are spoken for...and it's much more important for W, IP, PSP, and RSP to be in address registers than TOS. The TOS-in-register penalty for ! and +! should be outweighed by the gains in the many arithmetic and stack operations.</p>"},{"location":"Moving_Forth/moving2/#case-study-2-the-8051","title":"CASE STUDY 2: THE 8051","text":"<p>If the 6809 is the Forthwright's dream machine, the 8051 is the nightmare. It has only one general-purpose address register, and one addressing mode, which always uses the one 8-bit accumulator.</p> <p>All of the arithmetic operations, and many of the logical, must use the accumulator. The only 16-bit operation is INC DPTR. The hardware stack must use the 128-byte on-chip register file. [SIG92] Such a CPU could give ulcers.</p> <p>Some 8051 Forths have been written that implement a full 16-bit model, e.g. [PAY90], but they are too slow for my taste. Let's make some tradeoffs and make a faster 8051 Forth.</p> <p>Our foremost reality is the availability of only one address register. So let's use the 8051's Program Counter as IP -- i.e., let's make a subroutine-threaded Forth. If the compiler uses 2-byte ACALLs instead of 3-byte LCALLs whenever possible, most of the STC code will be as small as ITC or DTC code.</p> <p>Subroutine threading implies that the Return Stack Pointer is the hardware stack pointer. There are 64 cells of space in the on-chip register file, not enough room for multiple task stacks. At this point you can</p> <p>a) restrict this Forth to single-task; b) code all of the Forth definitions so that upon entry they move their return address to a software stack in external RAM; or c) do task switches by swapping the entire Return Stack to and from external RAM.</p> <p>Option (b) is slow! Moving 128 bytes on every task switch is faster than moving 2 bytes on every Forth word. For now I choose option (a), leaving the door open for (c) at some future date.</p> <p>The one-and-only \"real\" address register, DPTR, will have to do multiple duty. It becomes W, the multi-purpose working register.</p> <p>In truth, there are two other registers that can address external memory: R0 and R1. They provide only an 8-bit address; the high 8 bits are explicitly output on port 2. But this is a tolerable restriction for stacks, since they can be limited to a 256-byte space. So let's use R0 as the PSP.</p> <p>This same 256-byte space can be used for user data. This makes P2 (port 2) the high byte of the User Pointer, and, like the 6809, the low byte will be implied to be zero.</p> <p>What is the programmer's model of the 8051 so far?</p> <pre><code>    reg 8051   Forth\n   adrs name   usage\n   ---- ------ -----------------\n\n      0  R0    low byte of PSP\n      1  R1\n      2  R2\n      3  R3\n      4  R4\n      5  R5\n      6  R6\n      7  R7 \n  8-7Fh        120 bytes of return stack\n    81h  SP    low byte of RSP (high byte=00)\n 82-83h  DPTR  W register\n    A0h  P2    high byte of UP and PSP\n    E0h  A\n    F0h  B\n</code></pre> <p>Note that this uses only register bank 0. The additional three register banks from 08h to 1Fh, and the bit-addressable region from 20h to 2Fh, are of no use to Forth. Using bank 0 leaves the largest contiguous space for the return stack. Later the return stack can be shrunk, if desired.</p> <p>The NEXT, ENTER, and EXIT routines aren't needed in a subroutine threaded Forth.</p> <p>What about the top of stack? There are plenty of registers, and memory operations on the 8051 are expensive. Let's put TOS in R3:R2 (with R3 as the high byte, in Intel fashion). Note that B:A can't be used -- the A register is the funnel through which all memory references must move!</p>"},{"location":"Moving_Forth/moving2/#harvard-architectures","title":"Harvard architectures","text":"<p>The 8051 uses a \"Harvard\" architecture: program and data are kept in separate memories. (The Z8 and TMS320 are two other examples) The 8051 is a degenerate case: there is physically no means to write to the program memory! This means that a Forthwright can do one of two things:</p> <p>a) cross-compile everything, including the application, and give up all hope of putting an interactive Forth compiler on the 8051; or</p> <p>b) cause some or all of the program memory to also appear in the data space. The easiest way is to make the two spaces completely overlap, by logically ORing the active-low PSEN* and RD* strobes with an external AND gate.</p> <p>The Z8 and TMS320C25 are more civilized: they allow write access to program memory. The implications for the design of the Forth kernel will be discussed in subsequent articles.</p>"},{"location":"Moving_Forth/moving2/#case-study-3-the-z80","title":"CASE STUDY 3: THE Z80","text":"<p>The Z80 is instructive because it is an extreme example of a non-orthogonal CPU. It has four different kinds of address registers! Some operations use A as destination, some any 8-bit register, some HL, some any 16-bit register, and so on. Many operations (such as EX DE,HL) are only defined for one combination of registers.</p> <p>In a CPU such as the Z80 (or 8086!), the assignment of Forth functions must be carefully matched to the capabilities of the CPU registers. Many more tradeoffs need to be evaluated, and often the only way is to write sample code for a number of different assignments. Rather than burden this article down endless permutations of Forth code, I'll present one register assignment based on many Z80 code experiments. It turns out that these choices can be rationalized in terms of the general principles outlined earlier.</p> <p>I want a \"conventional\" Forth, although I will use direct threading. All of the \"classical\" virtual registers will be needed.</p> <p>Ignoring the alternate register set, the Z80 has six address registers, with the following capabilities:</p> <pre><code>BC,DE - LD A indirect, INC, DEC\n        also exchange DE/HL\n\n    HL - LD r indirect, ALU indirect, INC, DEC, ADD, ADC, \n        SBC, exchange w/TOS, JP indirect\n\nIX,IY - LD r indexed, ALU indexed, INC, DEC, ADD, ADC,\n        SBC, exchange w/TOS, JP indirect  (all slow)\n\n    SP - PUSH/POP 16-bit, ADD/ADC/SUB to HL/IX/IY\n</code></pre> <p>BC, DE, and HL can also be manipulated in 8-bit pieces.</p> <p>The 8-bit register A must be left as a scratch register, since it's the destination for so many ALU and memory reference operations.</p> <p>HL is undoubtedly the most versatile register, and at one time or another it is tempting to use it for each of the Forth virtual registers. However, because of its versatility -- and because it is the only register which can be fetched byte-wise and used in an indirect jump -- HL should be used for W, Forth's all-purpose working register.</p> <p>IX and IY might be considered for the Forth stack pointers, because of their indexed addressing mode, which can be used in ALU operations. But there are two problems with this: it leaves SP without a job; and, IX/IY are too slow! Most of the operations on either stack involve pushing or popping 16-bit quantities. This is one instruction using SP, but it requires four using IX or IY. One of the Forth stacks should use SP. And this should be the Parameter Stack, since it is used more heavily than the Return Stack.</p> <p>What about Forth's IP? Mostly, IP fetches from memory and autoincrements, so there's no programming advantage to using IX/IY over BC/DE. But speed is of the essence with IP, and BC/DE are faster. Let's put IP in DE: it has the advantage of being able to swap with HL, which adds versatility.</p> <p>A second Z80 register pair (other than W) will be needed for 16-bit arithmetic. Only BC is left, and it can be used for addressing or for ALU operations with A. But should BC be a second working register \"X\", or the top-of-stack? Only code will tell; for now, let's optimistically assume that BC=TOS.</p> <p>This leaves the RSP and UP functions, and the IX and IY registers unused. IX and IY are equivalent, so let's assign IX=RSP, and IY=UP.</p> <p>Thus the Z80 Forth register assignments are:</p> <pre><code>BC = TOS   IX = RSP\nDE = IP    IY = UP\nHL = W     SP = PSP\n</code></pre> <p>Now look at NEXT for the DTC Forth:</p> <pre><code>DTC-NEXT: LD A,(DE) (7) (IP)-&gt;W, increment IP\n          LD L,A    (4)\n          INC DE    (6)\n          LD A,(DE) (7)\n          LD H,A    (4)\n          INC DE    (6)\n          JP (HL)   (4) jump to address in W\n</code></pre> <p>alternate version (same number of clock cycles)</p> <pre><code>DTC-NEXT: EX DE,HL  (4) (IP)-&gt;W, increment IP\nNEXT-HL:  LD E,(HL) (7)\n          INC HL    (6)\n          LD D,(HL) (7)\n          INC HL    (6)\n          EX DE,HL  (4)\n          JP (HL)   (4) jump to address in W\n</code></pre> <p>Note that cells are stored low-byte first in memory. Also, although it might seem advantageous to keep IP in HL, it really isn't. This is because the Z80 can't JP (DE). The NEXT-HL entry point will be used shortly.</p> <p>Just for comparison, let's look at an ITC NEXT. The pseudo-code given previously requires another temporary register \"X\", whose contents can be used for an indirect jump. Let DE=X, and BC=IP. TOS will have to be kept in memory.</p> <pre><code>ITC-NEXT: LD A,(BC) (7) (IP)-&gt;W, increment IP\n          LD L,A    (4)\n          INC BC    (6)\n          LD A,(BC) (7)\n          LD H,A    (4)\n          INC BC    (6)\n\n          LD E,(HL) (7) (W)-&gt;X\n          INC HL    (6)\n          LD D,(HL) (7)\n          EX DE,HL  (4) jump to address in X\n          JP (HL)   (4)  \n</code></pre> <p>This leaves \"W\" incremented by one, and in the DE register. As long as this is done consistently, there's no problem -- code needing the contents of W knows where to find it, and how much to adjust it.</p> <p>The ITC NEXT is 11 instructions, as compared to 7 for DTC. And ITC on the Z80 loses the ability to keep TOS in a register. My choice is DTC.</p> <p>If coded in-line, DTC NEXT would require seven bytes in every CODE word. A jump to a common NEXT routine would only use three bytes, but would add 10 clock cycles. This is another of the tradeoff decisions in designing a Forth kernel. This example is a close call; let's opt for speed with an in-line NEXT. But sometimes NEXT is so huge, or memory is so tight, that the prudent decision is to use a JMP NEXT.</p> <p>Now let's look at the code for ENTER. Using a CALL, the hardware stack is popped to get the Parameter Field address:</p> <pre><code>        CALL ENTER  (17)\n        ...\nENTER:  DEC IX      (10) push the old IP on the return stack\n        LD (IX+0),D (19)\n        DEC IX      (10)\n        LD (IX+0),E (19)\n        POP DE      (10) Parameter Field address -&gt; IP\n        NEXT        (38) assembler macro for 7 instructions\n</code></pre> <p>Actually it's faster to POP HL, and then use the last six instructions of NEXT (omitting the EX DE,HL):</p> <pre><code>        CALL ENTER  (17)\n        ...\nENTER:  DEC IX      (10) push the old IP on the return stack\n        LD (IX+0),D (19)\n        DEC IX      (10)\n        LD (IX+0),E (19)\n        POP HL      (10) Parameter Field address -&gt; HL\n        NEXT-HL     (34) see DTC NEXT code, above\n                    119 cycles total\n</code></pre> <p>When a JP is used, the W register (HL) is left pointing to the Code Field. The Parameter Field is 3 bytes after:</p> <pre><code>        JP ENTER    (10)\n        ...\nENTER:  DEC IX      (10) push the old IP on the return stack\n        LD (IX+0),D (19)\n        DEC IX      (10)\n        LD (IX+0),E (19)\n        INC HL      ( 6) Parameter Field address -&gt; IP\n        INC HL      ( 6)\n        INC HL      ( 6) \n        NEXT-HL     (34)\n                    120 cycles total\n</code></pre> <p>Again, because of the alternate entry point for NEXT, the new value for IP doesn't actually have to be put into the DE register pair.</p> <p>The CALL version is one cycle faster. On an embedded Z80, a one-byte RST instruction could be used to gain speed and save space. This option is not available on many Z80-based personal computers.</p>"},{"location":"Moving_Forth/moving2/#case-study-4-the-8086","title":"CASE STUDY 4: THE 8086","text":"<p>The 8086 is another instructive CPU. Rather than go through the design process, let's look at one of the newer shareware Forths for the IBM PC: Pygmy Forth [SER90].</p> <p>Pygmy is a direct-threaded Forth with the top-of-stack kept in register. The 8086 register assignments are:</p> <pre><code>AX = W         DI = scratch\nBX = TOS       SI = IP\nCX = scratch   BP = RSP\nDX = scratch   SP = PSP\n</code></pre> <p>Most 8086 Forths use the SI register for IP, so that NEXT can be written with the LODSW instruction. In Pygmy the DTC NEXT is:</p> <pre><code>NEXT:  LODSW\n       JMP AX\n</code></pre> <p>This is short enough to include in-line in every CODE word.</p> <p>High-level and \"defined\" Forth words use a JMP (relative) to their machine code. The ENTER routine (called 'docol' in Pygmy) must therefore get the Parameter Field address from W:</p> <pre><code>ENTER:  XCHG SP,BP\n        PUSH SI\n        XCHG SP,BP\n        ADD AX,3    Parameter Field address -&gt; IP\n        MOV SI,AX\n        NEXT\n</code></pre> <p>Note the use of XCHG to swap the two stack pointers. This allows the use of PUSH and POP instructions for both stacks, which is faster than using indirect access on BP.</p> <pre><code>EXIT:   XCHG SP,BP\n        POP SI\n        XCHG SP,BP\n        NEXT \n</code></pre>"},{"location":"Moving_Forth/moving2/#segment-model","title":"Segment model","text":"<p>Pygmy Forth is a single-segment Forth; all code and data are contained within a single 64 kByte segment. (This is the \"tiny model\" in Turbo C lingo) All of the Forth standards issued to date assume that everything is contained in a single memory space, accessible with the same fetch and store operators.</p> <p>Nevertheless, IBM PC Forths are beginning to appear that use multiple segments for up to five different kinds of data [KEL92,SEY89]. These are:</p> <p>CODE ...machine code LIST ...high-level Forth threads (a.k.a. THREADS) HEAD ...headers of all Forth words STACK ...parameter and return stacks DATA ...variables and user-defined data</p> <p>This allows PC Forths to break the 64K limit, without going to the expense of implementing a 32-bit Forth on a 16-bit CPU. Implementation of a multi-segment model, and the ramifications for the Forth kernel, are beyond the scope of this article.</p>"},{"location":"Moving_Forth/moving2/#still-to-come","title":"STILL TO COME...","text":"<p>Subsequent articles will look at:</p> <ul> <li>design tradeoffs in the Forth header and dictionary search</li> <li>the logic of CONSTANTs, VARIABLEs, and other data structures</li> <li>the defining word mechanisms, CREATE...;CODE and CREATE...DOES&gt;</li> <li>the assembler vs. metacompiler question</li> <li>the assembler and high-level code that comprises a Forth kernel</li> <li>multitasking modifications to the kernel</li> </ul>"},{"location":"Moving_Forth/moving2/#references","title":"REFERENCES","text":"<p>[KEL92] Kelly, Guy M., \"Forth Systems Comparisons,\" Forth Dimensions XIII:6 (Mar/Apr 1992) [1] [2]. Also published in the 1991 FORML Conference Proceedings. Both available from the Forth Interest Group, P.O. Box 2154, Oakland, CA 94621. Illustrates design tradeoffs of many 8086 Forths with code fragments and benchmarks -- highly recommended!</p> <p>[MOT83] Motorola Inc., 8-Bit Microprocessor and Peripheral Data, Motorola data book (1983). [1]</p> <p>[SIG92] Signetics Inc., 80C51-Based 8-Bit Microcontrollers, Signetics data book (1992). [1]</p>"},{"location":"Moving_Forth/moving2/#forth-implementations","title":"Forth Implementations","text":"<p>[PAY90] Payne, William H., Embedded Controller FORTH for the 8051 Family, Academic Press (1990), ISBN 0-12-547570-5. This is a complete \"kit\" for a 8051 Forth, including a metacompiler for the IBM PC. Hardcopy only; files can be downloaded from GEnie. Not for the novice! [1]</p> <p>[SER90] Sergeant, Frank, Pygmy Forth for the IBM PC, version 1.3 (1990). Distributed by the author, available from the Forth Interest Group. Version 1.4 is now available on GEnie, and worth the extra effort to obtain. [1]</p> <p>[SEY89] Seywerd, H., Elehew, W. R., and Caven, P., LOVE-83Forth for the IBM PC, version 1.20 (1989). A shareware Forth using a five-segment model. Contact Seywerd Associates, 265 Scarboro Cres., Scarborough, Ontario M1M 2J7 Canada.</p> <p>Author's note for web publication: the files formerly available on the GEnie online service are now available from the Forth Interest Group FTP server, <code>ftp://ftp.forth.org/pub/Forth</code>.</p>"},{"location":"Moving_Forth/moving3/","title":"MOVING FORTH 3","text":"<p>Part 3: Demystifying DOES&gt; \\ by Brad Rodriguez</p> <p>This article first appeared in The Computer Journal #62 (July/August 1993).</p>"},{"location":"Moving_Forth/moving3/#oops","title":"OOPS!","text":"<p>There's a colossal mistake in one of my 6809 design decisions in the previous installment. It became evident when I started to code the Forth word EXECUTE.</p> <p>EXECUTE causes the execution of a single Forth word, whose address is given on the Parameter Stack. (To be precise: the compilation address, a.k.a. Code Field Address, is given on the stack.) This can be any kind of Forth word: CODE definition, colon definition, CONSTANT, VARIABLE, or defined word. This differs from the usual Forth interpretation process in that the address of the word-to-execute is given on the stack, and not taken from the \"thread\" (as pointed to by IP).</p> <p>In our direct-threaded 6809 code this can be easily coded:</p> <pre><code>EXECUTE:  TFR  TOS,W      put address of word in W\n          PULU TOS        pop new TOS\n          JMP  ,W         jump to address given in W\n</code></pre> <p>Note: this is JMP ,W and not JMP [,W], since we already have the code address of the word. We're not fetching from the high-level thread. (If TOS wasn't in register, EXECUTE could be done with simply JMP [,PSP++].) Now suppose that this EXECUTEd word is a colon definition. W will be pointing to its Code Field, which contains JMP ENTER. This does the following (described in the previous article):</p> <pre><code>          JMP ENTER\n          ...\nENTER:    PSHS IP\n          LDX  -2,IP      re-fetch the Code Field address\n          LEAY 3,X\n          NEXT\n</code></pre> <p>This is the mistake! We are not executing this word from within a thread, so IP was not pointing to a copy of its Code Field address! (Remember, the address of the word-to-EXECUTE came from the stack.) This form of ENTER will not work with EXECUTE, because there is no way to find the address of the word being executed!</p> <p>This suggests a new general rule for DTC Forths: if NEXT does NOT leave the address of the word-being-executed in a register, you MUST use a Call in the code field.</p> <p>So, the 6809 Forth is back to using a JSR in the Code Field. But to avoid the speed penalty for ENTER -- one of the most-used code fragments in Forth -- I'll complete the \"exercise for the student\" from the last article. Note what happens if you swap the registers assigned to RSP and PSP:</p> <pre><code>          with RSP=S,  with RSP=U,\n          and PSP=U   and PSP=S\n          (previous)  (new)\n\n          JSR ENTER   JSR ENTER\n          ...         ...\nENTER:    PULS W      PSHU IP     push old IP onto R stack\n          PSHS IP     PULS IP     pop new IP from JSR stack\n          TFR  W,IP   NEXT\n          NEXT\n</code></pre> <p>The new version executes in 31 cycles, the same as the JMP version I had wanted to use. The improvement is because the JSR version of ENTER must use both Forth's Return Stack, and the 6809 subroutine-return stack (\"JSR stack\"). Using two different stack pointers means we don't have to \"swap\" the top-of-stack with IP, eliminating the need for a temporary register.</p> <p>This illustrates the usual development process for a new Forth kernel: make some design decisions, write some sample code, discover a bug or a better way to do things, throw out some code, change some design decisions, rewrite some sample code, loop until satisfied. (This is the programming equivalent of a \"rip up\" PC board autorouter.)</p> <p>This teaches an important lesson: make EXECUTE one of your benchmark words!</p>"},{"location":"Moving_Forth/moving3/#oops-again","title":"OOPS, AGAIN","text":"<p>Carey Bloodworth of Van Buren, AR has pointed out a minor but embarrassing mistake in my 6809 code in the previous installment. For the \"TOS-in-memory\" version of 0=, I showed the code fragment</p> <pre><code>          LDD ,PSP\n          CMPD #0\n</code></pre> <p>to test for top-of-stack equaling zero. In this case, the CMPD instruction is completely superfluous, since the LDD instruction will set the Zero flag if D is zero! (The TOS-in-D version still requires the CMPD instruction, but remains faster than TOS-in-memory.)</p> <p>Now, on to our main topic:</p>"},{"location":"Moving_Forth/moving3/#whats-a-code-field","title":"WHAT'S A CODE FIELD?","text":"<p>The DOES&gt; concept seems to be one of the most misunderstood and mystifying aspects of Forth. Yet DOES&gt; is also one of Forth's most powerful features -- in many ways, it anticipated object-oriented programming. The action and power of DOES&gt; hinges upon a brilliant innovation of Forth: the Code Field.</p> <p>Recall from Part 1 that the \"body\" of a Forth definition consists of two parts: the Code Field, and the Parameter Field. You can think of these two fields in several ways:</p> <ul> <li> <p>The Code Field is the \"action\" taken by this Forth word, and the Parameter Field is the data on which it acts.</p> </li> <li> <p>The Code Field is a subroutine call, and the Parameter Field is parameters that are included \"in-line\" after the call. (The assembly language programmer's view.)</p> </li> <li> <p>The Code Field is the single \"method\" for this \"class\" of words, and the Parameter Field contains the \"instance variables\" for this particular word. (The object-oriented programmer's view.)</p> </li> </ul> <p>Common features appear in all these views:</p> <ul> <li> <p>The Code Field routine is always called with at least one argument, namely, the address of the Parameter Field for the Forth word being executed. The Parameter Field may contain any number of parameters.</p> </li> <li> <p>There are relatively few distinct actions, i.e., relatively few distinct routines referenced by the Code Field. Each of these routines is widely shared (except for CODE words, as we will see later). Recall, for example, the ENTER routine from Part 2: this common routine is used by all Forth colon definitions.</p> </li> <li> <p>The interpretation of the Parameter Field is implicitly determined by the contents of the Code Field. I.e., each Code Field routine expects the Parameter Field to contain a certain kind of data.</p> </li> </ul> <p>A typical Forth kernel will have several Code Field routines predefined.</p> Code Fieldroutine Parameter Fieldcontents ENTER a high-level \"thread\" (series of addresses) DOCON a constant value DOVAR a storage location for data DOVOC vocabulary info (varies by implementation) <p>What makes this feature powerful is that a Forth program is not limited to this set of Code Field routines (or whatever set is provided in your kernel). The programmer can define new Code Field routines, and new Parameter Fields to match. In object-oriented lingo, new \"classes\" and \"methods\" can be created (although each class has only one method). And -- like Forth words themselves -- the Code Field actions can be defined in either assembly language or high-level Forth!</p> <p>To understand the mechanism of the Code Field, and how parameters are passed, we will first look at the case of assembly-language (machine code) actions. We'll start with Indirect Threading (ITC), since it is the easiest to understand, and then see how the logic is modified in Direct-Threaded (DTC) and Subroutine-Threaded (STC) Forths. Then, we'll look at how the Code Field action can be written in high-level Forth.</p> <p>Forthwrights are somewhat inconsistent in their terminology, so I'll define my terms, using the ITC Forth word illustrated in Figure 1. The Header contains the dictionary information, and isn't involved in the execution of the Forth word. The Body is the \"working\" part of the word, and consists of the fixed-length Code Field, and the variable-length Parameter Field. For any given word, the locations of these two fields in memory are the Code Field Address (CFA) and the Parameter Field Address (PFA), respectively. The Code Field Address of a word is the address in memory where its Code Field is located. This is not to be confused with the contents of the Code Field, which, in ITC Forths, is another different address. To be specific, the contents of the Code Field is the address of a fragment of machine code somewhere else in memory. I will refer to this as the Code Address. Later, when in discussing DTC and STC Forths, I will also refer to the \"Code Field contents,\" which will include more than just the Code Address.</p> <p> Figure 1. An ITC Forth word</p> <p></p>"},{"location":"Moving_Forth/moving3/#machine-code-actions","title":"MACHINE-CODE ACTIONS","text":"<p>Forth CONSTANTs are probably the simplest example of a machine-code action. Let's consider some good Francophone constants</p> <pre><code>1 CONSTANT UN\n2 CONSTANT DEUX\n3 CONSTANT TROIS\n</code></pre> <p>Executing the word UN will push the value 1 onto the Forth Parameter Stack. Executing DEUX will push a 2 onto the stack, and so on. (Don't confuse Parameter Stack with Parameter Field; they are entirely separate.)</p> <p>In the Forth kernel there is a single word called CONSTANT. This is not a constant-type word itself; it is a high-level Forth definition. CONSTANT is a \"defining word\": it creates new words in the Forth dictionary. Here we create the new \"constant-type\" words UN, DEUX, and TROIS. (You may think of these as \"instances\" of the \"class\" CONSTANT.) These three words will have their Code Fields pointing to a machine code fragment that does the action of CONSTANT.</p> <p>What must this code fragment do? Figure 2 shows the memory representation of the three constants. All three words point to a common action routine. The difference in the words is entirely contained in their Parameter Fields, which, in this case, simply hold the constant values (\"instance variables\" in object lingo). So, the action of these three words should be fetch the contents of the Parameter Field, and push this onto the stack. The code understands implicitly that the parameter field contains a single-cell value.</p> <p></p> <p>Figure 2. Three constants</p> <p></p> <p>To write a machine-code fragment to do this, we need to know how to find the Parameter Field Address, after the Forth interpreter jumps to the machine code. That is, how is the PFA passed to the machine-code routine? This, in turn, depends on how the Forth interpreter NEXT has been coded, which varies from implementation to implementation. To write machine-code actions, we must understand NEXT.</p> <p>The ITC NEXT was described in pseudo-code in Part 1. Here's one implementation for the 6809, using Y=IP and X=W:</p> <pre><code>NEXT:   LDX ,Y++    ; (IP) -&gt; W, and IP+2 -&gt; IP\n        JMP [,X]    ; (W) -&gt; temp, JMP (temp)\n</code></pre> <p>Suppose that we're in a high-level thread</p> <pre><code>... SWAP DEUX + ...\n</code></pre> <p>with the Interpreter Pointer (IP) pointing to the DEUX \"instruction,\" when NEXT is executed. (This would be at the very end of SWAP.) Figure 3 illustrates what happens. IP (register Y) is pointing within the high-level thread, at a memory cell that contains the address of the Forth word DEUX. To be precise, this cell contains the Code Field Address of DEUX. So, when we fetch a cell using Y, and auto increment Y, we fetch the Code Field Address of DEUX. This goes into W (register X), so W is now pointing to the Code Field. The contents of this field is the address of some machine code. We can fetch the contents of this cell and jump to the machine code with a single 6809 instruction. This leaves register X unchanged, so W is still pointing to the CFA of DEUX. This is how the Parameter Field Address is obtained, since, in this case, it is simply two bytes past the Code Field.</p> <p> Figure 3. ITC Before and After</p> <p></p> <p>So, the machine code fragment has only to add 2 to W, fetch the cell value at that address, and push that on the stack. This fragment is frequently called DOCON:</p> <pre><code>DOCON:  LDD 2,X  ; fetch the cell at W+2\n        PSHU D   ; push that on the Parameter Stack\n        NEXT     ; (macro) do the next high-level word\n</code></pre> <p>(For this example, TOS is kept in memory.) Note that the previous NEXT incremented IP by 2, so it is already pointing to the next cell in the thread (\"CFA of +\") when DOCON does NEXT.</p> <p>In general, ITC Forths leave the Parameter Field Address or some \"nearby\" address in the W register. In this case, W contained the CFA, which in this Forth implementation is always PFA-2. Since every class of Forth word except CODE words needs to use the Parameter Field Address, many implementations of NEXT will increment W to leave it pointing to the PFA. We can do this on the 6809 with one small change:</p> <pre><code>NEXT:   LDX ,Y++     ; (IP) -&gt; W, and IP+2 -&gt; IP\n        JMP [,X++]   ; (W) -&gt; temp, JMP (temp), W+2 -&gt; W\n</code></pre> <p>This adds three clock cycles to NEXT, and leaves the Parameter Field Address in W. What does it do to the Code Field routines?</p>   W=CFA  W=PFA  <pre>\nDOCON:  LDD 2,X (6)              \n        PSHU D                   \n        NEXT\nDOVAR:  LEAX 2,X (5)             \n        PSHU X                   \n        NEXT\nENTER:  PSHS Y                   \n        LEAY 2,X (5)             \n        NEXT                     \n</pre><pre>\nLDD ,X (5)                       \nPSHU D                           \nNEXT\n; no operation                   \nPSHU X                           \nNEXT\nPSHS Y                           \nLEAY ,X  (4, faster than TFR X,Y)\nNEXT                             \n</pre> <p>In exchange for a three-cycle penalty in NEXT, the DOCON code is reduced by one clock cycle, DOVAR by five cycles, and ENTER by one cycle. CODE words don't use the value in W, so they gain nothing from the auto increment. The speed gained or lost is determined by the mix of Forth words executed. The usual rule is that most of the words executed are CODE words, thus, incrementing W in NEXT costs a bit of speed overall. (There is a memory savings, but DOCON, DOVAR, and ENTER appear only once, making this gain slight.)</p> <p>The best decision, of course, depends upon the processor. On machines like the Z80, which only access memory by bytes and don't have auto increment address modes, it is often best to leave W pointing to IP+1 (the last byte fetched from the Code Field). On other machines, auto incrementing is \"free,\" and leaving W pointing to the Parameter Field is most convenient.</p> <p>Remember: the decision must be made consistently. If NEXT leaves W pointing to the PFA of the word being executed, then EXECUTE must do likewise! (This was the 'oops' that I corrected at the start of this article.)</p>"},{"location":"Moving_Forth/moving3/#direct-threading","title":"Direct Threading","text":"<p>Direct Threading works just like Indirect Threading, except that instead of the Code Field containing the address of some machine code, it contains a JUMP or CALL to some machine code. This makes the Code Field larger -- e.g., 1 byte larger in the 6809 -- but removes one level of indirection from the NEXT routine.</p> <p>The choice of a JUMP or a CALL instruction in the Code Field hinges upon how the Parameter Field Address can be obtained by the machine code routine. In order to jump to the Code Field, many CPUs require that its address be in a register. For instance, the indirect jump on the 8086 is JMP AX (or some other register), and on the Z80 is JP (HL) (or IX or IY). On these processors, the DTC NEXT involves two operations, which on the 6809 would be:</p> <pre><code>NEXT:   LDX ,Y++    ; (IP) -&gt; W, and IP+2 -&gt; IP\n        JMP ,X      ; JMP (W)\n</code></pre> <p>(On the 8086, this can be done with LODSW, JMP AX.) The effect of this is illustrated in Figure 4 as \"case 1\". The Code Field Address of DEUX is fetched from the high-level thread, and IP is incremented. Then, instead of a fetch, a JUMP is made to the Code Field Address (i.e., the CPU jumps directly to the Code Field). The CFA is left in the W register, just like the first ITC example above. Since this address is already in a register, we can simply put a JUMP to DOCON in the Code Field, and the DOCON fragment will work the same as before.</p> <p> Figure 4. DTC Before and After</p> <p></p> <p>However, some processors -- such as the 6809 and PDP-11 -- can do this DTC NEXT in one instruction:</p> <pre><code>NEXT:  JMP [,Y++]   ; (IP) -&gt; temp, IP+2 -&gt; IP, JMP (temp)\n</code></pre> <p>This, too, will cause the CPU to jump to the Code Field of DEUX. But there's one big difference: the CFA is not left in any register! So how is the machine code fragment to find the Parameter Field Address? By putting a CALL (JSR) in the Code Field instead of a JUMP. On most CPUs, the CALL instruction will push the return address -- the address immediately following the CALL instruction -- onto the Return Stack. As Figure 4 illustrates (\"case 2\"), this return address is exactly the Parameter Field Address we want! So, all DOCON has to do is pop the Return Stack -- balancing the JSR in the Code Field -- and then use that address to fetch the constant value. Thus:</p> <pre><code>DOCON:  PULS X   ; pop the PFA from the Return Stack\n        LDD ,X   ; fetch the Parameter Field cell\n        PSHU D   ; push that on the Parameter Stack\n        NEXT     ; (macro) do the next high-level word\n</code></pre> <p>Compare this with the ITC version. One instruction has been added to DOCON, but one instruction has been deleted from NEXT. DOVAR and NEXT likewise become one instruction longer:</p> <pre><code>DOVAR:  PULS X   ; pop the PFA of the word\n        PSHU X   ; push that address on the Parameter Stack\n        NEXT\n\nENTER:  PULS X   ; pop the PFA of the word\n        PSHS Y   ; push the old IP\n        TFR X,Y  ; the PFA becomes the new IP\n        NEXT\n</code></pre> <p>Now go back to the beginning of this article, and reread my \"oops,\" to see why we can't just re-fetch the CFA by using the IP. Also note the difference when the assignment of Forth's stack pointers to the 6809's U and S is reversed.</p>"},{"location":"Moving_Forth/moving3/#subroutine-threading","title":"Subroutine Threading","text":"<p>Subroutine Threading (STC) is like DTC in that the CPU jumps directly to the Code Field of a Forth word. Only now there is no NEXT code, no IP register, and no W register. So, there is no choice but to use a JSR in the Code Field, since this is the only way to obtain the Parameter Field Address. This process is illustrated in Figure 5.</p> <p> Figure 5. Subroutine Threaded Code</p> <p></p> <p>The high-level \"thread\" is a series of subroutine calls being executed by the CPU. When the JSR DEUX is executed, the address of the next instruction in the thread is pushed onto the Return Stack. Then, the JSR DOCON within the word DEUX is executed, which causes another return address -- the PFA of DEUX -- to be pushed onto the Return Stack. DOCON can pop that address, use it to fetch the constant, stack the constant, and then do an RTS to return to the thread:</p> <pre><code>DOCON:  PULS X  ; pop the PFA from the Return Stack\n        LDD ,X  ; fetch the Parameter Field cell\n        PSHU D  ; push that on the Parameter Stack\n        RTS     ; do the next high-level word\n</code></pre> <p>We can still speak of a Code Field and a Parameter Field in Subroutine-Threaded Code. In every \"class\" of Forth word except CODE and colon definitions, the Code Field is the space occupied by a JSR or CALL instruction (just like DTC), and the Parameter Field is what follows. So, on the 6809, the PFA would equal CFA+3. The meaning of \"Parameter Field\" becomes somewhat fuzzy in CODE and colon definitions, as will be seen in future articles.</p>"},{"location":"Moving_Forth/moving3/#the-special-case-code-words","title":"THE SPECIAL CASE: CODE WORDS","text":"<p>There is a significant exception to all of the above generalizations. This is CODE definitions -- Forth words that are defined as a machine code subroutine. This wonderful capability is trivially easy to implement in Forth, since every Forth word executes some piece of machine code!</p> <p>The machine code comprising a CODE word is always contained in the body of the Forth word. In an Indirect-Threaded Forth, the Code Field must contain the address of the machine code to be executed. So the machine code is placed in the Parameter Field, and the Code Field contains the address of the Parameter Field, as shown in Figure 6.</p> <p> Figure 6. Code Words</p> <p></p> <p>In Direct- and Subroutine-Threaded Forths, we could -- by analogy -- put, in the Code Field, a JUMP to the Parameter Field. But this would be pointless, since the Parameter Field immediately follows the Code Field! The Code Field could be filled with NOPs for the same result. Better still, the machine code could be started at the Code Field, and continued into the Parameter Field. At this point the distinction of \"Code Field\" and \"Parameter Field\" breaks down. This is no problem, because we don't need this distinction for CODE words. (This does have ramifications for decompilers and certain clever programming tricks, none of which concern us here.)</p> <p>CODE words -- whatever the implementation -- are the one case where the machine code \"action\" routine does not need to be passed the Parameter Field address. The Parameter Field contains, not data, but the code being executed! Only NEXT needs to know this address (or the Code Field Address), so it can jump to the machine code.</p>"},{"location":"Moving_Forth/moving3/#using-code","title":"USING ;CODE","text":"<p>Three questions remain unanswered:</p> <p>a. how do we create a new Forth word that has some arbitrary data in its Parameter Field?</p> <p>b. how do we change the Code Field of that word, to point to some machine code of our choosing?</p> <p>c. how do we compile (assemble) this machine code fragment, which exists in isolation from the words using it?</p> <p>The answer to (a) is: we write a Forth word to do this. Since this word, when executed, will define (create) a new word in the Forth dictionary, it is called a \"defining word.\" CONSTANT is one example of a defining word. All of the \"hard work\" of a defining word is done by a kernel word, CREATE, which parses a name from the input stream, builds the header and Code Field for a new word, and links it into the dictionary. (In fig-Forth this word is called \\&lt;BUILDS.) All that remains for the programmer is to build the Parameter Field.</p> <p>The answer to (b) and (c) is embodied in two convoluted words called (;CODE) and ;CODE respectively. To understand how they work, let's look at how the defining word CONSTANT is actually written in Forth. Using the original ITC 6809 example:</p> <pre><code>: CONSTANT ( n -- )\n    CREATE      \\ create the new word\n    ,           \\ append the TOS value to the dictionary,\n                \\   as the 1st cell of the Parameter Field\n    ;CODE       \\ end high-level &amp; start assembler code\n    LDD 2,X     \\ the code fragment DOCON\n    PSHU D      \\  \"   \"      \"       \"\n    NEXT        \\  \"   \"      \"       \"\nEND-CODE\n</code></pre> <p>There are two parts to this Forth word. Everything from :\u00a0CONSTANT to ;CODE is the high-level Forth code executed when the word CONSTANT is invoked. Everything from ;CODE to END-CODE is machine code executed when the \"children\" of CONSTANT -- the \"constant-class\" words such as UN and DEUX -- are executed. That is, everything from ;CODE to END-CODE is the code fragment to which constant-type words will point. The name ;CODE signifies that it ends a high-level definition (\";\") and begins a machine- code definition (\"CODE\"). However, this is not put into the dictionary as two separate words. Everything from : CONSTANT to END-CODE is contained in the Parameter Field of CONSTANT, as shown in Figure 7.</p> <p> Figure 7. ITC ;CODE</p> <p></p> <p>Derick and Baker [DER82] name three \"sequences\" that help to understand the action of defining words:</p> <p>Sequence 1 is when the word CONSTANT is being defined. This involves both the high-level compiler (for the first part) and the Forth assembler (for the second part). This is when the definition of CONSTANT shown in Figure 7 is added to the dictionary. As we will see shortly, ;CODE -- a compiler directive -- is executed during Sequence 1.</p> <p>Sequence 2 is when the word CONSTANT is being executed, and when some constant-type word is being defined. In the example</p> <pre><code>2 CONSTANT DEUX\n</code></pre> <p>Sequence 2 is when the word CONSTANT executes, and the word DEUX is added to the dictionary (as shown in Figure 7). During Sequence 2, the high-level part of CONSTANT is executed, including the word (;CODE).</p> <p>Sequence 3 is when the constant-type word is executed. In our example, Sequence 3 is when DEUX is executed to push the value 2 onto the stack. This is when the machine-code part of CONSTANT is executed. (Recall that this fragment is the Code Field action of DEUX.)</p> <p>The words ;CODE and (;CODE) do the following:</p> <p>;CODE is executed during Sequence 1, when CONSTANT is compiled. This is an example of a Forth IMMEDIATE word -- a word executed during the Forth compilation. ;CODE does three things:</p> <p>a. it compiles the Forth word (;CODE) into CONSTANT, b. it turns off the Forth compiler, and c. it turns on the Forth assembler.</p> <p>(;CODE) is part of the word CONSTANT, so it executes when CONSTANT executes (Sequence 2). It performs the following actions:</p> <p>a. It gets the address of the machine code that immediately follows. This is done by popping IP from the Forth Return Stack.</p> <p>b. It puts that address into the Code Field of the word just defined by CREATE. The Forth word LAST (sometimes LATEST) gets the address of that word.</p> <p>c. It does the action of EXIT (a.k.a. ;S) so that the Forth inner interpreter doesn't try to execute the machine code that follows as part of the Forth thread. This is the high-level \"subroutine return\" which ends a Forth thread.</p> <p>F83 [LAX84] illustrates how these are typically coded in Forth:</p> <pre><code>: ;CODE\n    COMPILE (;CODE)     \\ compiles (;CODE) into definition\n    ?CSP  [COMPILE] [   \\ turns off the Forth compiler\n    REVEAL              \\   (just like \";\" does)\n    ASSEMBLER           \\ turns on the assembler\n    ; IMMEDIATE         \\ this is an IMMEDIATE word!\n\n: (;CODE)\n    R&gt;                  \\ pops the adrs of the machine code\n    LAST @ NAME&gt;        \\ gets the CFA of the latest word\n    !                   \\ stores the code address in the\n    ;                   \\   Code Field\n</code></pre> <p>(;CODE) is the more subtle of the two. Since it is a high-level Forth definition, the address following it in the CONSTANT thread -- the high-level \"return address\" -- is pushed onto Forth's Return Stack. So, popping the Return Stack while within (;CODE) will yield the address of the machine code that follows. Also, popping this value from the Return Stack will \"bypass\" one level of high-level subroutine return, so that when (;CODE) exits, it will exit to the caller of CONSTANT. This is equivalent to returning to CONSTANT, and then having CONSTANT return immediately. Use Figure 7 and walk through the execution of the words CONSTANT and (;CODE) to see how this works.</p>"},{"location":"Moving_Forth/moving3/#direct-and-subroutine-threading","title":"Direct and Subroutine Threading","text":"<p>For DTC and STC, the action of ;CODE and (;CODE) is identical to ITC, with one important exception: instead of holding an address, the Code Field holds a JUMP or CALL instruction. For an absolute JUMP or CALL, probably the only difference is that the address has to be stored at the end of the Code Field, as the operand of the JUMP or CALL instruction. In the case of the 6809, the address would be stored as the last two bytes of the three-byte JSR instruction. But some Forths, such as Pygmy Forth on the 8086, use a relative branch in the code field. In this case, the relative offset must be computed and inserted into the branch instruction.</p>"},{"location":"Moving_Forth/moving3/#high-level-forth-actions","title":"HIGH-LEVEL FORTH ACTIONS","text":"<p>We have seen how to make a Forth word execute a chosen fragment of machine language code, and how to pass that fragment the address of the word's Parameter Field. But how do we write the \"action routine\" in high-level Forth?</p> <p>Every Forth word must -- by the action of NEXT -- execute some machine language routine. This is what the Code Field is all about. Therefore, a machine language routine, or a set of routines, is needed to handle the problems of invoking a high- level action. We'll call this routine DODOES. There are three problems to be solved:</p> <p>a. how do we find the address of the high-level action routine associated with this Forth word?</p> <p>b. how do we, from machine code, invoke the Forth interpreter for a high-level action routine?</p> <p>c. how do we pass that routine the address of the Parameter Field for the word we are executing?</p> <p>The answer to (c) -- how do you pass an argument to a high-level Forth routine -- is easy. On the Parameter Stack, of course. Our machine language routine must push the Parameter Field Address on the stack before it invokes the high level routine. (From our previous work, we know how the machine language routine can obtain the PFA.)</p> <p>The answer to (b) is a bit more difficult. Basically, we want to do something like the Forth word EXECUTE, which invokes a Forth word; or perhaps ENTER, which invokes a colon definition. Both are among our \"key\" kernel words. The DODOES code will resemble these.</p> <p>Question (a) is the tricky one. Where to put the address of the high-level routine? Remember, the Code Field does not point to high-level code; it must point to machine code. Two approaches have been used in the past:</p>"},{"location":"Moving_Forth/moving3/#1-the-fig-forth-solution","title":"1. The fig-Forth solution","text":"<p>Fig-Forth reserved the first cell of the Parameter Field to hold the address of the high-level code. The DODOES routine then obtained the Parameter Field address, pushed the address of the actual data (typically PFA+2) onto the stack, fetched the address of the high-level routine, and EXECUTEd.</p> <p>There were two problems with this approach. First, the structure of the Parameter Field was different for machine-code actions and high-level actions. For example, a CONSTANT defined with a machine code action would have its data stored at PFA, but a CONSTANT defined with a high-level action would have its data stored at (typically) PFA+2.</p> <p>Second, every instance of a high-level-action class carried an additional overhead of one cell. That is, if CONSTANT used a high-level action, every constant defined in the program was one cell larger!</p> <p>Fortunately, clever Forth programmers quickly devised a solution which overcame these problems, and the fig-Forth approach has fallen into disuse.</p>"},{"location":"Moving_Forth/moving3/#2-the-modern-solution","title":"2. The modern solution","text":"<p>Most Forths nowadays associate a different machine language fragment with each high-level action routine. So, a high-level constant would have its Code Field pointing to a machine language fragment whose sole function is to invoke the high-level action of CONSTANT. A high-level variable's Code Field would point to the \"startup\" routine for the high-level VARIABLE action, and so on.</p> <p>Is this excessive duplication of code? No, because each of these machine-language fragments is just a subroutine call to a common startup routine, DODOES. (This is different from the fig-Forth DODOES routine.) The address of the high-level code to DODOES is passed as an \"inline\" subroutine parameter. That is, the address of the high-level code is put immediately after the JSR/CALL instruction. DODOES can then pop the CPU stack and do a fetch to obtain this address.</p> <p>Actually, we make two more simplifications. The high-level code itself is put immediately after the JSR/CALL instruction. Then DODOES pops the CPU stack, and obtains this address directly. And since we know this is high-level Forth code, we dispense with its Code Field and just compile the high-level thread...essentially incorporating the action of ENTER into DODOES.</p> <p>Now each \"defined\" word just points to a bit of machine code...no space is consumed in its Parameter Field. This bit of machine code is a JSR or CALL instruction, followed by the high-level action routine. In the 6809 example, we have traded two bytes in every constant for a three-byte JSR that appears only once.</p> <p>This is undoubtedly the most convoluted program logic in the entire Forth kernel! So, let's see how this is implemented in practice, using our trusty ITC 6809 example.</p> <p> Figure 8. ITC DODOES</p> <p></p> <p>Figure 8 shows the constant DEUX implemented with a high-level action. When the Forth interpreter encounters DEUX -- that is, when the Forth IP is at IP(1) -- it does the usual thing: it fetches the address contained in DEUX's Code Field, and jumps to that address. At that address is a JSR DODOES instruction, so a second jump -- this time a subroutine call -- is immediately taken. DODOES must then perform the following actions:</p> <p>a. Push the address of DEUX's Parameter Field onto the Parameter Stack, for later use by the high-level action routine. Since the JSR instruction does not alter any registers, we expect to find the Parameter Field Address of DEUX (or a \"nearby\" address) still in the W register.</p> <p>b. Obtain the address of the high-level action routine, by popping the CPU stack. (Recall that popping the CPU stack will give the address of whatever immediately follows the JSR instruction.) This is a high-level thread, i.e., the Parameter Field part of a colon definition.</p> <p>c. Save the old value of Forth's Instruction Pointer -- IP(2) -- on Forth's Return Stack, since the IP register will be used to execute the high-level fragment. Essentially, DODOES must \"nest\" the IP, just like ENTER does. Remember that Forth's Return Stack may not be the same as the CPU subroutine stack.</p> <p>d. Put the address of the high-level thread into IP. This is IP(3) in Figure 8.</p> <p>e. Do a NEXT to continue high-level interpretation at the new location.</p> <p>Assume an indirect-threaded ITC 6809, and the following:</p> <ul> <li> <p>W is not incremented by NEXT (i.e., W will contain the CFA of the word entered by NEXT);</p> </li> <li> <p>the 6809 S is Forth's PSP, and U is Forth's RSP (i.e., the CPU stack is not Forth's Return Stack);</p> </li> <li> <p>the 6809 Y is Forth's IP, and X is Forth's W.</p> </li> </ul> <p>Recall the definition of NEXT for these conditions:</p> <pre><code>NEXT:   LDX ,Y++   ; (IP) -&gt; W, and IP+2 -&gt; IP\n        JMP [,X]   ; (W) -&gt; temp, JMP (temp)\n</code></pre> <p>DODOES can be written as follows:</p> <pre><code>DODOES: LEAX 2,X    ; make W point to the Parameter Field\n        PSHU Y      ; (c) push old IP onto the Return Stack\n        PULS Y      ; (b,d) pop new IP from the CPU stack\n        PSHS X      ; (a) push W (the Parameter Field \n                    ;     Address) onto the Parameter Stack\n        NEXT        ; (e) invoke high-level interpreter\n</code></pre> <p>These operations are slightly out of sequence. As long as the right things go onto the right stacks (or into the right registers) at the right time, the exact order of operations is not critical. In this case, we're taking advantage of the fact that the old IP can be pushed onto Forth's Return Stack before the new IP is popped from the CPU stack.</p> <p>On some processors the CPU stack is used as Forth's Return Stack. In this case, one step involving temporary storage is necessary. If we had chosen S=RSP and U=PSP above, DODOES would be:</p> <pre><code>DODOES: LEAX 2,X    ; make W point to the Parameter Field\n        PSHU X      ; (a) push W (the Parameter Field \n                    ;     Address) onto the Parameter Stack\n        PULS X      ; (b) pop thread address from CPU stack\n        PSHS Y      ; (c) push old IP onto the Return Stack\n        TFR X,Y     ; (d) put thread address into IP\n        NEXT        ; (e) invoke high-level interpreter\n</code></pre> <p>Since we are essentially swapping the top of the Return/CPU stack with IP, we need to use X as a temporary holding register. Thus we must push the PFA -- step (a) -- before re-using the X register.</p> <p>Walk through both of these DODOES examples step by step, and track the contents of the registers and the two stacks. I always walk through my DODOES routine, just to make sure I'm not clobbering a register at the wrong time.</p>"},{"location":"Moving_Forth/moving3/#direct-threading_1","title":"Direct Threading","text":"<p>The logic of DODOES is the same in DTC Forths. But the implementation may be different, depending on whether the DTC Forth uses a JMP or a CALL in the Code Field of a word.</p> <p>a. JMP in Code Field. A DTC Forth can use a JMP in the Code Field if the address of the word being executed is found in a register. This will most likely be the Code Field Address.</p> <p>From the point of view of DODOES, this is identical to ITC. In our example, DODOES sees that the Forth interpreter jumps to the machine code associated with DEUX, and that code is a JSR to DODOES. It doesn't matter that the first jump is now a direct jump rather than an indirect jump; the register and stack contents are the same. So, the code for DODOES will be identical to that for ITC. (Of course, NEXT is different, and W may need a different offset to point to the Parameter Field.)</p> <p>b. CALL/JSR in Code Field. In the DTC 6809, we never explicitly fetch the CFA of the word being executed, so the Forth word must contain a JSR in its Code Field. Instead of finding the Parameter Field Address of the Forth word in a register, we find it on the CPU stack.</p> <p> Figure 9. DTC DODOES</p> <p></p> <p>The DEUX example in this case is shown in Figure 9. When the Forth IP is at IP(1), the Forth interpreter jumps to the Code Field of DEUX (and increments IP). In the Code Field is a JSR to DEUX's machine code fragment. At that address is a second JSR, to DODOES. So two things get pushed onto the CPU stack. The return address of the first JSR is the Parameter Field address of DEUX. The return address of the second JSR -- and thus topmost on the CPU stack -- is the address of the high-level thread to be executed. DODOES must ensure that the old IP is pushed onto the Return Stack, the PFA of DEUX is pushed onto the Parameter Stack, and the address of the high-level thread is loaded into IP. This is very sensitive to stack assignments! For S=PSP (CPU stack) and U=RSP, the NEXT and DODOES code is:</p> <pre><code>NEXT: LDX [,Y++] ; (IP) -&gt; temp, IP+2 -&gt; IP, JMP (temp)\n\nDODOES: PSHU Y  ; push old IP onto the Return Stack\n        PULS Y  ; pop new IP from the CPU stack\n                ; note: the CPU stack is the Parameter Stack, and the\n                ; topmost element is now the PFA of the word...\n                ; exactly what we want! \n        NEXT    ; invoke high-level interpreter\n</code></pre> <p>Check for yourself that the flow through NEXT, DEUX, and DODOES pushes a net total of one item -- the PFA of DEUX -- onto the Parameter Stack!</p>"},{"location":"Moving_Forth/moving3/#subroutine-threading_1","title":"Subroutine Threading","text":"<p>In STC Forths, there are no IP or W registers, and a high-level \"thread\" is pure machine code (a series of subroutine calls). The only difference between a high-level action and a ;CODE action is that the PFA of the \"defined\" word must be pushed onto the Parameter Stack. \"Defined\" words have a CALL/JSR in the Code Field, and the CPU stack must be Forth's Return Stack, so DODOES is mostly a matter of stack manipulations.</p> <p> Figure 10. STC DODOES</p> <p></p> <p>Figure 10 shows a 6809 STC example of DEUX with a high-level action. By the time DODOES is entered, three things have been pushed onto the CPU/Return Stack: the return address in the \"main\" thread, the PFA of DEUX, and the address of DEUX's high-level action code. DODOES must pop the last two, push the PFA onto the Parameter Stack, and jump to the action code:</p> <pre><code>DODOES: PULS X,Y    ; action code adrs -&gt; X, PFA -&gt; Y\n        PSHU Y      ; push PFA onto Parameter Stack\n        JMP ,X      ; jump to the action code\n</code></pre> <p>DODOES for the 6809 is now a three-instruction routine. It can be simplified even further by \"expanding JSR DODOES in-line\", i.e., replacing the JSR DODOES with the equivalent machine code instructions. Since there's one less JSR, this simplifies the stack manipulation to:</p> <pre><code>        PULS X      ; pop PFA from CPU stack\n        PSHU X      ; and push it onto the Parameter Stack\n        ...high level thread for DEUX...\n</code></pre> <p>This replaces a three-byte JSR with four bytes of explicit code, with a considerable improvement in speed. For the 6809 this would probably be a good choice. For a processor like the 8051, DODOES is long enough that it should be kept as a subroutine.</p>"},{"location":"Moving_Forth/moving3/#using-does","title":"USING DOES&gt;","text":"<p>We learned with ;CODE how to create a new Forth word with arbitrary data in its parameter field, and how to make that word's Code Field point to a new machine code fragment. How do we compile a high-level action routine, and make a new word point to it?</p> <p>The answer lies in the two words DOES&gt; and (DOES&gt;), which are the high-level equivalents of ;CODE and (;CODE). To understand them, let's look at an example of their use:</p> <pre><code>: CONSTANT ( n -- )\n    CREATE      \\ create the new word\n    ,           \\ append the TOS value to the dictionary,\n                \\   as the 1st cell of the Parameter Field\n    DOES&gt;       \\ end \"create\" part &amp; start \"action\" part\n    @           \\ given the PFA, fetch its contents\n    ;\n</code></pre> <p>Compare this with the previous ;CODE example, and observe that DOES&gt; performs a function analogous to ;CODE. Everything from : CONSTANT to DOES&gt; is executed when the word CONSTANT is invoked. This is the code which builds the Parameter Field of the \"defined\" word. Everything from DOES&gt; to ; is the high-level code executed when the \"children\" of CONSTANT (such as DEUX) are invoked, i.e., the high-level fragment to which the Code Field will point. (We'll see that a JSR DODOES is included before this high-level fragment.) Just as with ;CODE, both the \"create\" and the \"action\" clauses are contained within the body of the Forth word CONSTANT, as shown in Figure 11.</p> <p> Figure 11. ITC DOES&gt;</p> <p></p> <p>Recall Sequence 1, 2, and 3. The words DOES&gt; and (DOES&gt;) do the following:</p> <p>DOES&gt; is executed during Sequence 1, when CONSTANT is compiled. Thus DOES&gt; is a Forth IMMEDIATE word. It does two things:</p> <p>a. It compiles the Forth word (DOES&gt;) into CONSTANT. b. It compiles a JSR DODOES into CONSTANT.</p> <p>Note that DOES&gt; leaves the Forth compiler running, in order to compile the high-level fragment which follows. Also, even though JSR DODOES is not itself Forth code, an IMMEDIATE word such as DOES&gt; can cause it to be compiled in the middle of Forth code.</p> <p>(DOES&gt;) is part of the word CONSTANT, so it executes when CONSTANT executes (Sequence 2). It does the following:</p> <p>a. It gets the address of the machine code that immediately follows (JSR DODOES), by popping IP from the Forth Return Stack.</p> <p>b. It puts that address into the Code Field of the word just defined by CREATE.</p> <p>c. It performs the action of EXIT, causing CONSTANT to terminate here and not attempt to execute the fragment that follows.</p> <p>The action of (DOES&gt;) is identical to (;CODE)! A separate word is not strictly required. F83, for example, uses (;CODE) in both ;CODE and DOES&gt;. I'll use (;CODE) from now on instead of (DOES&gt;).</p> <p>You've already seen the workings of (;CODE). The F83 definition of DOES&gt; is</p> <pre><code>: DOES&gt;\n    COMPILE (;CODE)     \\ compiles (;CODE) into definition\n    0E8 C,              \\ the CALL opcode byte\n    DODOES HERE 2+ - ,  \\ the relative offset to DODOES\n    ; IMMEDIATE\n</code></pre> <p>where DODOES is a constant which holds the address of the DODOES routine. (The actual F83 source code is slightly different, due to the requirements of the F83 metacompiler.) DOES&gt; need not fiddle with CSP or the smudge bit, since the Forth compiler is left \"on.\" In the case of the 8086, the CALL instruction expects a relative address...hence the arithmetic involving DODOES and HERE. In the 6809, DOES&gt; would look like</p> <pre><code>: DOES&gt;\n    COMPILE (;CODE)     \\ compiles (;CODE) into definition\n    0BD C,              \\ the JSR Extended opcode byte\n    DODOES ,            \\ the operand: address of DODOES \n    ; IMMEDIATE\n</code></pre> <p>You can see here how the machine language JSR DODOES is compiled after the high-level (;CODE), and before the high-level \"action\" code.</p>"},{"location":"Moving_Forth/moving3/#direct-and-subroutine-threading_1","title":"Direct and Subroutine Threading","text":"<p>The only difference in DTC and STC is how the Code Field is fiddled to point to a new routine. This is done by (;CODE), and the required changes have already been described. DOES&gt; isn't affected at all, unless you're writing an STC Forth and expanding the JSR DODOES to explicit machine code. In this case, DOES&gt; is modified to assemble the \"in-line\" machine code instead of a JSR DODOES instruction.</p>"},{"location":"Moving_Forth/moving3/#onward-and-upward","title":"ONWARD AND UPWARD","text":"<p>Who would have thought that so few lines of code would require so much explanation? This is why I admire ;CODE and DOES&gt; so much...I've never before seen seen such intricate, powerful, and flexible constructs coded with such economy.</p> <p>In the next installment I'll discuss the merits of assemblers vs. metacompilers, and provide the actual CODE definitions for our Forth example systems.</p>"},{"location":"Moving_Forth/moving3/#references","title":"REFERENCES","text":"<p>[DER82] Derick, Mitch and Baker, Linda, Forth Encyclopedia, Mountain View Press (1982). A word-by-word description of fig-Forth in minute detail. Still available from the Forth Interest Group, P.O. Box 2154, Oakland CA 94621.</p> <p>[LAX84] Laxen, H. and Perry, M., F83 for the IBM PC, version 2.1.0 (1984). Distributed by the authors, available from the Forth Interest Group or GEnie.</p> <p>Author's note for web publication: the files formerly available on the GEnie online service are now available from the Forth Interest Group FTP server, <code>ftp://ftp.forth.org/pub/Forth</code>.</p>"},{"location":"Moving_Forth/moving4/","title":"MOVING FORTH 4","text":"<p>Part 4: Assemble or Metacompile? by Brad Rodriguez</p> <p>This article first appeared in The Computer Journal #64 (November/December 1993).</p> <p>\"Keep it SHORT!\" was the editorial directive for this installment. So I apologize for postponing the source listings to yet another issue. In the meantime, there is a new decision to contemplate:</p>"},{"location":"Moving_Forth/moving4/#how-do-you-build-a-forth-system-for-the-very-first-time","title":"How do you build a Forth system for the Very First Time?","text":"<p>You know now that most Forth code is high-level \"threads,\" usually compiled as just a series of addresses. In the early days of fig-Forth, assemblers were often the only programming tools available. This was fine for writing Forth CODE words, but high- level threads had to be written as a series of DW directives. For example, the Forth word</p> <pre><code>: MAX ( n n - n)   OVER OVER &lt; IF SWAP THEN DROP ;\n</code></pre> <p>would be written [TAL80]</p> <pre><code>      DW OVER,OVER,LESS,ZBRAN\n      DW MAX2-$\n      DW SWAP\nMAX2: DW DROP,SEMIS\n</code></pre> <p>Later, as working Forth systems became widespread, Forthwrights began modifying the Forth compilers into cross-compilers [CAS80]. Thus with Forth on your CP/M machine (or Apple II, or whatever), you could write Forth programs for some other CPU...up to and including an entirely new Forth system for that CPU.</p> <p>Because they create a new Forth from within Forth, these are often called metacompilers. Computer science purists object to this, so some Forthies use the terms \"cross-compiler\" and \"recompiler.\" The difference is that a recompiler can only generate a new Forth for the same CPU.</p> <p>Most PC Forths are now produced with metacompilers, but opinion is divided in the embedded systems arena [TIN91,ROD91,SER91]. The arguments for using assemblers to write Forth are:</p> <ol> <li>Metacompilers are cryptic and hard to understand, and you must thoroughly understand a metacompiler in order to use it.</li> <li>Assemblers are understood by the average programmer.</li> <li>An assembler is almost always available for a new CPU.</li> <li>Assemblers handle many optimizations (e.g. short vs. long branch).</li> <li>Assemblers handle forward references and peculiar address modes; many metacompilers don't.</li> <li>Assemblers use familiar editing and debugging tools.</li> <li>The code generation is completely visible -- nothing is \"hidden\" from the programmer.</li> <li>It's easier to tweak the Forth model, since many design decisions affect the internals of a metacompiler.</li> </ol> <p>The arguments for metacompilers:</p> <ol> <li>You write \"normal\" looking Forth code, which is easier to read and debug.</li> <li>Once you understand your metacompiler, you can port it easily to new CPUs.</li> <li>The only tool you need to acquire is a Forth for your computer.</li> </ol> <p>The last is particularly applicable to those who don't own PCs, since most cross-assemblers require PCs or workstations these days.</p> <p>I've written several Forths each way, so I'm painfully aware of the tradeoffs. I admit a preference for metacompilers: I find the Forth code for MAX much easier to read and understand than its assembler equivalent. Most of the arguments against metacompilers have been overcome by modern \"professional\" compilers, and if you're using Forth for work I strongly recommend investing in a commercial product. Alas, public-domain metacompilers (including my own) are still behind the times, clunky, and arcane.</p> <p>So I'm going to take a radical position for a Forth programmer, and tell you to choose for yourself. I'll publish the 6809 code in metacompiler form, and I'll supply a metacompiler for F83 (IBM PC, CP/M, or Atari ST) [ROD92]. The Z80 code will be written for a CP/M assembler. The 8051 code will be written for a public-domain PC cross-assembler.</p> <p>Forth in C?</p> <p>No discussion of this topic would be complete without mentioning a new trend: Forths written in C. These have the advantage of being more portable than assembler -- in theory, all you have to do is recompile the same source code for any CPU. The disadvantages:</p> <ol> <li>Less flexibility in the design decisions; e.g., direct-threaded code is probably not possible, and you can't optimize register assignments.</li> <li>You have to recompile the C source to add new primitives.</li> <li>Forth words carry the C call-and-return overhead.</li> <li>Some C Forths use inefficient threading techniques, e.g. a CASE statement.</li> <li>Most C compilers produce less efficient code than a good assembly-language programmer.</li> </ol> <p>But for Unix systems and RISC workstations, which frown upon assembler, this may be the only way to get a Forth up and running. The most complete and widely used of the public-domain C Forths [at the time of publication] is TILE (TILE_21.ZIP, file #2263 on GEnie's Forth Roundtable). If you're not running Unix, you should look instead at the Genie files HENCE4TH_1.2.A (#2490) and CFORTHU.ARC (#2079).</p> <p>To continue the previous comparison, here's the definition of MAX from HENCE4TH [MIS90]. I omit the dictionary headers for clarity:</p> <pre><code>_max() {\n    OVER  OVER  LESS IF  SWAP  ENDIF  DROP }\n</code></pre> <p>Instead of assembler, C is used to write the CODE words in the kernel. For example, here is HENCE4TH's SWAP:</p> <pre><code>_swap() {\n    register cell i = *(dsp);\n    *(dsp) = *(dsp + 1);\n    *(dsp + 1) = i;\n}\n</code></pre> <p>(Please note: there is quite a variety of techniques for writing Forth words in C, so these words may appear radically different in CFORTH or TILE.)</p> <p>On a 68000 or SPARC, this might produce quite good code. On a Z80 or 8051, quite the opposite. But even if you plan to write a Forth in C, you need to understand how Forth works in assembler. So stay tuned for the next installment of Moving Forth!</p> <p>REFERENCES</p> <p>[CAS80] Cassady, John J., METAFORTH: A Metacompiler for Fig- Forth, Forth Interest Group (1980).</p> <p>[MIS90] HenceFORTH in C, Version 1.2, distributed by The Missing Link, 975 East Ave. Suite 112, Chico, CA 95926, USA (1990). This is a shareware product available from the GEnie Forth Roundtable.</p> <p>[ROD91] Rodriguez, B.J., letter to the editor, Forth Dimensions XIII:3 (Sep/Oct 1991), p.5.</p> <p>[ROD92] Rodriguez, B.J., \"Principles of Metacompilation,\" Forth Dimensions XIV:3 (Sep/Oct 1992), XIV:4 (Nov/Dec 1992), and XIV:5 (Jan/Feb 1993). Note that the published code is for a fig-Forth variant and not F83. The F83 version is on GEnie as CHROMIUM.ZIP</p> <p>[SER91] Sergeant, Frank, \"Metacompilation Made Easy,\" Forth Dimensions XII:6 (Mar/Apr 1991).</p> <p>[TAL80] Talbot, R.J., fig-Forth for 6809, Forth Interest Group, P.O. Box 2154, Oakland, CA 94621 (1980).</p> <p>[TIN91] Ting, C.H., \"How Metacompilation Stops the Growth Rate of Forth Programmers,\" Forth Dimensions XIII:1 (May/Jun 1991), p.17.</p> <p>Author's note for web publication: the files formerly available on the GEnie online service are now available from the Forth Interest Group FTP server, <code>ftp://ftp.forth.org/pub/Forth</code>. Also, several new Forths-in-C have been published since this article was first written. Consult the \"systems\" FAQ at <code>ftp://ftp.forth.org/pub/Forth/FAQ</code> for a current list.</p>"},{"location":"Moving_Forth/moving5/","title":"MOVING FORTH 5","text":"<p>Part 5: The Z80 Primitives by Brad Rodriguez</p> <p>This article first appeared in The Computer Journal #67 (May/June 1994).</p>"},{"location":"Moving_Forth/moving5/#the-code-i-promised","title":"THE CODE I PROMISED","text":"<p>At long last, I am ready to present the complete source code for an (I hope) ANSI compliant Forth, CamelForth [1]. As an intellectual exercise -- and to ensure a clear copyright -- I've written this code entirely from scratch. (Do you know how hard it is to not look at excellent code examples?) Of course, my experience with various Forths has no doubt influenced some design decisions.</p> <p>Due to space limitations, the source code will be presented in four installments (if you can't wait, complete files will be on GEnie):</p> <ol> <li>Z80 Forth \"primitives,\" in assembler source</li> <li>8051 Forth \"primitives,\" likewise</li> <li>Z80/8051 high-level kernel, likewise</li> <li>complete 6809 kernel, in metacompiler source</li> </ol> <p>For CamelForth I'm trying to use exclusively public-domain tools: for the Z80, the Z80MR assembler under CP/M [3]; for the 8051, the A51 cross-assembler on an IBM PC [4], and for the 6809, my own metacompiler under F83 for CP/M, IBM PC, or Atari ST.</p> <p>By \"kernel\" I mean the set of words that comprises a basic Forth system, including compiler and interpreter. For CamelForth this is the ANS Forth Core word set, plus any non-ANSI words necessary to implement the Core word set. A Forth kernel is usually written partly in machine code (as CODE words), and partly in high-level Forth. The words which are written in machine code are called the \"primitives,\" since, in the final analysis, the entire Forth system is defined in terms of just these words.</p> <p>Exactly which words should be written in machine code? The selection of the optimal set of primitives is an interesting debate. A smaller set of primitives makes for easier porting, but poorer performance. I've been told that a set of 13 primitives is sufficient to define all of Forth -- a very slow Forth. eForth [2], designed for easy porting, had a more generous set of 31 primitives. My rules are these:</p> <ol> <li>Fundamental arithmetic, logic, and memory operators are CODE.</li> <li>If a word can't be easily or efficiently written (or written at all) in terms of other Forth words, it should be CODE (e.g., U\\&lt;, RSHIFT).</li> <li>If a simple word is used frequently, CODE may be worthwhile (e.g., NIP, TUCK).</li> <li>If a word requires fewer bytes when written in CODE, do so (a rule I learned from Charles Curley).</li> <li>If the processor includes instruction support for a word's function, put it in CODE (e.g. CMOVE or SCAN on a Z80 or 8086).</li> <li>If a word juggles many parameters on the stack, but has relatively simple logic, it may be better in CODE, where the parameters can be kept in registers.</li> <li>If the logic or control flow of a word is complex, it's probably better in high-level Forth.</li> </ol> <p>For Z80 CamelForth I have a set of about 70 primitives. (See Table 1) Having already decided on the Forth model and CPU usage (see my previous TCJ articles), I followed this development procedure:</p> <ol> <li>Select the subset of the ANSI Core word set which will be primitives. (Subject to revision, of course.)</li> <li>From the ANSI descriptions, write assembler definitions of these words, plus the processor initialization code.</li> <li>Run this through the assembler, fixing source code errors.</li> <li>Test that you can produce working machine code. I usually add a few lines of assembler code to output a character once the initialization is complete. This seemingly trivial test is crucial! It ensures that your hardware, assembler, \"downloader\" (EPROM emulator or whatever), and serial communications are all working! 5. (Embedded systems only) Add another assembler code fragment to read the serial port and echo it back...thus testing both directions of communications.</li> <li>Write a high-level Forth fragment to output a character, using only Forth primitives. (Usually something like \"LIT,33h,EMIT,BYE\") This tests the Forth register initialization, the stacks, and the threading mechanism. Problems at this stage can usually be traced to logic errors in NEXT or in the initialization, or data stack goofs (e.g. stack in ROM).</li> <li>Write a colon definition to output a character, and include it in the high-level fragment from step 6. (E.g., define BLIP as \"LIT,34h,EMIT,EXIT\" and then test the fragment \"LIT,33h,EMIT, BLIP,BYE\") Problems at this stage are usually with DOCOLON or EXIT logic, or return stack goofs.</li> <li>At this point you can write some tools to help you with debugging, such as words to display in hex a number on the stack. Listing 1 shows a simple test routine to do a never-ending memory dump (useful even if your keyboard doesn't work). This tests the primitives DUP, EMIT, EXIT, C@, &gt;\\&lt;, LIT, 1+, and BRANCH, as well as several levels of nesting. Plus, it doesn't use DO..LOOP, which are often difficult to get working. When this code works, you have some confidence that your basic Forth model is valid.</li> <li>From here on it's just testing the remaining primitives -- DO..LOOP, UM/MOD, UM*, and DODOES are particularly tricky -- and adding high-level definitions. I like to get a rudimentary interpreter going next, so that I can test words interactively.</li> </ol> <p>With this set of primitives you can begin writing Forth code. Sure, you have to use an assembler instead of a Forth compiler, but -- as Listing 1 suggests -- you can use high-level control flow and nesting to write useful code that would be more difficult to write in assembler.</p>"},{"location":"Moving_Forth/moving5/#read-the-code","title":"READ THE CODE!","text":"<p>I've run out of abstractions for today. If you want to learn more about how a Forth kernel works and is written, study Listing 2. It follows the Forth convention for documentation:</p> <pre><code>WORD-NAME    stack in -- stack out    description\n</code></pre> <p>WORD-NAME is the name by which Forth knows the word. Often these names include peculiar ASCII characters, so an approximation must be used when defining assembler labels (such as ONEPLUS for the Forth word 1+).</p> <p>stack in are the arguments this word expects to see on the stack, with the topmost stack item always on the right. stack out are the arguments this word will leave on the stack, likewise.</p> <p>If the word has a return stack effect (other than nesting, that is), an additional return stack comment will be added after \"R:\"</p> <pre><code>stack in -- stack out    R: stack in -- stack out\n</code></pre> <p>ANSI Forth defines a number of useful abbreviations for stack arguments, such as \"n\" for a signed single-cell number, \"u\" for an unsigned single-cell number, \"c\" for a character, and so on. See Table 1.</p>"},{"location":"Moving_Forth/moving5/#references","title":"REFERENCES","text":"<p>[1] Definition of a camel: a horse designed by committee.</p> <p>[2] Ting, C. H., eForth Implementation Guide, July 1990, available from Offete Enterprises, 1306 South B Stret, San Mateo, CA 94402 USA.</p> <p>[3] Z80MR, a Z80 Macro Assembler by Mike Rubenstein, is public-domain, available on the GEnie CP/M Roundtable as file Z80MR-A.LBR. Warning: do not use the supplied Z1.COM program, use only Z80MR and LOAD. Z1 has a problem with conditional jumps.</p> <p>[4] A51, PseudoCorp's freeware Level 1 cross-assembler for the 8051, is available from the Realtime and Control Forth Board, (303) 278-0364, or on the GEnie Forth Roundtable as file A51.ZIP. PseudoCorp's commercial products are advertised here in TCJ.</p> <p>Source code for Z80 CamelForth is available on this site at http://www.camelforth.com/public_ftp/cam80-12.zip.</p>"},{"location":"Moving_Forth/moving6/","title":"MOVING FORTH 6","text":"<p>Part 6: the Z80 high-level kernel by Brad Rodriguez</p> <p>This article first appeared in The Computer Journal #69 (September/October 1994).</p>"},{"location":"Moving_Forth/moving6/#errata","title":"ERRATA","text":"<p>There are two goofs in the CAMEL80.AZM file I presented in TCJ#67. The minor goof is that the name length specified in the HEAD macro for the Forth word &gt; was incorrectly typed as 2 instead of 1.</p> <p>The major goof results from a subtlety of CP/M console I/O. KEY must not echo the typed character, and so used BDOS function 6. KEY? used BDOS function 11 to test non-destructively for the presence of a keypress. Unfortunately, BDOS function 6 does not \"clear\" the keypress detected by function 11! I have now rewritten KEY? to use BDOS function 6 (see Listing 1). Since this is a \"destructive\" test, I had to add logic to save the \"consumed\" keypress and return it when KEY is next used. This new logic can be used whenever your hardware (or operating system) provides only a destructive test-for-keypress.</p>"},{"location":"Moving_Forth/moving6/#high-level-definitions","title":"HIGH LEVEL DEFINITIONS","text":"<p>In the last installment I did not expound greatly on the source code. Each Forth \"primitive\" performs a miniscule, sharply-defined function. It was almost all Z80 assembler code, and if it wasn't obvious why a particular word was included, I hope it was clear what each word did.</p> <p>In this installment I have no such luxury: I will present the high level definitions which embody the elegant (and tortuous) logic of the Forth language. Entire books have been written [1,2,3] describing Forth kernels, and if you want complete mastery I highly recommend you buy one of them. For TCJ I'll limit myself to some of the key words of the compiler and interpreter, given in Listing 2.</p>"},{"location":"Moving_Forth/moving6/#text-interpreter-operation","title":"TEXT INTERPRETER OPERATION","text":"<p>The text or \"outer\" interpreter is the Forth code which accepts input from the keyboard and performs the desired Forth operations. (This is distinct from the address or \"inner\" interpreter, NEXT, which executes compiled threaded code) The best way to understand it is to work through the startup of the Forth system.</p> <ol> <li> <p>The CP/M entry point (see listing in previous installment) determines the top of available memory, set the stack pointers (PSP,RSP) and user pointer (UP), establishing the memory map shown in Figure 1. It then sets the \"inner\" interpreter pointer (IP) to execute the Forth word COLD.</p> </li> <li> <p>COLD initializes the user variables from a startup table, and then does ABORT. (COLD will also attempt to execute a Forth command from the CP/M command line.)</p> </li> <li> <p>ABORT resets the parameter stack pointer and does QUIT.</p> </li> <li> <p>QUIT resets the return stack pointer, loop stack pointer, and interpret state, and then begins to interpret Forth commands. (The name is apt because QUIT can be used to abort an application and get back to the \"top level\" of Forth. Unlike ABORT, QUIT will leave the parameter stack contents alone) QUIT is an infinite loop which will ACCEPT a line from the keyboard, and then INTERPRET it as Forth commands. When not compiling, QUIT will prompt \"ok\" after each line.</p> </li> <li> <p>INTERPRET is an almost verbatim translation of the algorithm given in section 3.4 of the ANS Forth document. It parses one space-delimited string from the input, and tries to FIND the Forth word of that name. If the word is found, it will be either executed (if it is an IMMEDIATE word, or if in the \"interpret\" state, STATE=0) or compiled into the dictionary (if in the \"compile\" state, STATE\\&lt;&gt;0). If not found, Forth attempts to convert the string as a number. If successful, LITERAL will either place it on the parameter stack (if in \"interpret\" state) or compile it as an in-line literal value (if in \"compile\" state). If not a Forth word and not a valid number, the string is typed, an error message is displayed, and the interpreter ABORTs. This process is repeated, string by string, until the end of the input line is reached.</p> </li> </ol>"},{"location":"Moving_Forth/moving6/#the-forth-dictionary","title":"THE FORTH DICTIONARY","text":"<p>Whoa! How does the interpreter \"find\" a Forth word by name? Answer: Forth keeps a \"dictionary\" of the names of all Forth words. Each name is connected in some fashion with the executable code for the corresponding word.</p> <p>There are many ways to store a set of strings for searching: a simple array, a linked list, a multiple linked list, hash table, etc. Almost all are valid here -- all Forth asks is that, if you reuse a name, the latest definition is found when you search the dictionary.</p> <p>It's also possible to have several sets of names (\"vocabularies\", or \"wordlists\" in the new ANSI jargon ). This lets you reuse a name without losing its previous meaning. For example, you could have an integer +, a floating-point +, even a + for strings...one way to achieve the \"operator overloading\" so beloved by the object-oriented community.</p> <p>Each string may be connected with its executable code by being physically adjacent in memory -- i.e., the name appears in memory just before the executable code, thus being called the \"head\" or \"header\" of the Forth word. Or the strings may be located in a totally different part of memory, and connected with pointers to executable code (\"separate heads\").</p> <p>You can even have unnamed (\"headless\") fragments of Forth code, if you know you'll never need to compile or interpret them. ANSI only requires that the ANS Forth words be findable.</p> <p>The design decisions could fill another article. Suffice it to say that CamelForth uses the simplest scheme: a single linked list, with the header located just before the executable code. No vocabularies... although I may add them in a future issue of TCJ.</p>"},{"location":"Moving_Forth/moving6/#header-structure","title":"HEADER STRUCTURE","text":"<p>Still more design decisions: what data should be present in the header, and how should it be stored?</p> <p>The minimum data is the name, precedence bit, and pointer (explicit or implicit) to executable code. For simplicity, CamelForth stores the name as a \"counted string\" (one byte of length, followed by N characters). Early Forth Inc. products stored a length but only the first three characters, for faster comparisons (the actual improvement gained is another hot debate). Fig-Forth compromised, flagging the last character with MSB high in order to allow either full-length or truncated names. Other Forths have used packed strings [4], and I suspect even C-style null-terminated strings have been used.</p> <p>The \"precedence bit\" is a flag which indicates if this word has IMMEDIATE status. IMMEDIATE words are executed even during compilation, which is how Forth implements compiler directives and control structures. There are other ways to distinguish compiler directives -- Pygmy Forth [5], for example, puts them in a separate vocabulary. But ANS Forth essentially mandates the use of a precedence bit [6]. Many Forths store this bit in the \"length\" byte. I have chosen to put it in a separate byte, in order to use the \"normal\" string operators on word names (e.g. S= within FIND, and TYPE within WORDS).</p> <p>If the names are kept in a linked list, there must be a link. Usually the latest word is at the head of the linked list, and the link points to a previous word. This enforces the ANSI (and traditional) requirement for redefined words. Charles Curley [7] has studied the placement of the link field, and found that the compiler can be made significantly faster if the link field comes before the name (rather than after, as was done in Fig-Forth).</p> <p>Figure 2 shows the structure of the CamelForth word header, and the Fig-Forth, F83, and Pygmy Forth headers for comparison. The \"view\" vield of F83 and Pygmy is an example of other useful information which can be stored in the Forth word header.</p> <p>Remember: it's important to distinguish the header from the \"body\" (executable part) of the word. They need not be stored together. The header is only used during compilation and interpretation, and a \"purely executable\" Forth application could dispense with headers entirely. However, headers must be present -- at least for the ANSI word set -- for it to be a legal ANS Forth System.</p> <p>When \"compiling\" a Forth system from assembler source code, you can define macros to build this header (see HEAD and IMMED in CAMEL80.AZM). In the Forth environment the header, and the Code Field, is constructed by the word CREATE.</p>"},{"location":"Moving_Forth/moving6/#compiler-operation","title":"COMPILER OPERATION","text":"<p>We now know enough to understand the Forth compiler. The word : starts a new high-level definition, by creating a header for the word (CREATE), changing its Code Field to \"docolon\" (!COLON), and switching to compile state (]). Recall that, in compile state, every word encountered by the text interpreter is compiled into the dictionary instead of being executed. This will continue until the word ; is encountered. Being an IMMEDIATE word, ; will execute, compiling an EXIT to end the definition, and then switching back to interpret state ([).</p> <p>Also, : will HIDE the new word, and ; will REVEAL it (by setting and clearing the \"smudge\" bit in the name). This is to allow a Forth word to be redefined in terms of its \"prior self\". To force a recursive call to the word being defined, use RECURSE.</p> <p>Thus we see that there is no distinct Forth \"compiler\", in the same sense that we would speak of a C or Pascal compiler. The Forth compiler is embodied in the actions of various Forth words. This makes it easy for you to change or extend the compiler, but makes it difficult to create a Forth application without a built-in compiler!</p>"},{"location":"Moving_Forth/moving6/#the-dependency-word-set","title":"THE DEPENDENCY WORD SET","text":"<p>Most of the remaining high-level words are either a) necessary to implement the compiler and interpreter, or b) provided solely for your programming pleasure. But there is one set which deserves special mention: the words I have separated into the file CAMEL80D.AZM (Listing 3).</p> <p>One of the goals of the ANSI Forth Standard was to hide CPU and model dependencies (Direct or Indirect Threaded? 16 or 32 bit?) from the application programmer. Several words were added to the Standard for this purpose. I have taken this one step further, attempting to encapsulate these dependencies even within the kernel. Ideally, the high-level Forth code in the file CAMEL80H.AZM should be the same for all CamelForth targets (although different assemblers will have different syntax).</p> <p>Differences in cell size and word alignment are managed by the ANS Forth words ALIGN ALIGNED CELL+ CELLS CHAR+ CHARS and my own addition, CELL (equivalent to 1 CELLS, but smaller when compiled).</p> <p>The words COMPILE, !CF ,CF !COLON and ,EXIT hide peculiarities of the threading model, such as a) how are the threads represented, and b) how is the Code Field implemented? The value of these words becomes evident when you look at the differences between the direct-threaded Z80 and the subroutine-threaded 8051:</p> <pre><code>word     compiles on Z80   compiles on 8051\n-------- ----------------- ---------------------------\n\nCOMPILE, address           LCALL address\n!CF      CALL address      LCALL address\n,CF      !CF &amp; allot       3 bytes !CF &amp; allot 3 bytes\n!COLON   CALL docolon      nothing!\n,EXIT    address of EXIT   RET\n</code></pre> <p>(!CF and ,CF are different for indirect-threaded Forths.)</p> <p>In similar fashion, the words ,BRANCH ,DEST and !DEST hide the implementation of high-level branch and loop operators. I have tried to invent -- without borrowing from existing Forths! -- the minimal set of operators which can factor out all the implementation differences. Only time, expert criticism, and many CamelForths will tell how successful I've been.</p> <p>So far I have not been successful factoring the differences in header structure into a similar set of words. The words FIND and CREATE are so intimately involved with the header contents that I haven't yet found suitable subfactors. I have made a start, with the words NFA&gt;LFA NFA&gt;CFA IMMED? HIDE REVEAL and the ANS Forth words &gt;BODY IMMEDIATE. I'll continue to work on this. Fortunately, it is practical for the time being to use the identical header structure on all CamelForth implementations (since they're all byte-addressed 16-bit Forths).</p>"},{"location":"Moving_Forth/moving6/#next-time","title":"NEXT TIME...","text":"<p>I will probably present the 8051 kernel, and talk about how the Forth compiler and interpreter are modified for Harvard architectures (computers that have logically distinct memories for Code and Data, like the 8051). For the 8051 I will print the files CAMEL51 and CAMEL51D, but probably only excerpts from CAMEL51H, since (except for formatting of the assembler file) the high-level code shouldn't be different from what I've presented this issue...and Bill needs the space for other articles! Don't worry, the full code will be uploaded to GEnie.</p> <p>However, I may succumb to demands of Scroungemaster II builders, and publish the 6809 CamelForth configured for the Scroungemaster II board. Whichever I do next, I'll do the other just one installment later.</p>"},{"location":"Moving_Forth/moving6/#references","title":"REFERENCES","text":"<ol> <li> <p>Derick, Mitch and Baker, Linda, Forth Encyclopedia, Mountain View Press, Route 2 Box 429, La Honda, CA 94020 USA (1982). Word-by-word description of Fig-Forth.</p> </li> <li> <p>Ting, C. H., Systems Guide to fig-Forth, Offete Enterprises, 1306 South B Street, San Mateo, CA 94402 USA (1981).</p> </li> <li> <p>Ting, C. H., Inside F83, Offete Enterprises (1986).</p> </li> <li> <p>Ewing, Martin S., The Caltech Forth Manual, a Technical Report of the Owens Valley Radio Observatory (1978). This PDP-11 Forth stored a length, four characters, and a link in two 16-bit words.</p> </li> <li> <p>Sergeant, Frank, Pygmy Forth for the IBM PC, version 1.4 (1992). Distributed by the author, available from the Forth Interest Group (P.O. Box 2154, Oakland CA 94621 USA) or on GEnie.</p> </li> <li> <p>J. E. Thomas examined this issue thoroughly when converting Pygmy Forth to an ANSI Forth. No matter what tricks you play with relinking words, strict ANSI compliance is violated. A regrettable decision on the part of the ANS Forth team.</p> </li> <li> <p>In private communication.</p> </li> </ol> <p>The source code for Z80 CamelForth is now available on GEnie as CAMEL80.ARC in the CP/M and Forth Roundtables. Really. I just uploaded it. (Apologies to those who have been waiting.)</p> <p>Source code for Z80 CamelForth is available on this site at http://www.camelforth.com/public_ftp/cam80-12.zip.</p> <p></p>"},{"location":"Moving_Forth/moving6/#figure-1-z80-cpm-camelforth-memory-map","title":"FIGURE 1. Z80 CP/M CAMELFORTH MEMORY MAP","text":"<p>assuming CP/M BDOS starts at ED00 hex.</p> <pre><code>0000 +-----------------------+\n    |      CP/M stuff       |\n0080 +-----------------------+\n    | Terminal Input Buffer |\n    |                       |\n0100 +-----------------------+\n    |                       |\n    | CamelForth Z80 kernel |\n    |                       |\n1700 +-----------------------+\n    | User definitions      |\n    |                       |\n    |                       |   / EB00 reserved\n    ~~~~~~~~~~~~~~~~~~~~~~~~~  /  EB02 &gt;IN\n    |                       | /   EB04 BASE\nEB00 +-----------------------+/    EB06 STATE\n    | User Area             |     EB08 DP\n    |                       |\\    EB0A,EB0C 'SOURCE\n    |                       | \\   EB0E LATEST\n    |       Parameter Stack |  \\  EB10 HP\nEC00 +-----------------------+   \\ EB12 LP\n    |                       |\n    |   HOLD working buffer |\nEC28 +-----------------------+\n    | PAD buffer            |\n    |                       |\nEC80 +-----------------------+\n    | Leave stack*          |\n    |                       |\n    |                       |\n    |          Return stack |\nED00 +-----------------------+\n    |                       |\n    |         CP/M          |\n    |                       |\nFFFF +-----------------------+\n</code></pre> <p>* used during compilation of DO..LOOPs.</p> <p></p>"},{"location":"Moving_Forth/moving6/#figure-2-header-structures","title":"FIGURE 2. HEADER STRUCTURES","text":"<pre><code>    CamelForth        Fig-Forth          Pygmy Forth            F83\n\n D7           D0    D7           D0    D7           D0    D7           D0\n+---------------+  +-+-+-+---------+  +---------------+  +---------------+\n|               |  |1|P|S| length  |  |               |  |               |\n|-    link     -|  +-+-+-+---------+  |-    view     -|  |-    view     -|\n|               |  |               |  |               |  |               |\n+-------------+-+  |-    name     -|  +---------------+  +---------------+\n|      0      |P|  |               |  |               |  |               |\n+-+-----------+-+  ~~~~~~~~~~~~~~~~~  |-    link     -|  |-    link     -|\n|S|   length    |  |               |  |               |  |               |\n+-+-------------+  +-+            -|  +-+-+-+---------+  +-+-+-+---------+\n|               |  |1|             |  |0|0|S| length  |  |1|P|S| length  |\n|-    name     -|  +-+-------------+  +-+-+-+---------+  +-+-+-+---------+\n|               |  |               |  |               |  |               |\n~~~~~~~~~~~~~~~~~  |-    link     -|  |-    name     -|  |-    name     -|\n|               |  |               |  |               |  |               |\n|-             -|  +---------------+  ~~~~~~~~~~~~~~~~~  ~~~~~~~~~~~~~~~~~\n|               |                     |               |  |               |\n+---------------+                     |-             -|  +-+            -|\n                                      |               |  |1|             |\n                                      +---------------+  +-+-------------+\n</code></pre> <p>Link - in CamelForth and Fig-Forth, points to the previous word's Length byte. In Pygmy Forth and F83, points to the previous word's Link.</p> <p>P - Precedence bit, equals 1 for an IMMEDIATE word (not used in Pygmy).</p> <p>S - Smudge bit, used to prevent FIND from finding this word.</p> <p>1 - in Fig-Forth and F83, the length byte and the last character of the name are flagged with a 1 in the most significant bit (bit 7).</p> <p>View - in Pygmy Forth and F83, contains the block number of the source code for this word.</p>"},{"location":"Moving_Forth/moving7/","title":"MOVING FORTH 7","text":"<p>Part 7: CamelForth for the 8051 by Brad Rodriguez</p> <p>This article first appeared in The Computer Journal #71 (January/February 1995).</p> <p>Under the prodding of Our Esteemed Editor, I present CamelForth for the 8051. CamelForth for the 6809 will follow soon! This 8051 Forth occupies about 6K of program memory. Alas, the full source listing would take 16 pages of TCJ, so this article includes only the significantly changed portions of the kernel. [Note for web publication: see the end of this page for a link to the 8051 source code.] These should illustrate how the high-level code is modified for the 8051 assembler, and for subroutine threading. The full source code is available in the Forth Roundtable on GEnie as file CAMEL51.ZIP, and the freeware 8051 assembler as file A51.ZIP. But first...</p>"},{"location":"Moving_Forth/moving7/#z80-errata","title":"Z80 ERRATA","text":"<p>In the file CAMEL80H.AZM, the definition of DO is given as</p> <pre><code>['] xdo ,BRANCH  . . .\n</code></pre> <p>It should be</p> <pre><code>['] xdo ,XT  . . .\n</code></pre> <p>This is of no consequence on the Z80 (where ,BRANCH and ,XT are identical), but it became embarrassingly obvious on the 8051.</p> <p>Also, in the words S\" and (S\"), the word ALIGN should really be ALIGNED. On the Z80 -- and the 8051 -- both are no-ops, so this mistake didn't make itself evident.</p>"},{"location":"Moving_Forth/moving7/#8051-camelforth-model","title":"8051 CAMELFORTH MODEL","text":"<p>In issue #60 I summarized the design decisions for an 8051 Forth. To recap: the 8051's retarded memory addressing practically demands the use of subroutine threading. This means the hardware stack (in the 8051 register file) is the Return Stack. The Parameter Stack (a.k.a. Data Stack) is in 256 bytes of external RAM, using R0 as the stack pointer. Since that article, I've discovered that it's better to keep the Top Of Stack item (TOS) in DPTR than in R3:R2. Thus:</p> reg adrs 8051 name Forth usage 0 R0 low byte of PSP (Parameter Stack Pointer) 1-5 R1-R5 scratch registers for Forth 6-7 R6-R7 loop index 8 high byte of PSP and UP (also output on P2) 9-7Fh 119 bytes of return stack (more on 8052s!) 81h SP low byte of RSP (Return Stack Pointer) 82-83h DPTR Top-Of-Stack item E0,F0h A,B scratch registers for Forth <p>This incorporates an idea from Charles Curley [CUR93]. On a register-rich machine like the 8051, we can keep the innermost loop index in registers. This makes LOOP and +LOOP much faster. DO must still push two values on the Return Stack: the old loop index, and the new loop limit! UNLOOP must of course restore the loop index from the Return Stack -- kudos to the ANSI team for making UNLOOP a distinct word! Note that R6:R7 are not the topmost Return Stack item, merely the innermost loop index.</p> <p>Port 2 (P2) contains the high byte of the Parameter Stack Pointer (allowing R0 to address external memory), which is also the high byte of the User Pointer -- the low byte of UP is assumed to be 00. I learned the hard way that P2 can't be read while executing from external ROM, so I keep a copy of the P2 byte in register 8.</p> <p>I have a novel implementation of BRANCH and ?BRANCH. Since the 8051 model is subroutine-threaded, high-level Forth is compiled as true machine code. So BRANCH can be implemented with an SJMP (or AJMP or LJMP) instruction. ?BRANCH can be implemented with a JZ instruction, if the zero/nonzero status of the top-of-stack is put in the accumulator (A register). The subroutine ZEROSENSE does this. So, BRANCH and ?BRANCH become</p> <pre><code>BRANCH:   SJMP dest \n?BRANCH:  LCALL ZEROSENSE JZ dest\n</code></pre> <p>Similar routines LOOPSENSE and PLUSLOOPSENSE allow a JZ instruction to be used for LOOP and +LOOP. For these, a call to UNLOOP must appear after the JZ, to clean up the Return Stack when the program \"falls out\" of the loop.</p> <p>In the assembly language source file I have manually replaced the sequence</p> <pre><code>LCALL word   RET\n</code></pre> <p>with the shorter and faster</p> <pre><code>LJMP word\n</code></pre> <p>in many places [CUR93]. This works as long as \"word\" isn't a return-stack operator (such as R&gt; or &gt;R). LCALL and LJMP have also been replaced with ACALL and AJMP where possible. The CamelForth compiler does not attempt these optimizations.</p> <p>I wrote the 8051 kernel to use \"Intel\" byte order (low byte first). Then I discovered that the address compiled into an LJMP or LCALL is stored high byte first. Rather than rewrite the entire kernel, I included a byte-swap in those words which compile LCALLs: COMPILE, !CF and ,CF (all in the Dependency word set).</p> <p>Listing 1 gives the 8051 assembly language \"primitives\", and Listing 2 gives the Dependency word set.</p>"},{"location":"Moving_Forth/moving7/#harvard-architectures","title":"HARVARD ARCHITECTURES","text":"<p>The 8051 uses a \"Harvard\" architecture: program and data are kept in separate memories. In embedded systems, these are typically ROM and RAM, respectively. ANS Forth is the first Forth standard to address the restrictions of a Harvard architecture. Briefly, ANS Forth says that a) application programs can only access Data memory, and b) all of the operators used to access memory and build data structures must operate in Data space. (Ref. section 3.3.3 of the ANS document [ANS94].) This includes the Forth words</p> <p>@ ! C@ C! DP HERE ALLOT , C, COUNT TYPE WORD (S\") S\" CMOVE</p> <p>Yet the Forth compiler still needs to access Program space (also called Code or Instruction space). And Forth needs to maintain a dictionary pointer for Program space as well as Data space. So I've added these new words (shown in Listing 3):</p> <p>I@ I! IC@ IC! IDP IHERE IALLOT I, IC, ICOUNT ITYPE IWORD (IS\") IS\" D-&gt;I I-&gt;D</p> <p>The \"I\" prefix stands for \"Instruction\" (since \"P\" and \"C\" have other meanings in Forth). ICOUNT and ITYPE are needed to display strings which have been compiled into ROM. IWORD copies the string left by WORD from Data space to Code space -- needed to build Forth word headers and ROMmed strings. D-&gt;I and I-&gt;D are equivalents of CMOVE, which copy to and from Code space.</p> <p>VARIABLEs must have addresses in Data space. So they can't use the traditional practice of putting the data immediately after the Code field. Instead, the Data space address of the data is stored after the Code field. In essence, a VARIABLE is a CONSTANT whose value is the Data space address. (Note that the traditional CONSTANT is still valid.)</p> <p>CREATEd words, and words built with CREATE...DOES&gt;, must work the same way. Here's how they look in Program space:</p> <pre><code>CODE word:   ...header... 8051 machine code \nhigh-level:  ...header... 8051 machine code \nCONSTANT:    ...header... LCALL-DOCON  value \nVARIABLE:    ...header... LCALL-DOCON  Data-adrs \nCREATEd:     ...header... LCALL-DOCON  Data-adrs\n</code></pre> <p>Note that CONSTANT must replace the value stored by CREATE, and : must \"un-allot\" both this value and the LCALL DOCON.</p> <p>S\" presents special problems. Strings defined with S\" (\"text literals\") must reside in Data space, where they can be used by such words as TYPE and EVALUATE. But we expect those strings to be part of a definition, and to exist in ROM in a ROM forth environment. We could store the string in Program space, and copy it to HERE when referenced, but the ANS document does not allow text literals to exist in this \"transient\" storage region (ref. sections 3.3.3.4 and 3.3.3.6 [ANS93]). Also, if WORD returns its string at HERE -- as in CamelForth -- text literals must not alter this transient region.</p> <p>My solution is to have S\" store the string in Code space, but permanently reserve space for it in Data space, and copy it from Code to Data when referenced. ANS Forth does not yet fully address the problems of Harvard processors; something like C's \"initialized data\" region may eventually be required.</p> <p>Since .\" strings can never be accessed by the programmer, they can be stored in Code space, using the words (IS\") and IS\". (These are the \"old\" (S\") and S\".) This adds two words to the kernel, but saves quite a bit of Data space. I plan to move the string-literal words into either the Dependency word set, or a new \"Harvard\" word set.</p>"},{"location":"Moving_Forth/moving7/#writing-to-program-space","title":"WRITING TO PROGRAM SPACE","text":"<p>The 8051 can't actually write to Program memory. There's no hardware signal for this, and no machine instruction. Under these circumstances, the CamelForth interpreter will work, but new words can't be compiled. You can get around this by causing some memory to appear in both Program and Data space. Figure 1 shows the modification to my board, an MCB8031 from Blue Ridge Micros (2505 Plymouth Road, Johnson City, TN, 37601, USA, telephone 615-335-6696, fax 615-929-3164). U1A and U1B create a new read strobe which is active for either a Program or Data fetch. EPROM is selected only when A15 is low (lower 32K), and RAM when A15 is high (upper 32K). You still can't write to EPROM, of course, but you can execute programs out of RAM! One disadvantage: this makes @ and I@ equivalent, so it's not immediately obvious if the wrong one was used somewhere.</p> <p> Figure 1</p> <p></p>"},{"location":"Moving_Forth/moving7/#next-issue","title":"NEXT ISSUE...","text":"<p>These modifications to the CamelForth high-level code are intended to be portable to either Harvard or non-Harvard (\"von Neumann\") machines. For the latter, the new Program-space words are simply equated to their Data-space equivalents, e.g. on the Z80,</p> <pre><code>IFETCH EQU FETCH  \nISTORE EQU STORE  \nITYPE EQU TYPE  \netc.\n</code></pre> <p>In the next installment I shall modify the 8051 source code to work on the 6809...thus approaching a truly portable model by successive approximation.</p>"},{"location":"Moving_Forth/moving7/#references","title":"REFERENCES","text":"<p>[ANS93] dpANS-6 draft proposed American National Standard for Information Systems - Programming Languages - Forth, June 30, 1993. \"It is distributed solely for the purpose of review and comment and should not be used as a design document. It is inappropriate to claim compatibility with this draft standard.\" Nevertheless, for the last 16 months it's all we've had to go by.</p> <ul> <li> <p>http://www.forth.com/forth-books/</p> </li> <li> <p>ftp://ftp.taygeta.com/pub/Forth/Literature/</p> </li> </ul> <p>[CUR93] Curley, Charles, Optimization Considerations, Forth Dimensions XIV:5 (Jan/Feb 1993), pp. 6-12.</p> <p>Source code for 8051 CamelForth is available on this site at http://www.camelforth.com/public_ftp/cam51-15.zip.</p>"},{"location":"Moving_Forth/moving8/","title":"MOVING FORTH 8","text":"<p>Part 8: CamelForth for the 6809 \\ by Brad Rodriguez</p> <p>This article first appeared in The Computer Journal #74 (July/August 1995).</p> <p>Finally, the last installment of \"Moving Forth!\" Here is the long-promised ANSI CamelForth for the Motorola 6809, and specifically for the Scroungmaster II processor board.</p> <p>Unlike the Z80 and 8051 CamelForth, the 6809 Forth was produced with my \"Chromium 2\" Forth metacompiler [ROD92]. Right away you'll notice two things: first, the metacompiler runs on an older Forth (F83), and so the source code is contained in 16x64 Forth \"screens\". I've converted these to an ASCII file for TCJ, but the original formatting is still evident.</p> <p>Second, source code for a Forth metacompiler looks like ordinary Forth code (with a few changes, which I'll discuss shortly). Thus the definition of <code>1+</code> is given as</p> <pre><code>CODE 1+   1 # ADDD,   NEXT   ;C\n</code></pre> <p>The assembler used is the 6809 assembler I've described previously in TCJ [ROD91].</p> <p>I typed the high-level source code directly from the already-published listings (converting to the Forth syntax in the process). Unfortunately, this was done over the space of a few days, and sometimes I worked from the Z80 listing, and sometimes the 8051... with the result that the Harvard-architecture constructs (such as I@ and IALLOT) are not consistently used in the 6809 code. This is of no consequence for the non-Harvard 6809, but I'll have to correct this before porting the Forth code to a Harvard CPU.</p> <p>Also, since I was working from published listings, I often neglected typing the detailed comments for the high-level words. For this I apologize. You can find how any word works by consulting the previous listings, but I shouldn't force you to do this.</p> <p>6809 CAMELFORTH SOURCE CODE</p> <p>The 6809 CamelForth model holds top-of-stack in D, and uses the S stack pointer for the Parameter Stack. The U stack pointer is the Return Stack Pointer, and Y is the Interpreter Pointer. X is the temporary register \"W\". The 6809 direct page pointer DPR holds the high byte of the User Pointer (the low byte is assumed to be zero).</p> <p>The memory map for a Scroungemaster II with 8K of RAM and 8K of EPROM is as follows:</p> <pre><code>6000-797Fh RAM dictionary (for new definitions)\n7980-79FFh Terminal Input Buffer\n7A00-7A7Fh User Area (USER variables)\n7A80-7AFFh Parameter Stack (grows downward)\n7B00-7B27h HOLD area (grows downward) \n7B28-7B7Fh PAD area (general purpose buffer)\n7B80-7BFFh Return Stack (grows downward)\n\nE000-FFFFh Forth kernel in EPROM\n</code></pre> <p>All of the RAM data areas are referenced to the User Pointer, whose starting value is given by UP-INIT: in this case, 7A00h. (Note the use of UP-INIT-HI for the high byte of this value) When CamelForth starts, it will set its Dictionary Pointer to DP-INIT, which must be in RAM so you can add new definitions to the Forth dictionary. These are all specified with the metacompiler's EQU directive. An EQU is like a CONSTANT, except that it is only known to the metacompiler. These EQUates take up no space in the 6809 kernel, and will not appear in the 6809 Forth's dictionary.</p> <p>DICTIONARY tells the metacompiler where to compile the code, in this case for an 8K EPROM from E000-FFFFh. The new dictionary is named \"ROM\", and then ROM is specified to select that dictionary. (If you're familiar with Forth vocabularies, you'll see a strong resemblance.)</p> <p>AKA (\"also known as\") defines a synonym for a Forth word. Since the 6809 is a non-Harvard machine, we should compile @ wherever I@ appears in the source code, and likewise for the other \"I-prefix\" (instruction-space) words. AKA will do this. These synonyms are like EQUates -- they don't appear in the 6809 dictionary.</p> <p>The metacompiler allows you to use forward references, i.e., Forth words which haven't been defined yet. (You must of course define them before you finish!) Often this is automatic, but AKA requires you to explicitly declare a forward reference with PRESUME. Thus</p> <pre><code>PRESUME WORD   AKA WORD IWORD\n</code></pre> <p>is needed to create the IWORD synonym. @ ! HERE ALLOT and the others are PRESUMEd by the metacompiler, so we don't have to do so here.</p> <p>The CODE definitions are conventional. Note that you can use</p> <pre><code>HERE EQU labelname\n</code></pre> <p>to generate a label when metacompiling. (This is a function of the metacompiler, not the assembler) Also, ASM: begins a \"fragment\" of assembler code (i.e., not part of a CODE word).</p> <p>The phrase</p> <pre><code>HERE RESOLVES name\n</code></pre> <p>is used to resolve certain forward references which are made by the metacompiler (for example, the metacompiler has to know where the code for the DOCOLON action is). You should leave these alone. Otherwise, feel free to add any CODE definitions to the source code.</p> <p>The code for defining words and control structures (IMMEDIATE words) is rather opaque. This is because these words must also perform some action while metacompiling. For example: the 6809 Forth includes the standard word CONSTANT, to define new constants. But CONSTANTs may also appear in the 6809 kernel; we may have to define a CONSTANT while metacompiling. The EMULATE: phrase instructs the metacompiler how to handle the word CONSTANT if it is encountered. This phrase is written entirely using metacompiler words, and so may appear to be total gibberish.</p> <p>Likewise, IF THEN and their ilk include the metacompiler phrases to build and resolve branches in the 6809 image. Some Forth metacompilers bury this code inside the compiler. This makes for prettier target code, but if you change the way branches work (for example), you have to perform surgery on the metacompiler. I preferred to make these actions easily changeable, and so I designed Chromium to put them in the target source code. (The most horrific examples are the definitions of TENDLOOP and TS\", which actually extend the metacompiler vocabulary in the middle of the target source code.)</p> <p>If you're new to Forth and the metacompiler, it's best to just accept these as given. \"Ordinary\" colon definitions are easy to add. Just follow the example of the rest of the 6809 source code. You can even make CREATE..DOES&gt; definitions, as long as you don't need to use them within the metacompiler.</p>"},{"location":"Moving_Forth/moving8/#future-work","title":"FUTURE WORK","text":"<p>On a 1 MHz 6809, a line of text input takes a noticeable time to process (up to 1 second at a rough estimate). This is partly becuase so much of the interpreter is written in high-level Forth, and partly because CamelForth uses a single-linked-list dictionary. These handicaps only affect compilation speed, not execution speed, but the delays can be annoying. Maybe someday I'll do an article on \"Accelerating Forth\".</p> <p>Currently, the User Pointer never changes. The reason we have a User Pointer is to support multitasking -- each task having separate user area, stacks, etc. I'll be working on this soon. I may also explore using the SM II's memory management to give each task a full 32K private dictionary. And of course, I intend to write a true multiprocessor Forth kernel using the shared bus. If I live long enough, a distributed Forth kernel using the serial ports (a la Transputer) is the logical next step.</p> <p>The source code for 6809 CamelForth, version 1.0, is available on GEnie's Forth Roundtable in the file CAM09-10.ZIP. This file includes the Chromium 2 metacompiler, complete and ready to run. You'll need a copy of F83. Then you merely type</p> <pre><code>F83 CHROMIUM.SCR\n1 LOAD\nBYE\n</code></pre> <p>This will load the metacompiler, compile the 6809 CamelForth, and write the result to an Intel hex file 6809.HEX. Note: if you're using the CP/M or Atari ST versions of F83, you'll have to edit the load screen to delete the hex file utility, since this only works under MS- DOS. I haven't yet tested Chromium 2 with CP/M or Atari ST, so if you need assistance, please contact me.</p> <p>Which reminds me: I have a new email address! You can now reach me as bj@genie.com, or just BJ if you're a GEnie user. It's a lot easier to type. [Note for web publication: my current email address is here.]</p>"},{"location":"Moving_Forth/moving8/#errata","title":"ERRATA","text":"<p>There were some errors in the Harvard memory access in CamelForth/8051. The corrected file is on GEnie as CAM51-11.ZIP. I've also uploaded the current Z80 CamelForth, CAM80-12.ZIP, which incorporates all the fixes which have been published in TCJ.</p>"},{"location":"Moving_Forth/moving8/#references","title":"REFERENCES","text":"<p>[ROD91] Rodriguez, B. J., \"B.Y.O. Assembler\", The Computer Journal [#52 (Sep/Oct 1991)] and [#54 (Jan/Feb 1992)].</p> <p>[ROD92] Rodriguez, B. J., \"Principles of Metacompilation\", Forth Dimensions XIV:3 (Sep/Oct 1992)], XIV:4 (Nov/Dec 1992), and XIV:5 (Jan/Feb 1993). Describes the \"Chromium 1\" metacompiler.</p> <p>Source code for 6809 CamelForth is available on this site at http://www.camelforth.com/public_ftp/cam09-10.zip.</p>"},{"location":"Moving_Forth/About/editor%27s%20notes/","title":"Editor's Notes","text":"<ul> <li>The github sources for this website are available at: http://github.com/efurlanm/forth</li> <li>The source markdown documents were also edited using Mark Text (http://github.com/marktext/) which is a good offline markdown document reader and also exports to PDF or HTML formats</li> <li>Material for MkDocs static site generator and theme was used to build the website</li> <li>The tables were edited in Libreoffice Calc using a custom html template, then copied and pasted into the text</li> <li>Figures were edited using Libreoffice Drawn and exported as SVG. In trial-and-error testing, what looks best on the laptop monitor and smartphone screen are approximately 7 x 3 inch figures with font size 10 or 12</li> <li>The original documents were converted from html to markdown using pandoc</li> <li>PDF files were converted to TXT using pdftotext (poppler-utils)</li> <li>The moving directory contains the original files that were converted to markdown</li> <li>Instructions to obtain a local copy of this repository: cloning-a-repository</li> </ul>"},{"location":"Moving_Forth/About/pandoc/","title":"Pandoc markdown to html","text":"<p>Example of using pandoc to convert markdown to html:</p> <pre><code>$ pandoc --self-contained --from=gfm --to=html --css=github-markdown.css --template=template.html moving1.md -o moving1.html\n</code></pre> <ul> <li> <p><code>github-markdown.css</code> comes from https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.1.0/github-markdown.css</p> </li> <li> <p><code>--self-contained</code> creates a single .html file with no external dependencies, including images</p> </li> <li> <p>the <code>template.html</code> file can be changed as needed</p> </li> <li> <p>alternatively we can use panserver to view the markdown files: http://github.com/Marfisc/panserver/</p> </li> </ul>"},{"location":"Moving_Forth/MVP-Forth/","title":"MVP-Forth for the Apple II","text":"<p>I downloaded the files from</p> <p>https://mirrors.apple2.org.za/ftp.apple.asimov.net/images/programming/forth/</p> <p>and I tried to extract the content using CiderPress</p> <p>https://a2ciderpress.com/</p> <p>but I only managed to extract the disk <code>MVP Forth v1.0103.03 (1983)(Mountain View Press) - Assembly Source Code.dsk</code> and I have no idea how to extract the others.</p>"},{"location":"assembly/","title":"Assembly","text":"<p>My personal notes about the Assembly Programming Language.</p>"},{"location":"assembly/#links-of-interest","title":"Links of interest","text":"<ul> <li>Intel manuals. https://software.intel.com/en-us/articles/intel-sdm</li> <li>x86 and amd64 instruction reference. https://www.felixcloutier.com/x86/index.html</li> <li>JORGENSEN, E. x86-64 Assembly Language Programming with Ubuntu. http://www.egr.unlv.edu/~ed/assembly64.pdf</li> <li>Boldyshev &amp; Rideau. Linux Assembly HOWTO. 2000. http://www.mit.edu/afs.new/athena/system/rhlinux/redhat-6.2-docs/HOWTOS/other-formats/pdf/Assembly-HOWTO.pdf</li> <li>Ray Toal. x86 Assembly Language Programming. https://cs.lmu.edu/~ray/notes/x86assembly/</li> </ul>"},{"location":"assembly/#some-references","title":"Some references","text":"<ul> <li>HOEY, J. V. Beginning x64 Assembly Programming. 2019.</li> <li>MILLER, A. R. Assembly Language Techniques for the IBM PC. 1986.</li> </ul> <p>Last edited: 2024-11-23</p>"},{"location":"assembly/assembly/","title":"Bare metal x86_64 Assembly Language on *nix 64","text":"<p>Using the NASM assembler (https://nasm.us/)</p> <p>To install on Fedora: # dnf -y install nasm</p> <ul> <li>SYSCALL instruction jumps to operating system services. To use, first put the system call number in RAX, then the arguments, if any, in RDI, RSI, RDX, R10, R8, and R9, respectively. </li> <li>call number 60 exit a process.</li> </ul>"},{"location":"assembly/assembly/#hello-world-example","title":"Hello world example","text":""},{"location":"assembly/assembly/#write-the-source-file","title":"Write the source file","text":"<pre><code>%%writefile hello.asm\n; hello.asm\n; source: https://cs.lmu.edu/~ray/notes/x86assembly/\n            global      _start\n            section     .text\n_start:     mov         rax, 1          ; system call for write\n            mov         rdi, 1          ; file handle 1 is stdout\n            mov         rsi, message    ; address of string to output\n            mov         rdx, 14         ; number of bytes\n            syscall                     ; invoke operating system to do the write\n            mov         rax, 60         ; system call for exit\n            xor         rdi, rdi        ; exit code 0\n            syscall                     ; invoke operating system to exit\n\n            section     .data\nmessage:    db          \"Hello, world!\", 10   ; note the newline (10) at the end\n</code></pre> <pre><code>Overwriting hello.asm\n</code></pre>"},{"location":"assembly/assembly/#assemble-and-show-the-listing-file","title":"Assemble and show the listing file","text":"<pre><code>! nasm -f elf64 hello.asm -l hello.lst\n</code></pre> <pre><code>! cat hello.lst\n</code></pre> <pre><code>     1                                  ; hello.asm\n     2                                  ; source: https://cs.lmu.edu/~ray/notes/x86assembly/\n     3                                              global      _start\n     4                                              section     .text\n     5 00000000 B801000000              _start:     mov         rax, 1          ; system call for write\n     6 00000005 BF01000000                          mov         rdi, 1          ; file handle 1 is stdout\n     7 0000000A 48BE-                               mov         rsi, message    ; address of string to output\n     7 0000000C [0000000000000000] \n     8 00000014 BA0E000000                          mov         rdx, 14         ; number of bytes\n     9 00000019 0F05                                syscall                     ; invoke operating system to do the write\n    10 0000001B B83C000000                          mov         rax, 60         ; system call for exit\n    11 00000020 4831FF                              xor         rdi, rdi        ; exit code 0\n    12 00000023 0F05                                syscall                     ; invoke operating system to exit\n    13                                  \n    14                                              section     .data\n    15 00000000 48656C6C6F2C20776F-     message:    db          \"Hello, world!\", 10   ; note the newline (10) at the end\n    15 00000009 726C64210A\n</code></pre> <p>Columns, in sequence: * sequential line number, only for reference * address in memory * bytes (data or instruction) * label * opcode * operand, register, data, other information * comments</p>"},{"location":"assembly/assembly/#link","title":"Link","text":"<pre><code>! ld --verbose -o hello.out hello.o\n</code></pre> <pre><code>GNU ld version 2.35-18.fc33\n  Supported emulations:\n   elf_x86_64\n   elf32_x86_64\n   elf_i386\n   elf_iamcu\n   elf_l1om\n   elf_k1om\n   i386pep\n   i386pe\n   elf64bpf\nusing internal linker script:\n==================================================\n/* Script for -z combreloc -z separate-code */\n/* Copyright (C) 2014-2020 Free Software Foundation, Inc.\n   Copying and distribution of this script, with or without modification,\n   are permitted in any medium without royalty provided the copyright\n   notice and this notice are preserved.  */\nOUTPUT_FORMAT(\"elf64-x86-64\", \"elf64-x86-64\",\n          \"elf64-x86-64\")\nOUTPUT_ARCH(i386:x86-64)\nENTRY(_start)\nSEARCH_DIR(\"=/usr/x86_64-redhat-linux/lib64\"); SEARCH_DIR(\"=/usr/lib64\"); SEARCH_DIR(\"=/usr/local/lib64\"); SEARCH_DIR(\"=/lib64\"); SEARCH_DIR(\"=/usr/x86_64-redhat-linux/lib\"); SEARCH_DIR(\"=/usr/local/lib\"); SEARCH_DIR(\"=/lib\"); SEARCH_DIR(\"=/usr/lib\");\nSECTIONS\n{\n  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x400000)); . = SEGMENT_START(\"text-segment\", 0x400000) + SIZEOF_HEADERS;\n  .interp         : { *(.interp) }\n  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n  .hash           : { *(.hash) }\n  .gnu.hash       : { *(.gnu.hash) }\n  .dynsym         : { *(.dynsym) }\n  .dynstr         : { *(.dynstr) }\n  .gnu.version    : { *(.gnu.version) }\n  .gnu.version_d  : { *(.gnu.version_d) }\n  .gnu.version_r  : { *(.gnu.version_r) }\n  .rela.dyn       :\n    {\n      *(.rela.init)\n      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n      *(.rela.fini)\n      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n      *(.rela.ctors)\n      *(.rela.dtors)\n      *(.rela.got)\n      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n      *(.rela.ldata .rela.ldata.* .rela.gnu.linkonce.l.*)\n      *(.rela.lbss .rela.lbss.* .rela.gnu.linkonce.lb.*)\n      *(.rela.lrodata .rela.lrodata.* .rela.gnu.linkonce.lr.*)\n      *(.rela.ifunc)\n    }\n  .rela.plt       :\n    {\n      *(.rela.plt)\n      PROVIDE_HIDDEN (__rela_iplt_start = .);\n      *(.rela.iplt)\n      PROVIDE_HIDDEN (__rela_iplt_end = .);\n    }\n  . = ALIGN(CONSTANT (MAXPAGESIZE));\n  .init           :\n  {\n    KEEP (*(SORT_NONE(.init)))\n  }\n  .plt            : { *(.plt) *(.iplt) }\n.plt.got        : { *(.plt.got) }\n.plt.sec        : { *(.plt.sec) }\n  .text           :\n  {\n    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n    *(.text.exit .text.exit.*)\n    *(.text.startup .text.startup.*)\n    *(.text.hot .text.hot.*)\n    *(SORT(.text.sorted.*))\n    *(.text .stub .text.* .gnu.linkonce.t.*)\n    /* .gnu.warning sections are handled specially by elf.em.  */\n    *(.gnu.warning)\n  }\n  .fini           :\n  {\n    KEEP (*(SORT_NONE(.fini)))\n  }\n  PROVIDE (__etext = .);\n  PROVIDE (_etext = .);\n  PROVIDE (etext = .);\n  . = ALIGN(CONSTANT (MAXPAGESIZE));\n  /* Adjust the address for the rodata segment.  We want to adjust up to\n     the same address within the page on the next page up.  */\n  . = SEGMENT_START(\"rodata-segment\", ALIGN(CONSTANT (MAXPAGESIZE)) + (. &amp; (CONSTANT (MAXPAGESIZE) - 1)));\n  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n  .rodata1        : { *(.rodata1) }\n  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n  /* Adjust the address for the data segment.  We want to adjust up to\n     the same address within the page on the next page up.  */\n  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n  /* Exception handling  */\n  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n  /* Thread Local Storage sections  */\n  .tdata      :\n   {\n     PROVIDE_HIDDEN (__tdata_start = .);\n     *(.tdata .tdata.* .gnu.linkonce.td.*)\n   }\n  .tbss       : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n  .preinit_array    :\n  {\n    PROVIDE_HIDDEN (__preinit_array_start = .);\n    KEEP (*(.preinit_array))\n    PROVIDE_HIDDEN (__preinit_array_end = .);\n  }\n  .init_array    :\n  {\n    PROVIDE_HIDDEN (__init_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n    PROVIDE_HIDDEN (__init_array_end = .);\n  }\n  .fini_array    :\n  {\n    PROVIDE_HIDDEN (__fini_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n    PROVIDE_HIDDEN (__fini_array_end = .);\n  }\n  .ctors          :\n  {\n    /* gcc uses crtbegin.o to find the start of\n       the constructors, so we make sure it is\n       first.  Because this is a wildcard, it\n       doesn't matter if the user does not\n       actually link against crtbegin.o; the\n       linker won't look for a file to match a\n       wildcard.  The wildcard also means that it\n       doesn't matter which directory crtbegin.o\n       is in.  */\n    KEEP (*crtbegin.o(.ctors))\n    KEEP (*crtbegin?.o(.ctors))\n    /* We don't want to include the .ctor section from\n       the crtend.o file until after the sorted ctors.\n       The .ctor section from the crtend file contains the\n       end of ctors marker and it must be last */\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n    KEEP (*(SORT(.ctors.*)))\n    KEEP (*(.ctors))\n  }\n  .dtors          :\n  {\n    KEEP (*crtbegin.o(.dtors))\n    KEEP (*crtbegin?.o(.dtors))\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n    KEEP (*(SORT(.dtors.*)))\n    KEEP (*(.dtors))\n  }\n  .jcr            : { KEEP (*(.jcr)) }\n  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n  .dynamic        : { *(.dynamic) }\n  .got            : { *(.got) *(.igot) }\n  . = DATA_SEGMENT_RELRO_END (SIZEOF (.got.plt) &gt;= 24 ? 24 : 0, .);\n  .got.plt        : { *(.got.plt) *(.igot.plt) }\n  .data           :\n  {\n    *(.data .data.* .gnu.linkonce.d.*)\n    SORT(CONSTRUCTORS)\n  }\n  .data1          : { *(.data1) }\n  _edata = .; PROVIDE (edata = .);\n  . = .;\n  __bss_start = .;\n  .bss            :\n  {\n   *(.dynbss)\n   *(.bss .bss.* .gnu.linkonce.b.*)\n   *(COMMON)\n   /* Align here to ensure that the .bss section occupies space up to\n      _end.  Align after .bss to ensure correct alignment even if the\n      .bss section disappears because there are no input sections.\n      FIXME: Why do we need it? When there is no .bss section, we do not\n      pad the .data section.  */\n   . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  .lbss   :\n  {\n    *(.dynlbss)\n    *(.lbss .lbss.* .gnu.linkonce.lb.*)\n    *(LARGE_COMMON)\n  }\n  . = ALIGN(64 / 8);\n  . = SEGMENT_START(\"ldata-segment\", .);\n  .lrodata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. &amp; (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.lrodata .lrodata.* .gnu.linkonce.lr.*)\n  }\n  .ldata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. &amp; (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.ldata .ldata.* .gnu.linkonce.l.*)\n    . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  . = ALIGN(64 / 8);\n  _end = .; PROVIDE (end = .);\n  . = DATA_SEGMENT_END (.);\n  /* Stabs debugging sections.  */\n  .stab          0 : { *(.stab) }\n  .stabstr       0 : { *(.stabstr) }\n  .stab.excl     0 : { *(.stab.excl) }\n  .stab.exclstr  0 : { *(.stab.exclstr) }\n  .stab.index    0 : { *(.stab.index) }\n  .stab.indexstr 0 : { *(.stab.indexstr) }\n  .comment       0 : { *(.comment) }\n  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n  /* DWARF debug sections.\n     Symbols in the DWARF debugging sections are relative to the beginning\n     of the section so we begin them at 0.  */\n  /* DWARF 1 */\n  .debug          0 : { *(.debug) }\n  .line           0 : { *(.line) }\n  /* GNU DWARF 1 extensions */\n  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n  .debug_sfnames  0 : { *(.debug_sfnames) }\n  /* DWARF 1.1 and DWARF 2 */\n  .debug_aranges  0 : { *(.debug_aranges) }\n  .debug_pubnames 0 : { *(.debug_pubnames) }\n  /* DWARF 2 */\n  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n  .debug_abbrev   0 : { *(.debug_abbrev) }\n  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n  .debug_frame    0 : { *(.debug_frame) }\n  .debug_str      0 : { *(.debug_str) }\n  .debug_loc      0 : { *(.debug_loc) }\n  .debug_macinfo  0 : { *(.debug_macinfo) }\n  /* SGI/MIPS DWARF 2 extensions */\n  .debug_weaknames 0 : { *(.debug_weaknames) }\n  .debug_funcnames 0 : { *(.debug_funcnames) }\n  .debug_typenames 0 : { *(.debug_typenames) }\n  .debug_varnames  0 : { *(.debug_varnames) }\n  /* DWARF 3 */\n  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n  .debug_ranges   0 : { *(.debug_ranges) }\n  /* DWARF Extension.  */\n  .debug_macro    0 : { *(.debug_macro) }\n  .debug_addr     0 : { *(.debug_addr) }\n  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n}\n\n\n==================================================\nld: mode elf_x86_64\nattempt to open hello.o succeeded\nhello.o\n</code></pre>"},{"location":"assembly/assembly/#show-generated-files","title":"Show generated files","text":"<pre><code>! ls\n</code></pre> <pre><code>assembly.ipynb      hello.f90         hello.lst  hello.s\nfortran-assembly.ipynb  hello.f90.004t.original   hello.o    README.md\nhello.asm       hello.f90.235t.optimized  hello.out\n</code></pre>"},{"location":"assembly/assembly/#run","title":"Run","text":"<pre><code>! ./hello.out\n</code></pre> <pre><code>Hello, world!\n</code></pre>"},{"location":"assembly/assembly/#readelf","title":"readelf","text":"<pre><code>! readelf -all hello.o\n</code></pre> <pre><code>ELF Header:\n  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 \n  Class:                             ELF64\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              REL (Relocatable file)\n  Machine:                           Advanced Micro Devices X86-64\n  Version:                           0x1\n  Entry point address:               0x0\n  Start of program headers:          0 (bytes into file)\n  Start of section headers:          64 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               64 (bytes)\n  Size of program headers:           0 (bytes)\n  Number of program headers:         0\n  Size of section headers:           64 (bytes)\n  Number of section headers:         7\n  Section header string table index: 3\n\nSection Headers:\n  [Nr] Name              Type             Address           Offset\n       Size              EntSize          Flags  Link  Info  Align\n  [ 0]                   NULL             0000000000000000  00000000\n       0000000000000000  0000000000000000           0     0     0\n  [ 1] .text             PROGBITS         0000000000000000  00000200\n       0000000000000025  0000000000000000  AX       0     0     16\n  [ 2] .data             PROGBITS         0000000000000000  00000230\n       000000000000000e  0000000000000000  WA       0     0     4\n  [ 3] .shstrtab         STRTAB           0000000000000000  00000240\n       0000000000000032  0000000000000000           0     0     1\n  [ 4] .symtab           SYMTAB           0000000000000000  00000280\n       0000000000000090  0000000000000018           5     5     8\n  [ 5] .strtab           STRTAB           0000000000000000  00000310\n       000000000000001a  0000000000000000           0     0     1\n  [ 6] .rela.text        RELA             0000000000000000  00000330\n       0000000000000018  0000000000000018           4     1     8\nKey to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),\n  L (link order), O (extra OS processing required), G (group), T (TLS),\n  C (compressed), x (unknown), o (OS specific), E (exclude),\n  l (large), p (processor specific)\n\nThere are no section groups in this file.\n\nThere are no program headers in this file.\n\nThere is no dynamic section in this file.\n\nRelocation section '.rela.text' at offset 0x330 contains 1 entry:\n  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n00000000000c  000300000001 R_X86_64_64       0000000000000000 .data + 0\n\nThe decoding of unwind sections for machine type Advanced Micro Devices X86-64 is not currently supported.\n\nSymbol table '.symtab' contains 6 entries:\n   Num:    Value          Size Type    Bind   Vis      Ndx Name\n     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND \n     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS hello.asm\n     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 \n     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    2 \n     4: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    2 message\n     5: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT    1 _start\n\nNo version information found in this file.\n</code></pre>"},{"location":"assembly/assembly/#read-the-data-section-in-hex","title":"read the .data section in hex","text":"<pre><code>! readelf -x '.data'  hello.o\n</code></pre> <pre><code>Hex dump of section '.data':\n  0x00000000 48656c6c 6f2c2077 6f726c64 210a     Hello, world!.\n</code></pre>"},{"location":"assembly/assembly/#objdump","title":"objdump","text":"<pre><code>! objdump -d hello.o\n</code></pre> <pre><code>hello.o:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 &lt;_start&gt;:\n   0:   b8 01 00 00 00          mov    $0x1,%eax\n   5:   bf 01 00 00 00          mov    $0x1,%edi\n   a:   48 be 00 00 00 00 00    movabs $0x0,%rsi\n  11:   00 00 00 \n  14:   ba 0e 00 00 00          mov    $0xe,%edx\n  19:   0f 05                   syscall \n  1b:   b8 3c 00 00 00          mov    $0x3c,%eax\n  20:   48 31 ff                xor    %rdi,%rdi\n  23:   0f 05                   syscall\n</code></pre>"},{"location":"assembly/assembly/#asm-c-library","title":"asm + C library","text":"<pre><code>%%writefile hc.asm\n    global  main\n    extern  puts\n\n    section .text\nmain:                     ; This is called by the C library startup code\n    mov     rdi, message  ; First integer|pointer argument in rdi\n    call    puts          ; puts(message)\n    ret                   ; Return from main back into C library wrapper\nmessage:\n    db      \"Hello, world!\", 0    ; strings must be terminated with 0\n</code></pre> <pre><code>Overwriting hc.asm\n</code></pre>"},{"location":"assembly/assembly/#assemble-using-nasm","title":"Assemble using NASM","text":"<pre><code>! nasm -f elf64 hc.asm -l hc.lst\n</code></pre> <pre><code>! cat hc.lst\n</code></pre> <pre><code>     1                                      global  main\n     2                                      extern  puts\n     3                                  \n     4                                      section .text\n     5                                  main:                     ; This is called by the C library startup code\n     6 00000000 48BF-                       mov     rdi, message  ; First integer|pointer argument in rdi\n     6 00000002 [1000000000000000] \n     7 0000000A E8(00000000)                call    puts          ; puts(message)\n     8 0000000F C3                          ret                   ; Return from main back into C library wrapper\n     9                                  message:\n    10 00000010 48656C6C6F2C20776F-         db      \"Hello, world!\", 0    ; strings must be terminated with 0\n    10 00000019 726C642100\n</code></pre>"},{"location":"assembly/assembly/#link-using-gcc","title":"Link using gcc","text":"<pre><code>! gcc -o hc.out hc.o\n</code></pre>"},{"location":"assembly/assembly/#run_1","title":"Run","text":"<pre><code>! ./hc.out\n</code></pre> <pre><code>Hello, world!\n</code></pre>"},{"location":"assembly/assembly/#asm-f90","title":"asm &amp; f90","text":"<p>Reference: https://forum.nasm.us/index.php?topic=2448.15</p> <pre><code>%%writefile hcfg.asm\n            global      hello_\n            section     .text\nhello_:     mov         rax, 1          ; system call for write\n            mov         rdi, 1          ; file handle 1 is stdout\n            mov         rsi, message    ; address of string to output\n            mov         rdx, 20         ; number of bytes\n            syscall                     ; invoke operating system to do the write\n            mov         rax, 60         ; system call for exit\n            xor         rdi, rdi        ; exit code 0\n            syscall                     ; invoke operating system to exit\n\n            section     .data\nmessage:    db          \" asm: Hello, world!\", 10   ; note the newline (10) at the end\n</code></pre> <pre><code>Overwriting hcfg.asm\n</code></pre> <pre><code>! nasm -f elf64 hcfg.asm\n</code></pre> <pre><code>%%writefile hcfg.f90\nexternal hello\nprint*, \"f90: Hello, world!\"\ni = hello()\nend\n</code></pre> <pre><code>Overwriting hcfg.f90\n</code></pre> <pre><code>! gfortran -o hcfg.out hcfg.f90 hcfg.o\n</code></pre> <pre><code>! ./hcfg.out\n</code></pre> <pre><code> f90: Hello, world!\n asm: Hello, world!\n</code></pre> <pre><code>\n</code></pre>"},{"location":"assembly/small-assembly/","title":"Assembly small executable","text":"<p>Last edited: 2023-12-11</p> <p>Some exercises to try to better understand the creation of executables by an Assembler.</p> <pre><code>%%writefile hello.asm\nGLOBAL  _start \n\n; Code goes in the text section\nSECTION .text\n_start: mov rax,1           ; 'write' system call = 1\n        mov rdi,1           ; file descriptor 1 = STDOUT\n        mov rsi,hello       ; string to write\n        mov rdx,hLen        ; length of string to write\n        syscall             ; call the kernel\n\n        ; Terminate program\n        mov rax,60          ; 'exit' system call\n        mov rdi,42          ; exit with error code 42\n        syscall             ; call the kernel\n\n; Define variables in the data section\nSECTION .rodata\nhello:  db \"Hello world!\",10\nhLen:   equ $-hello\n</code></pre> <pre><code>Overwriting hello.asm\n</code></pre> <pre><code>! wc -c hello.asm\n</code></pre> <pre><code>604 hello.asm\n</code></pre> <pre><code>! nasm -f elf64 hello.asm\n</code></pre> <pre><code>! wc -c hello.o\n</code></pre> <pre><code>880 hello.o\n</code></pre> <pre><code>! ld hello.o\n</code></pre> <pre><code>! wc -c a.out\n</code></pre> <pre><code>8872 a.out\n</code></pre> <pre><code>! ./a.out ; echo $?\n</code></pre> <pre><code>Hello world!\n42\n</code></pre> <pre><code>! objdump -s a.out\n</code></pre> <pre><code>a.out:     file format elf64-x86-64\n\nContents of section .text:\n 401000 b8010000 00bf0100 000048be 00204000  ..........H.. @.\n 401010 00000000 ba0d0000 000f05b8 3c000000  ............&lt;...\n 401020 bf2a0000 000f05                      .*.....         \nContents of section .rodata:\n 402000 48656c6c 6f20776f 726c6421 0a        Hello world!.\n</code></pre> <pre><code>! objdump -d a.out\n</code></pre> <pre><code>a.out:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000401000 &lt;_start&gt;:\n  401000:   b8 01 00 00 00          mov    $0x1,%eax\n  401005:   bf 01 00 00 00          mov    $0x1,%edi\n  40100a:   48 be 00 20 40 00 00    movabs $0x402000,%rsi\n  401011:   00 00 00 \n  401014:   ba 0d 00 00 00          mov    $0xd,%edx\n  401019:   0f 05                   syscall \n  40101b:   b8 3c 00 00 00          mov    $0x3c,%eax\n  401020:   bf 2a 00 00 00          mov    $0x2a,%edi\n  401025:   0f 05                   syscall\n</code></pre>"},{"location":"assembly/small-assembly/#references","title":"References","text":"<ul> <li>https://www.devdungeon.com/content/hello-world-nasm-assembler</li> </ul>"},{"location":"blog/","title":"My Personal Blog","text":""},{"location":"blog/2024/01/24/inpe-general-regulations/","title":"INPE General Regulations","text":"<p>INPE's General Regulations 2024 (approved on 09/04/2023) in searchable PDF format:</p> <ul> <li>Regimento_Geral_20230904.pdf (in Portuguese)</li> </ul> <p>The original PDF file containing INPE's General Regulations 2024 has an annoying problem that is not searchable and is not possible to select text. What I used to fix it was:</p> <pre><code>$ pdfsandwich -lang por &lt;in.pdf&gt; -o &lt;out.pdf&gt;\n$ gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.7 -q -o &lt;out.pdf&gt; &lt;in.pdf&gt;\n$ ocrmypdf -l=por -s -O=3 --jbig2-lossy --output-type=pdf &lt;in.pdf&gt; &lt;out.pdf&gt;\n$ qpdf --linearize &lt;in.pdf&gt; &lt;out.pdf&gt;\n</code></pre>"},{"location":"blog/2024/05/29/loss-landscape/","title":"Loss Landscape","text":"<p>Very nice WebGL application to visualize the loss landscape for some common ANN. Currently features the models Resnet-20 (short/no-short), Resnet-56 (short/no-short), Vgg 16 and DenseNet 121.</p> <p>http://www.telesens.co/loss-landscape-viz/viewer.html</p> <p>More info:</p> <ul> <li>http://www.telesens.co/2019/01/16/neural-network-loss-visualization</li> <li>http://arxiv.org/abs/1712.09913</li> <li>http://mathformachines.com/posts/visualizing-the-loss-landscape</li> <li>http://github.com/tomgoldstein/loss-landscape</li> <li>http://github.com/marcellodebernardi/loss-landscapes</li> </ul>"},{"location":"blog/2024/01/25/microcloud/","title":"MicroCloud","text":"<p>MicroCloud is an interesting project that, through lightweight virtualization and few host computers, allows you to quickly generate a cluster of several computing nodes, requiring few resources and allowing you to use common available hardware at home, such as Raspberry Pi and laptops.</p> <p>https://canonical.com/microcloud</p> <p>Its sufficiently small to function on a developer laptop. It can be utilized for safely experimenting with new technologies, simulating or testing complicated infrastructure processes, simulating how your workloads would operate in production, and creating lightweight, restricted disposable testing environments.</p> <p>It is a simple method to start an LXD cluster with high availability. It makes use of snap packages, has the ability to automatically configure LXD and Ceph on a group of servers, and uses mDNS to find other servers on the network automatically. This allows you to run a single command on one machine to build an entire cluster.</p>","tags":["LXC","Conteiner"]},{"location":"blog/2024/05/24/nn-optimization/","title":"Neural Network Optimization","text":"<p>Good post by Matthew Stewart's \"Neural Network Optimization\" from June 27, 2019. https://towardsdatascience.com/neural-network-optimization-7ca72d4db3e0</p> <p>Optimization</p> <p>The equation below represents the average gradient of the loss function with respect to the model parameters, computed over all training samples</p> <p>$$g={\\frac{1}{m}}\\sum_{i}\\nabla_{\\theta}L(f(x^{(i)};\\theta),y^{(i)})$$</p> <p>where:</p> <ul> <li>$g$ is the gradient of the loss function with respect to the model parameters $\\theta$. The gradient vector is a vector that points in the direction of the steepest increase in a function.</li> <li>$m$ is the total number of training samples in the dataset. It\u2019s the denominator in the expression, indicating that we\u2019re averaging the gradients over all samples.</li> <li>$\\sum_{i}$ indicates that we\u2019re summing over all training samples. The index $i$ ranges from $1$ to $m$.</li> <li>$\\nabla_\\theta$ is the gradient operator with respect to the model parameters $\\theta$. It computes the partial derivatives of the loss function with respect to each parameter.</li> <li>$L(f(x^{(i)};\\theta),y^{(i)})$ represents the loss function evaluated for the $i$-th training sample. It measures the discrepancy between the predicted output $f(x^{(i)};\\theta)$ and the actual target $y^{(i)}$.</li> </ul>"},{"location":"blog/2024/02/22/parallel-spectral/","title":"Parallel Spectral Numerical Methods","text":"<p>Very nice Wikibook based on Parallel Spectral Numerical Methods by Chen et al. (2012) from University of Michigan. Discusses how to solve ordinary differential equations (ODE) and partial differential equations (PDE) using separation of variables. Next, it introduces numerical time-stepping schemes that can be used to solve ODEs and PDEs. This is followed by an introduction to pseudo spectral methods through an overview of the discrete Fourier Transform (DFT) and the Fast Fourier Transform (FFT) algorithm that is used to quickly calculate the DFT. Finally it will combine all of these to solve a couple of different PDEs first in a serial setting and then in a parallel setting. The programs will use Matlab and Fortran. A Python implementation of some of the Matlab programs is also provided.</p> <p>https://en.wikibooks.org/wiki/Parallel_Spectral_Numerical_Methods/</p>"},{"location":"blog/2024/02/06/periodicals-from-capes/","title":"Periodicals from CAPES","text":"<p>I did a quick search on the CAPES website:</p> <p>https://www-periodicos-capes-gov-br.ezl.periodicos.capes.gov.br/index.php/acervo/lista-a-z-periodicos.html</p> <p>Searching for open, peer-reviewed, national, multidisciplinary journals, and I selected some that I found interesting. The first line of each item corresponds to the title, [ISSN] and classification; the second corresponds to the website, and the third is the periodicity:</p> <ul> <li> <p>Revista Ci\u00eancia, Tecnologia &amp; Ambiente [2359-6643] B4 </p> <ul> <li>https://www.revistacta.ufscar.br/index.php/revistacta</li> <li>Federal University of S\u00e3o Carlos (UFSCAR)</li> <li>Rolling Pass</li> </ul> </li> <li> <p>Revista Profiscientia [1806-0285] B3</p> <ul> <li>https://profiscientia.ifmt.edu.br/profiscientia/index.php/profiscientia</li> <li>Federal Institute of Mato Grosso (IFMT)</li> <li>Rolling Pass</li> </ul> </li> <li> <p>Ci\u00eancia &amp; Tecnologia [2178-9436] B3</p> <ul> <li>https://citec.fatecjaboticabal.edu.br/index.php/citec</li> <li>Fatec Jaboticabal</li> <li>Rolling Pass</li> </ul> </li> <li> <p>Somma: Revista Cient\u00edfica do Instituto Federal do Piau\u00ed [2447-701X] B2</p> <ul> <li>https://revistas.ifpi.edu.br/index.php/somma/index</li> <li>Federal Institute of Piau\u00ed (IFPI)</li> <li>Rolling Pass</li> </ul> </li> <li> <p>Abak\u00f3s [2316-9451] A4</p> <ul> <li>https://periodicos.pucminas.br/index.php/abakos/</li> <li>PUC Minas</li> <li>Semiannual, 2023-11, 2023-06</li> </ul> </li> <li> <p>Essentia: Revista de Cultura, Ci\u00eancia e Tecnologia [1516-6406] B3</p> <ul> <li>https://essentia.uvanet.br/index.php/ESSENTIA</li> <li>State University of Vale do Acara\u00fa (UVA)</li> <li>Semiannual</li> </ul> </li> <li> <p>Journal of the Brazilian Computer Society [0104-6500] A2</p> <ul> <li>https://sol.sbc.org.br/journals/index.php/jbcs/</li> <li>Quarterly</li> </ul> </li> <li> <p>Revista Brasileira de Computa\u00e7\u00e3o Aplicada [2176-6649] B3</p> <ul> <li>University of Passo Fundo (UPF)</li> <li>Quarterly</li> </ul> </li> <li> <p>Revista de Inform\u00e1tica Te\u00f3rica e Aplicada [0103-4308] B3</p> <ul> <li>Federal University of Rio Grande do Sul (UFRGS)</li> <li>Semiannual</li> </ul> </li> </ul>","tags":["Qualis"]},{"location":"blog/2024/05/13/pinn-inverse-pereira/","title":"Using PINN for Inverse Problems","text":"<p>Last edited: 2024-05-28</p> <p>My personal notes about the seminar Using Physics-informed Neural Networks for Inverse Problems by Jo\u00e3o Pereira - IMPA at National Scientific Computing Laboratory (LNCC) on 2024-05-13.</p> <p>Presentation generated from the video: PINN-Presentation-Pereira.pdf (in Portuguese)</p> <p>The seminar mainly deals with two published articles, and also a third that has not yet been published:</p> <p>Hasan, A., Pereira, J. M., Ravier, R., Farsiu, S., &amp; Tarokh, V. (2019). Learning Partial Differential Equations from Data Using Neural Networks. http://arxiv.org/abs/1910.10262</p> <p>Hasan, A., M. Pereira, J., Farsiu, S., &amp; Tarokh, V. (2022). Identifying Latent Stochastic Differential Equations. IEEE Transactions on Signal Processing, 70, 89\u2013104. https://doi.org/10.1109/TSP.2021.3131723</p> <p>Bizzi, A., L. Nissenbaum, Pereira, J. M. (In Preparation) Neural Conjugate Flows: a Physics-Informed Architecture with Differential Flow Structure.</p> <ul> <li>Code:<ul> <li>http://github.com/alluly/pde-estimation</li> <li>http://github.com/alluly/ident-latent-sde</li> </ul> </li> </ul>"},{"location":"blog/2024/05/13/pinn-inverse-pereira/#pinn","title":"PINN","text":"<ul> <li>The various PDEs can be seen as a simple linear combination</li> </ul> Equation PDE Wave (1D) $u_{tt} - u_{xx} = 0$ Heat (1D) $u_{t} - u_{xx} = 0$ Helmholtz (2D) $u_{xx} + u_{yy} + u= 0$ Burgers (1D) $u_{t} + uu_{x} = 0$ Korteweg-de Vries $u_{t} - 6uu_{x} + u_{xxx}= 0$ <ul> <li> <p>The problem is to determine the PDE that best represents the data</p> </li> <li> <p>Initially, a set of possible derivative terms is estimated</p> </li> </ul> <p></p> <ul> <li> <p>Let $p_1, \u2026, p_k$ be sample random points in the domain</p> </li> <li> <p>If $u$ is a solution of the PDE</p> </li> </ul> <p>$a_1 u + a_2 u_{xx} + a_3 uu_x + a_4 u_{xxx} + a_5 u_t = 0$</p> <ul> <li>For all $p_1, \u2026, p_k$</li> </ul> <p>$a_1 u (p_k) + a_2 u_{xx} (p_k) + a_3 u (p_k) u_x(p_k) + a_4 u_{xxx} (p_k) + a_5 u_t (p_k) = 0 $</p> <ul> <li>In matrix form:</li> </ul> <p>$\\underbrace{ \\left[ \\begin{array}{c c c c} u(p_1) &amp; u_{x x}(p_1) &amp; u(p_1)u_x(p_1)&amp; u_{x x x}(p_1) &amp; u_t(p_1) \\\\  \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots \\\\  u(p_k) &amp; u_{x x}(p_k) &amp; u(p_k)u_x(p_k) &amp; u_{x x x}(p_k) &amp; u_t(p_k) \\end{array}  \\right] }_{\\mathcal{M}_u(p)} \\left[ \\begin{array}{c} a_1 \\\\ \\vdots \\\\ a_5  \\end{array}  \\right]=0$</p> <ul> <li>The vector $a = (a_1, ..., a_5)$ is in the null space of $\\mathcal{M}_u(p)$</li> <li>In matrix form: $\\mathcal{M}_u(p) a = 0$</li> <li>The null space vector is a singular vector with singular value 0</li> <li>The null space vector (also known as the null vector) refers to the zero vector in the context of linear algebra</li> <li>The null space vector is simply the zero vector itself: 0</li> <li>It is the unique vector that belongs to the null space of any matrix</li> <li>When we say null space vector, we are referring to the specific vector v that satisfies the condition Av = 0 for a given matrix A</li> <li>Let's think about optimization</li> <li>Calculate the smallest singular value using the min-max principle</li> </ul> <p>$ \\underset{ a }{ \\min } \\quad | \\mathcal{M}_u(p) a |_2^2 $</p> <p>subject to $ \\quad | a |_2 = 1 \\quad $ (Euclidean norm)</p> <p>$ | a |_2 = \\sqrt{a_1^2 + \\cdots + a_n^2} $</p> <ul> <li> <p>Bringing together the losses</p> </li> <li> <p>Fitting the neural network $\\hat{u}(\\cdot;\\theta)$</p> </li> </ul> <p></p> <ul> <li>Learning the PDE</li> </ul> <p></p> <ul> <li>Encourage law sparsity</li> </ul> <p></p> <ul> <li>Training</li> </ul> <p></p> <ul> <li>Minimizing $\\mathcal{L}_{PDE} (\\theta,a)$ in terms of $\\theta$ enforces that the ANN is a solution to the  PDE being learned.</li> </ul>"},{"location":"blog/2024/05/13/pinn-inverse-pereira/#stochastic-pinn","title":"Stochastic PINN","text":"<ul> <li>(in construction)</li> </ul>"},{"location":"blog/2024/05/13/pinn-inverse-pereira/#links-of-interest","title":"Links of interest","text":"<ul> <li>I WANT SCIENCE. Artificial Intelligence and Physics: Solving Inverse Problems with Neural Networks (in Portuguese).</li> <li>Schedule of the event where the lecture was given (in Portuguese).</li> </ul>"},{"location":"blog/2024/04/07/sdumont-upgrade/","title":"LNCC SDumont supercomputer upgrade","text":"<p>The National Scientific Computing Laboratory (LNCC) and Eviden/Atos signed a new contract worth us$ 19.4 million, which will allow the machine to go from the current 5.1 Petaflop/s to 17 Petaflop/s of capacity. The technology will be based on the BullSequana XH3000 architecture, and with the expansion it will be the most powerful supercomputer in Latin America dedicated to academic studies.</p> <p>https://agenciabrasil.ebc.com.br/geral/noticia/2024-04/supercomputador-mais-potente-do-pais-tera-capacidade-aumentada (in Portuguese)</p> <p>LNCC SDumont website (in Portuguese): https://sdumont.lncc.br/</p>"},{"location":"blog/2024/02/17/lncc-sdumont-supercomputer/","title":"LNCC SDumont supercomputer","text":"<p>Some related links I found interesting (mostly in Portuguese):</p> <ul> <li> <p>SDumont support manual: https://sdumont.lncc.br/support_manual.php</p> </li> <li> <p>LNCC Youtube channel: https://www.youtube.com/@LNCCbr</p> </li> <li> <p>2015 Simple presentation including some photos of the physical construction of the facilities: https://www.slideshare.net/RobsondaCosta2/supercomputador-sdumont-top500org-146-2015</p> </li> <li> <p>2016 Presentation. First SDumont architecture when it was first deployed: https://sdumont.lncc.br/media/01_General_overview_of_SANTOS_DUMONT_architecture.pdf</p> </li> </ul> <p>More info:</p> <ul> <li>http://eviden.com/insights/press-releases/eviden-expands-lncc-santos-dumont-supercomputer-capacity-fourfold-to-meet-growing-needs-of-academic-community/</li> </ul>"},{"location":"blog/2024/02/03/brazil-supercomputers-top500-nov2023/","title":"Brazil supercomputers top500 nov2023","text":"<p>Brazil currently has 9 supercomputers on the TOP500 list. The 500 most potent non-distributed computer systems in existence are ranked and described in detail by the TOP500 project. The last time LNCC's SDumont was included in the list, November 2022, it was in position 462.</p> <p>https://top500.org/</p> <p>The following list can be obtained directly from the top500.org website.</p> Rank System Cores Rmax (PFlop/s) Rpeak (PFlop/s) Power (kW) 45 P\u00e9gaso - Supermicro A+ Server 4124GO-NART+, AMD EPYC 7513 32C 2.6GHz, NVIDIA A100, Infiniband HDR, EVIDEN Petrobr\u00e1s Brazil 233,856 19.07 42.00 1,033 88 Drag\u00e3o - Supermicro SYS-4029GP-TVRT, Xeon Gold 6230R 26C 2.1GHz, NVIDIA Tesla V100, Infiniband EDR, EVIDEN Petrobr\u00e1s Brazil 188,224 8.98 14.01 943 111 Gaia - PowerEdge XE8545, AMD EPYC 74F3 24C 3.2GHz, NVIDIA A100, Infiniband, DELL EMC Petrobr\u00e1s Brazil 84,480 6.97 13.73 574 169 Atlas - Bull 4029GP-TVRT, Xeon Gold 6240 18C 2.6GHz, NVIDIA Tesla V100, Infiniband EDR, EVIDEN Petrobr\u00e1s Brazil 91,936 4.38 8.85 547 197 Gemini - PowerEdge XE8545, AMD EPYC 74F3 24C 3.2GHz, NVIDIA A100, Infiniband, DELL EMC Petrobr\u00e1s Brazil 42,240 3.86 6.86 287 205 IARA - NVIDIA DGX A100, AMD EPYC 7742 64C 2.25GHz, NVIDIA A100 SXM4 40 GB, Infiniband, Nvidia SiDi Brazil 24,800 3.66 4.13 217 NOBZ1 - ThinkSystem C2397, Xeon Platinum 8280 28C 2.7GHz, Broadcom, Lenovo Software Company MBZ Brazil 80,640 3.55 6.97 245 F\u00eanix - Bull 4029GP-TVRT, Xeon Gold 5122 4C 3.6GHz, NVIDIA Tesla V100, Infiniband EDR, EVIDEN Petrobr\u00e1s Brazil 60,480 3.16 5.37 390 475 A16A - ThinkSystem C0366, Xeon Gold 6252 24C 2.1GHz, 100G Ethernet, Lenovo Software Company MBZ Brazil 61,440 2.09 4.13 <p>SDumont on nov 2022 list</p> Rank System Cores Rmax (PFlop/s) Rpeak (PFlop/s) Power (kW) 462 Santos Dumont (SDumont) - Bull Sequana X1000, Xeon Gold 6252 24C 2.1GHz, Mellanox InfiniBand EDR, NVIDIA Tesla V100 SXM2, EVIDEN Laborat\u00f3rio Nacional de Computa\u00e7\u00e3o Cient\u00edfica Brazil 33,856 1.85 2.73 <p>SDumont is a Brazilian public supercomputer dedicated to teaching and research, and is the main machine of SINAPAD. The manufacturer is the French company Atos/Bull and has an installed processing capacity of around 5.1 petaflops peak, divided into 8 partitions: 4 partitions with CPU, 3 partitions with CPU + GPU, and 1 partition with CPU + Xeon Phi. SDumont should be in the TOP 500 with this capacity, but because it is partitioned, it can only run Linpack Benchmark on a single partition, only this being taken into consideration by the TOP500. A new upgrade is planned for 2024, boosting its capacity to 23 petaflops.</p>","tags":["top500"]},{"location":"blog/2024/02/02/wscad-and-sbac-pad/","title":"WSCAD and SBAC-PAD","text":"<p>The Symposium on High Performance Computing Systems (WSCAD), a national event organized by the Brazilian Computing Society (SBC) and the Institute of Electrical and Electronic Engineers (IEEE), aims to highlight the main developments, applications and trends in Computer Science. Computing for distributed systems, high-performance processing and architecture. The IEEE International Symposium on Computer Architecture and High Performance Computing (SBAC-PAD) is usually held annually in conjunction with the WSCAD event in October.</p> <p>http://wscad.sbc.org.br/edicoes/edicoes.html</p> <ul> <li>WSCAD conference proceedings: http://wscad.sbc.org.br/edicoes/edicoes.html</li> <li>WSCAD 2023 edition: https://inf.pucrs.br/wscad2023/</li> <li>WSCAD 2022 edition: http://wscad.sbc.org.br/</li> <li>Brazilian Computer Society (SBC) YouTube channel: https://www.youtube.com/@sbcoficial</li> </ul>"},{"location":"blog/2024/02/16/zenodo/","title":"Zenodo","text":"<p>Zenodo is a general-purpose open repository developed under the European OpenAIRE program and operated by the European Organization for Nuclear Research (CERN) and allows the deposit of research articles, datasets, research software, reports and any other related digital artifacts to research. For each submission, a persistent digital object identifier (DOI) is created, which makes stored items easily citable. It also allows the deposit of data sets of up to 50 GB. One supported source is GitHub repositories. It is hosted on CERN's high-performance computing infrastructure that is operated primarily for the needs of high-energy physics.</p> <p>https://zenodo.org/</p> <p>Lecture describing the use (in Portuguese): https://youtu.be/6tum4jq4mNs</p>","tags":["Zenodo"]},{"location":"blog/2023/08/24/zotero/","title":"Zotero","text":"<p>I use Zotero in my daily life to do my research. Zotero is a free and open source reference manager for bibliographic data and research materials. It features integration with web browsers, word processors, Google Docs, generation of in-text citations, footnotes and bibliographies, and has a built-in PDF reader with annotation capabilities. It was originally created at the Center for History and New Media at George Mason University.</p> <ul> <li>Website: https://www.zotero.org/</li> <li>Zotero on Wikipedia: https://pt.wikipedia.org/wiki/Zotero</li> <li>How To Use Zotero (A Complete Beginner's Guide): https://youtu.be/JG7Uq_JFDzE</li> </ul>","tags":["Zotero"]},{"location":"calculators/","title":"HP-41","text":"<p>The 1979 HP-41 series programmable calculator, which was produced until 1990, and was used in the Shuttle Space missions, has a processor called \"Coconut\" (or 1LE3 CPU), RAM, ROM, I/O, and uses the interpreted programming language FOCAL (\"Forty One Calculator Language\"). The operating system and the interpreter are stored in ROM, and were programmed using the Coconut processor assembly language also called MCODE (or \"M-Code\").</p> <ul> <li>https://en.wikipedia.org/wiki/HP-41C</li> <li>HP-41 Library</li> <li>A_programmers_handbook_v.2.07</li> <li>CPU Detailed Description</li> </ul>"},{"location":"calculators/#internals","title":"Internals","text":"<ul> <li>ROM listing:  [1],  [2],  [3]</li> </ul>"},{"location":"calculators/#links-of-interest","title":"Links of interest","text":"<ul> <li>Nonpareil RPN HP-41 Calculator Build</li> <li>go41c calculator Android App</li> <li>Online HP-41C OWNER\u2019S HANDBOOK AND PROGRAMMING GUIDE</li> </ul>"},{"location":"executables/","title":"My personal notes on generating executables on selected architectures","text":"<p>Repository: https://github.com/efurlanm/ldi/docs-src/executables/</p>"},{"location":"executables/#works","title":"Works","text":"<ul> <li>clang-aarch64.ipynb - My personal notes on Clang AArch64.</li> <li>flang-aarch64.ipynb - My personal notes on Flang AArch64.</li> <li>install-flang-aarch64.ipynb - Install Flang on aarch64.</li> <li>gcc_amd64.ipynb - Understanding executables. Running on a laptop with an i7-9750H processor.</li> <li>gcc_arm32.ipynb - Understanding executables. Running on an Orange Pi Zero, with 32-bit ARMv7-A Cortex-A7 architecture.</li> </ul>"},{"location":"executables/#links-of-interest","title":"Links of interest","text":"<ul> <li>ELF Executable_and_Linkable_Format diagram</li> </ul>"},{"location":"python/","title":"My personal notes on Python","text":"<p>Last edited: 2024-11-27</p> <p>This page contains my personal notes on Python-related topics that I find interesting. It is a work in progress and subject to constant change.</p>"},{"location":"python/#files-directories","title":"Files &amp; directories","text":"<ul> <li>cheatsheet/ -  Python Cheat Sheet, by Valdemar W. Setzer. The directory contains my attempt to help build the cheat sheet by describing some functions and modules that are not yet in the sheet.</li> <li>variables.ipynb - my personal notes on Python variables, which are a bit different, they are actually pointers to objects.</li> </ul>"},{"location":"python/#random-notes","title":"Random notes","text":"<ul> <li>Python is considered a dynamic and strongly typed language.<ul> <li>Strongly Typed: Python does not allow implicit operations between different types without explicit conversion. For example, adding a string to a number will generate an error unless the string is explicitly converted to a number.</li> <li>Dynamically Typed: The type of a variable is determined at runtime and can change as new values \u200b\u200bare assigned to it, meaning that a variable x adopts the type of the value assigned to it. For example, when executing the assignment x = 1, x will be of type integer. If the assignment x = 1.5 is then executed, x will become of type float.</li> </ul> </li> <li>Variables function as references (or pointers) to objects. When a value is assigned to a variable, it does not directly store the value, but rather a reference to the object that contains the value.</li> <li>Imutable variables: int, float, complex, str, tuple, frozenset, and bytes.</li> <li>Mutable variables: list, dict, set, bytearray, object (class instance).</li> </ul>"},{"location":"python/cheatsheet/","title":"Python Cheat Sheet","text":"<p>Last edited: 2024-11-27</p> <p>Python \u2013 Cheat Sheet, by Valdemar W. Setzer [Source, in Portuguese] - this directory contains my attempt to help build the cheat sheet by describing some functions and modules that are not yet in the sheet. It is a work in progress and subject to constant change.</p>"},{"location":"python/cheatsheet/#current-work","title":"Current work","text":"<ul> <li>Cheat Sheet (in English, Google Docs format) - document converted to English using Google Translate, and edited manually. Include suggestions. Corrections are highlighted in yellow, suggestions are highlighted in red, and the old text is highlighted in gray.</li> </ul>"},{"location":"python/cheatsheet/#history","title":"History","text":"<ul> <li>2024-11-26<ul> <li>Cheat Sheet (in Portuguese, Google Docs format) - original document in Portuguese with some suggestions in English for correcting some Portuguese errors using a grammar checker, and also some suggestions for additions to the text. Corrections are highlighted in yellow, suggestions are highlighted in red, and the old text is highlighted in gray.</li> </ul> </li> </ul>"},{"location":"python/cheatsheet/#notebooks","title":"Notebooks","text":"<ul> <li>cheasheeaux.ipynb - auxiliary Notebook used in the cheat sheet to confirm the operation of some items.</li> </ul>"},{"location":"python/cheatsheet/#other-files","title":"Other files","text":"<ul> <li>python-folha-de-consulta-v17.2.html - 2024-11-26 backup copy of the original document.</li> </ul>"},{"location":"python/cheatsheet/#resources","title":"Resources","text":"<ul> <li>Github Markdown</li> <li>Google Docs Markdown</li> <li>Markdown for Jupyter notebooks cheatsheet</li> <li>MarkText Markdown editor</li> </ul>"},{"location":"blog/archive/2024/","title":"2024","text":""},{"location":"blog/archive/2023/","title":"2023","text":""},{"location":"blog/category/ann/","title":"ANN","text":""},{"location":"blog/category/inpe/","title":"INPE","text":""},{"location":"blog/category/pinn/","title":"PINN","text":""},{"location":"blog/category/hpc/","title":"HPC","text":""},{"location":"blog/category/publication/","title":"Publication","text":""},{"location":"blog/category/virtualization/","title":"Virtualization","text":""},{"location":"blog/page/2/","title":"My Personal Blog","text":""},{"location":"blog/archive/2024/page/2/","title":"2024","text":""}]}